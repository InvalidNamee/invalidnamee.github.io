[{"content":"心理笔记整合 心理咨询预约 预约方式: 电话预约: 86981525(预约时需告知自己所在校区) 网上预约: 关注“石大心理”公众号，点击“心理咨询”预约。 现场预约: 校医院三楼 333-9 心理咨询值班室(仅限唐岛湾校区) 接待时间: 唐岛湾校区：周一至周日上午8:30-11:40，下午2:30-5:40，晚上19:00-20:50 古镇口校区：周一至周五同上，周六上午8:30-11:40 接待地点: 唐岛湾校区: 校医院三楼333-9 古镇口校区：3号公寓楼144(古镇口校区仅接受电话和网络预约) 心理学绪论 心理学的概念 又称心理科学，研究心理现象及其规律的科学\n心理现象 感知觉 记忆 想象，思维 情感 意志 行为 心理学诞生的标志 1879 年冯德特在德国莱比锡建立第一个心理学实验室，标志着心理学诞生\n心理问题的概念 所有各种心理行为异常的情形\n心理问题的类型 心理困扰 心理障碍 精神疾病 心理健康 认知 情感意志 行为 人格协调 心理健康的标志 对生活充满爱，充满向往，觉得生活充满乐趣 稳定的情绪 有较强的适应能力 解决心理问题的关键是认知态度 具有允许心理问题存在的态度 认识到心理问题是无法彻底消除的 允许自己不完美的你才能更完美。\n自我意识 概念 人对自己身心状态及对自己同世界关系的意识\n内容 生理自我 心理自我 社会自我 偏差 自我中心 自负 自卑 从众 相关效应 焦点效应 透明效应 自我妨碍效应 积极心理学 什么是幸福 愉悦感 价值感 满意感 没有幸福感 活在过去 活在未来 提升幸福感，公式 H = S + C + V C 生活环境(10%～15%) S 先天决定的幸福水平 幸福的感知能力(50%) V 自我可控制的因素 积极心理学的核心(35～40%) 培养乐观的 ABCDE 模式 A(adversity) 代表不好的事 B(belief) 代表事情发生时自动出现的念头、想法 C(consequence) 代表这想法产生的后果 D(disputation) 代表反驳 E(energization) 代表你成功进行反驳后收到的激发 幸福感 愉悦：感官(克服习惯化，品味正念) 满意：自己优势的发挥(挑战性……) 爱情 亟待补充\nq2-问世间情为何物\n斯滕伯格爱情三角理论\n如图所示\nq3-人们为什么要谈恋爱，不谈行不行？\n马斯洛需求层次理论，其中爱情、性亲密属于归属需求\n埃里克森八阶段人格发展理论\n阶段 大致年龄 心理社会性发展阶段 正性结果 负性结果 青少年期 12-18岁 同一性对角色混乱 意识到自我独特性，清晰自己的角色 不能识别生命中适当角色 成年早期 18·25岁 亲密对孤独 建立性爱关系和亲密的友谊 对与他人建立关系感到恐惧 我们处于成年早期\nq4-人际关系影响因素\n“始于颜值，忠于人品”\n外表 50% 与外表有关；40% 与声音有关； 10% 与言语举止有关 才能 人格特质(最稳定的，最重要的因素之一) 时间和空间 时间因素 交往的机会、频率。一般来说，交往频率越高，越容易相互了解 空间因素 指交往双方距离的远近。“近水楼台先得月“，”远亲不如近邻“。 态度相似性(在理想，信念，价值观，兴趣爱好方面有不同的态度) 互补性(相似性的作用 \u0026raquo; 互补性) q5-要不要表白，什么时候表白？(表达爱的能力)\n约翰·范·埃普提出关系依恋模型 R.A.M. 在建立恋爱关系时应依次经历\n了解对方(Know) 家庭背景 道德感 匹配潜能 过去行为模式 关系技能 建立信任(Trust) 产生依赖(Rely) 给出承诺(Commit) 身体接触(Touch) 五个阶段。\n学会表达爱\n表白有风险(确定对方心意) 切忌道德绑架，作秀请谨慎 照顾到对方的情绪与感受 原则：真诚、尊重、适度 q6-接受爱的能力\nq7-如何婉拒别人的爱意(拒绝爱的能力)\n委婉而坚定的拒绝一份不想要的感情是一件需要勇气的事情！\n感谢对方爱的表达 温和而坚定地说明自己没有意愿 不进行人身攻击 q10-阶段\n共存(甜蜜期) 反依赖(矛盾潜伏期) 怀疑(矛盾突发期) q11-安全感\nq13-如何吵架让我们的感情“越吵越好”(解决冲突的能力)\n吵架不隔夜 摆正态度，以解决问题为目的吵架 平等 先解决情绪，再解决问题！！！ 关注情绪的正确表达 正向表达\n看到/听到的现实是什么 你的想法是什么 你的感受 你的期待 or 需求 守护爱\n共生(稳定期) 时间久了，吵累了，新的相处之道也就形成了，两个人开始意 识到感情的不易，相互珍惜，牵手走完一生。 q14-爱情如何保鲜？——爱的五种语言\n肯定的言词 需要赞美鼓励、安慰、甜言蜜语 精心的时刻 精心的时刻是给予对方全部的注意力，让对方感受到你专注于他/她 接受的礼物 爱，给予，礼物是我们表达和传递爱的媒介，是爱的视觉象征 服务的行动 爱需要落实的行动 身体的接触 身体的接触是亲密关系的表现与升华 q15-如何面对并走出失恋\n你努力了吗？认真对待了吗？ 接纳事实，接纳感受，允许自己痛苦 转移注意力 向外求助(朋友、父母、犀利咨询机构等) 失恋一定会痛苦，并不意味着你不好，过去的美好是真实的，未来的美好也是会来的😭\nq16-如何看待恋爱的开始和结束，正确的恋爱观？\n你好不好，ta 好不好？ ta 对你好不好，你对 ta 好不好？ ta 对你的好是不是你需要的好？你对 ta 的好是不是 ta 需要的好？ q17-存在完美的爱情吗，存在天造地设的一对吗？\n爱情陷阱：完美伴侣\n这世上从来没有天造地设的爱情，有的不过是在相互磨合中越来越坚定的两颗心。白头偕老的秘密，也从来不是“我们相爱就行了”，还包括各退一步、相互服软、轮流低头，以及允许“你是你，我是我”。\nq18-？？？\n爱人要爱己\n弗洛姆: 先要具备创造性的健全人格，使自己成为成熟的人，才有谈爱的能力。因为成熟的爱，是在保留自身完整性和独立性的情况下，与他人的结合。——《爱的艺术》\n创造性的健全人格，最重要的一个标准在于: 自爱 我们要先学会爱自己，而后才有能力去爱别人 并且要记得：爱自己是一生的！ 爱情陷阱: 有你，我才完整\n健康的关系应该是无论自己有没有伴侣，你都是完整的\n坚持自己的立场，不会因为害怕被拒绝，被抛弃而退缩\n压力 大学生常见的压力来源 学习 难度大、负担重 专业不满意 效能低 人际 个人情感 同学关系 师生关系 家庭 父母关系 教养方式 经济状况 事件 失恋、丧亲 灾害 发展 完美倾向 目标不清 理想和现实的差距 什么是压力 也叫应激，是一种反应模式，当刺激时间打破了有机体的平衡和符合能力，或者超过了个体能力所及，就会表现为压力。\n通俗的来讲，就是面对挑战、威胁，所拥有的资源与要求有所差距时内在的感受。\n压力下的反应 生理反应(长期压力下身体会报警)\n汗流量增加，恶心，胸闷，头痛 身体疲劳，肌肉紧张，尤其是头、颈、肩、背的紧张 心率加快，血压增高 皮肤干燥，有斑点和刺痛(皮肤对压力特别敏感) 消化系统问题，如胃痛、消化不良、腹泻、便秘 睡眠不好，精神萎靡，注意力很难集中 心理反应\n焦虑\n身体应对压力的反应；压力会发展成焦虑。 焦虑是一种过分担心和害怕的情绪状态，通常来自对未来的担心、错误的认知、外部突发事件、躯体疾病等。 短暂的焦虑对人体没有危害，可以作为一种警示信号，帮助人体应对当前或将要出现的危险状况 焦虑、紧张、迷惑、烦躁、敏感、喜怒无常 精神疲劳，错觉和思维混乱增加 感情压抑，兴趣和热情减少，厌倦工作 意志消沉，自信心不足，出现悲观失望和无助的心理 短期和长期记忆力减退 到的和情感准则削弱 行为反应\n拖延\n特别越南的事情越想拖，不胜任感，不知道如何做 害怕失败 后果: 自责、懊悔、难受、痛苦，影响任务完成的实际效果。夜不能寐，食之无味。 工作懈怠、能力降低，错误率增加。 放纵自己，自暴自弃 没胃口，吃得少，体重迅速下降 孤僻、抑郁、自闭、烦躁不安 冒险行为增加，包括不顾后果的驾车和赌博 攻击、侵犯他人，破坏公共财产 与家庭和朋友的关系恶化 自杀或企图自杀 战斗\n努力学习，拼绩点，关注他人 努力融入充满挑战的新环境 努力和同学建立关系 主动分析压力源: 明确问题所在，指定解决方案 寻求外部支持: 向他人求助或获取资源 情绪宣泄: 通过合理方式释放压力 压力本身不是问题，如何看待压力才是问题 把压力看作助力的话，生理会发生变化\n压力适当理论，Anderson，1987\n一个概念：习得性无助\n压力应对模型\n情感情绪应对\n冲动第一步：识别 冲动第二步：看看周围有什么物品可以让自己抓住 冲动第三部：做出选择(立足此时此刻) 正念 STOP: 停止 - 呼吸 - 觉察(开放/聚焦) - 继续\n认知行为应对\nABCDEF 认知管理技术\nA. 事件 B. 旧认识 C. 不良情绪 D. 辩驳 E. 新认识 F. 情绪改善 ABC 是一种”惯性”\n调整认知评估方式\n改变你与应激源评价的关系 我们越是认同这个标签，越是无法区分彼此，也就越不可能认为自己能够超越这个标签。因此标签经过了验证我是失败的，也成了不去进行一系列重要而有意义活动的理由。 明确目标是什么 建立对应激源的知觉控制 你对于改变事件或经历的进程或结果的信念 摒弃非理性信念 不要高估或者低估目己的能力 认识自己的限制、长处及弱点 保持开放性评价 处理事情保持弹性 形成正确的归因方式 具体有效的行动才能缓解压力\n控制自己的行动，做那些让自己的生活尽可能美好的事情 建立并持续改善社会支持系统\n社会资源\n第一层: 近亲 第二层: 知己好友 第三层: 一般朋友、社会机构 主动求助，善于求助：自助是一种能力 维护现有的社会支持系统 加深支持性人际关系：学习从良好的人际关系中获得温暖、爱、归属、安全感 放松训练\n身体应对\n呼吸调解法 腹式呼吸 肌肉松弛法 渐进式肌肉放松 运动 40min有氧运动 1w步 快走、爬楼 睡眠调节 7～9h 有条件午休 15～30min 将压力转化成创造力的最好方式 大学生人际交往和沟通 大学生人际交往中的常见问题 不敢交往 不会交往 不想交往 不良交往 概念 人际交往: 社会生活、活动过程中，人与人之间的信息交流、心理交流及相互作用的过程，一般认为是动态过程。 人际关系: 通过人际交往而形成的人与人之间的稳定的在心理或行为产生相互影响的过程，一般认为是静态过程。 为什么有人际关系 埃里克森人格八阶段发展理论 我们处于成年早期，任务是建立亲密关系(矛盾是亲密对孤独) 如果一个人不能与他人分享快乐与痛苦，不能与他人进行思想情感的交流，不互相关心与帮助，就会陷入孤独寂寞的苦恼情境之中 良好人际关系的意义 大学生正处在一种渴求交往，渴求理解的心理发展时期。\n大学生身心健康的需要\n“人际剥夺”实验 是获得安全感和幸福的需要\n马斯洛需求层次理论 哈多大学研究院的实验 孤独有害健康，良好的人际关系让人更长寿，更幸福 人际关系更在于质量，配偶关系(最重要) 是人发展与成功的重要保证\n人一生成长、发展和成功，无不与同他人的交往想联系，并且通过从人际关系中得到信息、机遇，帮助人们走上一条成功之路。\n人际关系的建立与发展的过程 定向阶段 - 情感探索阶段 - 情感交流阶段 - 稳定交流阶段\n顺序不可逆 时间可能长短不一 能到情感交流阶段已经非常好了 人际交往中的心理学效应 首因效应: 也称第一印象，是指初次见面时对人形成的鲜明印象，这种由先前的信息而形成的最初的印象及其对后来信息的影响即为首因效应。有先入为主的作用。 要懂得通过现象看本质，不要被对方的第一印象所迷惑。 近因效应: 也称最近印象，是指最近获得的信息对人的知觉和认识产生的强烈影响，主要发生在与熟悉的人的交往之中。最后留下的印象，往往是最深刻的印象。 与人交往不能进根据一时一事去评价他人，被暂时的、个别的行为所迷惑。 晕轮效应: 也称光环效应，是指在人际交往中仅仅依据某人身上一种或几种特征来概括其他一些未曾了解的人格特征的心理倾向。 不可以以偏概全，不仅要听从心的声音，也要听从大脑的声音。 刻板效应: 刻板效应又称定型效应，是指人们用刻印在自己头脑中的关于某人、某事物的固定印象，以此作为判断和评价人依据的心理现象。在人际交往中，刻板效应常使人们对他人的认知固定化。 “人心不同，各如其面”，刻板印象是一种概括而笼统的看法，并不能代替活生生的个体，与人交往不能“以偏概全，不能戴着“有色眼镜”去看人。 投射效应: 是指以己度人，认为自己具有某种特性，他人也一定会有与自已相同的特性，把自己的感情、意志、特性投射到他人身上并强加于人的一种认知障碍。 感情投射：即认为别人的喜好与自己相同，将自己的思维方式强加给对方 认知缺乏客观性：把自己的感情投射到他人或事物之上，认为自己喜欢的人或物都是美好的，自己厌恶的都是丑陋的，“以小人之心度君子之腹” 皮革马利翁效应(罗森塔尔效应): 亦称“罗森塔尔效应”或“期待效应”，你期望什么，你就会得到什么，你得到的不是你想要的，而是你期待的。有美国著名心理学家罗森塔尔提出。 练习题\n答案是: 马斯洛 亲密对孤独 晕轮效应 晕轮效应 首因效应 要分清自己的想法和他人的想法\n人际交往的原则 真诚守信原则 尊重平等原则 你好我也好 互助互惠原则 尊重距离原则 公共距离区 \u0026gt; 4m 社交距离区 1.3 ~ 4m 个体距离区 0.5 ~ 1.3m 亲密距离区 0 ~ 0.5m 人际交往的法则 黄金法则: 你想别人怎么对你，你就怎么对别人 白金法则: 别人希望你怎么样对待他们，你就怎么对待他们 反黄金法则: 我怎么对别人，别人就应该怎么对我 技巧 技巧一：不拿自己的标准要求别人 “应该、必须、一定要的绝对话要求” 不管这些规则在大多数时候有多精准，我们必须意识到，它只是我们单方面的期待，有时候甚至是幻想。 你可以打破规则，不必遵守别人对你的「预期」。你无需要求自己按别人期待的反应方式区反应。 技巧二：做好核对(处理情绪内耗最好的方式) 核对不仅能够避免误会，还能有效促成良好沟通。 尊重自己感受，减少自己的不舒服 沟通间的核对，是核对对方的想法是否和你猜测的一致 沟通中尽力做到开放、不评判、以及表达真实感受 人际交往的核心——沟通 接纳 沟通的前提\n学会倾听\n以自己为中心的假倾听者\n智者 你应该按我的做 乐观者 这没有那么早，至少你还没和他绝交 乌鸦嘴 那可惨了，他会不会去说你坏话啊 八卦者 快和我说说，你们是怎么吵的 主角 你这不算什么，以前我和人吵架…… 段位？层次？\n第一层: 心不在焉 第二层: 消极地听 第三层: 选择性听 第四层: 专注聆听 第五层: 积极聆听 共情\n关注情绪: 把强迫性建议改成与对方情绪同步的话语。 强迫性建议 与对方情绪同步的话语 这算什么 你经历了那么多，你已经很勇敢了 不要消极 痛苦是生活的一部分，是个人都要经历 没有什么过不去的 这段经历对你来说确实很难 你开心点，别太担心 我看你最近压力很大，有什么我可以帮你 你得乐观点 无论好坏我都会支持你 提升倾听技巧的 3F 模型\n事实 Fact\n分清事实 对方陈述了什么事实\n情绪 Feel\n感受情绪 对方表达了什么情绪\n期待 Focus\n理解意图 对方期待我做什么行动\n反向使用 3F\n情绪 Feel\n响应情绪 接纳对方的情绪\n事实 Fact\n确认事实 通过复数确认事实或得到信息补充\n意图 Focus\n明确意图 把对方的期待翻译成可实施的行动\n好的倾听 = 心里听进去 + 愿意听的姿态 + 恰到好处的反馈\n60分 复读机 70分 情感镜子 80分 支出希望和期待 90分 表达关心，共同解决 学会表达\n描述事实(观察)——我看到…… 表达感受(感受)——我觉得…… 表达需求(需要)——我希望得到…… 提出请求(请求)——你可以……吗 表达自己的情感就是让别人“看见”自己内心活动的过程。\n学习说话的艺术\n第一件事\n急事，慢慢的说\n大事，清楚的说\n小事，幽默的说\n第二件事\n没把握的事，谨慎的说\n没发生的事，不要胡说\n做不到的事，别乱说\n上海人的事，不能说\n第三件事\n讨厌的事，对事不对人的说\n开心的事，看场合说\n伤心的事，不要见人就说\n别人的事，小心的说\n","date":"2025-06-09T21:18:01+08:00","permalink":"https://invalidnamee.github.io/p/xinli-note/","title":"心理笔记"},{"content":"A. 评估 关键在于 \\(|a_i| \\le 1000\\)，所以可以开一个长度为 2000 的数组统计一下每个值的个数，然后 \\(\\Theta(n^2)\\) 处理这个 2000 的数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 2010; int a[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); a[t + 1000]++; } long long res = 0; for (int i = 0; i \u0026lt;= 2000; ++i) { for (int j = i + 1; j \u0026lt;= 2000; ++j) { res += (long long)a[i] * a[j] * (i - j) * (i - j); } } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } B. 拆分数字 记 n 在三进制表示下的各位数之和为 t，想要满足要求的充要条件是 \\(t \\le k \\le n\\ \\land\\ t \\equiv k\\ (mod\\ 2)\\).\n首先考虑边界情况，如果全用 1 那么需要 n 个；如果选择最优方案，全部按照三进制的表示那么需要 t 个；\n其次考虑内部，按照要求，无论怎么拆，一个 3 的幂只能拆成奇数个更小的幂，所以最优方案拆出来的个数的奇偶性和任何方案的奇偶性相同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { long long n, k; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;k); long long bit = 0; bool f = false; while (n) { f ^= (n % 3) \u0026amp; 1; bit += n % 3; n /= 3; } if (bit \u0026lt;= k \u0026amp;\u0026amp; !(f ^ (k \u0026amp; 1))) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); } return 0; } C. 露营 比较水，直接枚举一个中间点向三个点分别连线就行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; int dis(pair\u0026lt;int, int\u0026gt; a, pair\u0026lt;int, int\u0026gt; b) { return abs(a.first - b.first) + abs(a.second - b.second); } int main() { pair\u0026lt;int, int\u0026gt; a[3]; for (int i = 0; i \u0026lt; 3; ++i) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[i].first, \u0026amp;a[i].second); int res = 0x3f3f3f3f; for (int i = 0; i \u0026lt;= 1000; ++i) { for (int j = 0; j \u0026lt;= 1000; ++j) { pair\u0026lt;int, int\u0026gt; cur = {i, j}; res = min(res, dis(cur, a[0]) + dis(cur, a[1]) + dis(cur, a[2]) + 1); } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } D. 寻宝 思路比较简单，实际操作有点复杂\n能放法术一定是最开始连续放，让前面都是 a，所以先做一个二维 dp 求出来左上角到每个点路径上最多 a 的个数。\n遍历一遍 dp 的数组，找到能达到最长 a 的位置（可以是多个），从每个位置跑记搜（反拓扑序dp），dp 出后续的最优路线。\n这道题需要注意爆空间的问题，不能每个点都存字符串，应该存一个方向或者下一个点的位置，比较字典序的时候按照记录的信息递归比较。\n另外还要特判\n如果一开始就没有 a，也不能施法的情况。\nk 太大的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 1010; char a[N][N]; int f[N][N]; int n, k; bool vis[N][N], ne[N][N]; // 0 下 1 右 bool le(int x1, int y1, int x2, int y2) { while (x1 != n || y1 != n) { if (a[x1][y1] != a[x2][y2]) return a[x1][y1] \u0026lt; a[x2][y2]; else { bool flag = ne[x1][y1]; x1 = flag ? x1 : x1 + 1, y1 = flag ? y1 + 1 : y1; flag = ne[x2][y2]; x2 = flag ? x2 : x2 + 1, y2 = flag ? y2 + 1 : y2; } } return true; // 相等，随便了 } void dp(int x, int y) { if (vis[x][y]) return; vis[x][y] = true; if (x == n \u0026amp;\u0026amp; y != n) { dp(x, y + 1); ne[x][y] = 1; } else if (x != n \u0026amp;\u0026amp; y == n) { dp(x + 1, y); ne[x][y] = 0; } else if (x != n \u0026amp;\u0026amp; y != n) { dp(x + 1, y), dp(x, y + 1); if (le(x + 1, y, x, y + 1)) ne[x][y] = 0; else ne[x][y] = 1; } } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%s\u0026#34;, a[i] + 1); } int mxd = 0; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { f[i][j] = max(f[i - 1][j], f[i][j - 1]) + (a[i][j] == \u0026#39;a\u0026#39;); if (f[i][j] + k \u0026gt;= i + j - 1) mxd = max(mxd, i + j - 1); } } if (mxd == n * 2 - 1) { for (int i = 1; i \u0026lt; 2 * n; ++i) { printf(\u0026#34;a\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } else if (!mxd) { dp(1, 1); int px = 1, py = 1; while (px != n || py != n) { printf(\u0026#34;%c\u0026#34;, a[px][py]); bool flag = ne[px][py]; px = flag ? px : px + 1, py = flag ? py + 1 : py; } printf(\u0026#34;%c\\n\u0026#34;, a[n][n]); } else { int px = 0, py = 0; for (int i = 1; i \u0026lt;= n; ++i) { int j = mxd + 1 - i; if (f[i][j] + k == i + j - 1) { dp(i, j); bool flag = ne[i][j]; int npx = flag ? i : i + 1, npy = flag ? j + 1 : j; if (!px || le(npx, npy, px, py)) px = npx, py = npy; } } for (int i = 0; i \u0026lt; mxd; ++i) printf(\u0026#34;a\u0026#34;); while (px != n || py != n) { printf(\u0026#34;%c\u0026#34;, a[px][py]); bool flag = ne[px][py]; px = flag ? px : px + 1, py = flag ? py + 1 : py; } printf(\u0026#34;%c\\n\u0026#34;, a[n][n]); } return 0; } E. 饼干 1 2 n, m = map(int, input().split()) print(n // m) F. 方差 水题++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; long long a[N]; int main() { int n; long long ave = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); ave += a[i]; } ave /= n; long long res = 0; for (int i = 1; i \u0026lt;= n; ++i) { res += (a[i] - ave) * (a[i] - ave); } printf(\u0026#34;%lld\\n\u0026#34;, res / n); return 0; } G. 正方形划分 二维的有点乱，思路比较好猜，但是不好操作。\n对于操作 0， 可以用一种类似二分的思路（但是在二维空间应该叫四分\n\\[?\\]）分别给行号和列号一个左右端点，不断求中间的点，输出目标点相对中间点位置对应的字母，然后缩小区间直到左右端点重叠，循环结束。\n对于操作 1，和之前类似，这次是通过给出的序列确定相对位置，缩小区间，相当于是反着来的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int T; cin \u0026gt;\u0026gt; T; while (T--) { int op; cin \u0026gt;\u0026gt; op; if (!op) { int n, x, y; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; int lx = 1, ly = 1, rx = 1 \u0026lt;\u0026lt; n, ry = 1 \u0026lt;\u0026lt; n; while (lx != rx || ly != ry) { int mid_x = lx + rx \u0026gt;\u0026gt; 1, mid_y = ly + ry \u0026gt;\u0026gt; 1; if (x \u0026lt;= mid_x \u0026amp;\u0026amp; y \u0026lt;= mid_y) { cout \u0026lt;\u0026lt; \u0026#39;A\u0026#39;; rx = mid_x, ry = mid_y; } else if (x \u0026lt;= mid_x \u0026amp;\u0026amp; y \u0026gt; mid_y) { cout \u0026lt;\u0026lt; \u0026#39;B\u0026#39;; rx = mid_x, ly = mid_y + 1; } else if (x \u0026gt; mid_x \u0026amp;\u0026amp; y \u0026lt;= mid_y) { cout \u0026lt;\u0026lt; \u0026#39;C\u0026#39;; lx = mid_x + 1, ry = mid_y; } else { cout \u0026lt;\u0026lt; \u0026#39;D\u0026#39;; lx = mid_x + 1, ly = mid_y + 1; } } cout \u0026lt;\u0026lt; endl; } else { string s; cin \u0026gt;\u0026gt; s; int n = s.length(); int lx = 1, ly = 1, rx = 1 \u0026lt;\u0026lt; n, ry = 1 \u0026lt;\u0026lt; n; for (int i = 0; i \u0026lt; n; ++i) { if (s[i] == \u0026#39;A\u0026#39;) { rx = lx + rx \u0026gt;\u0026gt; 1; ry = ly + ry \u0026gt;\u0026gt; 1; } else if (s[i] == \u0026#39;B\u0026#39;) { rx = lx + rx \u0026gt;\u0026gt; 1; ly = (ly + ry \u0026gt;\u0026gt; 1) + 1; } else if (s[i] == \u0026#39;C\u0026#39;) { lx = (lx + rx \u0026gt;\u0026gt; 1) + 1; ry = ly + ry \u0026gt;\u0026gt; 1; } else { lx = (lx + rx \u0026gt;\u0026gt; 1) + 1; ly = (ly + ry \u0026gt;\u0026gt; 1) + 1; } } if (lx == rx \u0026amp;\u0026amp; ly == ry) cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; lx \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ly \u0026lt;\u0026lt; endl; else return 123; } } return 0; } ","date":"2025-06-08T09:04:41Z","permalink":"https://invalidnamee.github.io/p/2025st28/","title":"2025春训第二十八场"},{"content":"A. 序列 逻辑非常简单，先输出 k 个 0 之后 01 交替输出直到把 0 用完，最后输出剩下的 1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n, m, k; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); for (int i = 1; i \u0026lt;= k; ++i) { printf(\u0026#34;0\u0026#34;); m--; } while (n || m) { if (n) printf(\u0026#34;1\u0026#34;), n--; if (m) printf(\u0026#34;0\u0026#34;), m--; } printf(\u0026#34;\\n\u0026#34;); return 0; } B. 异或之力 也比较容易，不难想到最优方案是取 11111…0，因为这是个偶数，对半分异或 = 0；任意从中间断开，然后异或还是原数，答案是 \\(2^{n} - 2\\).\n需要特判 2，因为 2 只能分出正整数 1，答案是 0.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; const int MOD = 1e9 + 7; int power(int n, int p) { long long res = 1, base = n; while (p) { if (p \u0026amp; 1) res = res * base % MOD; base = base * base % MOD; p \u0026gt;\u0026gt;= 1; } return res; } int main() { int n; cin \u0026gt;\u0026gt; n; if (n \u0026lt;= 2) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; (power(2, n) - 2 + MOD) % MOD \u0026lt;\u0026lt; endl; return 0; } C. 队伍集结 看着吓人，实则不是，直接暴力 \\(\\Theta(n^4)\\) 预处理所有区间的最小不满度，然后开一个二维状态 \\(f_{i, j}\\) 表示以 i 结尾的区间加了 j 个汇合点时不满都的最小值，枚举最后一段区间 dp 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 210; long long d[N], f[N][N], s[N][N]; int main() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; ++i) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; d[a + 1] += b; } memset(f, 0x3f, sizeof(f)); memset(s, 0x3f, sizeof(s)); for (int i = 1; i \u0026lt;= 201; ++i) { for (int j = i; j \u0026lt;= 201; ++j) { for (int k = i; k \u0026lt;= j; ++k) { long long res = 0; for (int l = i; l \u0026lt;= j; ++l) { res += (long long)(l - k) * (l - k) * d[l]; } s[i][j] = min(s[i][j], res); } } } f[0][0] = 0; for (int i = 1; i \u0026lt;= 201; ++i) { for (int j = 1; j \u0026lt;= k; ++j) { // 使用次数 for (int l = 1; l \u0026lt;= i; ++l) { f[i][j] = min(f[i][j], f[l - 1][j - 1] + s[l][i]); } } } cout \u0026lt;\u0026lt; f[201][k] \u0026lt;\u0026lt; endl; return 0; } D. 花 子树在 dfs 序下一定是一段连续区间，把节点按 dfs 序建一棵线段树维护单点修改和区间查询即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010; vector\u0026lt;int\u0026gt; ed[N]; int dfn[N], cnt[N], t; int tr[N * 4]; int a[N]; void dfs(int x, int fa) { dfn[x] = ++t; cnt[x] = 1; for (int y : ed[x]) { if (y == fa) continue; dfs(y, x); cnt[x] += cnt[y]; } } void pushup(int u) { tr[u] = max(tr[u \u0026lt;\u0026lt; 1], tr[u \u0026lt;\u0026lt; 1 | 1]); } void modify(int u, int l, int r, int p, int val) { if (l == r) tr[u] = val; else { int mid = l + r \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) modify(u \u0026lt;\u0026lt; 1, l, mid, p, val); else modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, p, val); pushup(u); } } int query(int u, int l, int r, int ql, int qr) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return tr[u]; else { int mid = l + r \u0026gt;\u0026gt; 1; int res = 0; if (ql \u0026lt;= mid) res = query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr); if (qr \u0026gt; mid) res = max(res, query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr)); return res; } } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt; n; ++i) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); ed[a].push_back(b); ed[b].push_back(a); } dfs(1, 0); for (int i = 1; i \u0026lt;= n; ++i) { modify(1, 1, n, dfn[i], a[i]); } while (m--) { int op; scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); if (op == 1) { int u, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;w); modify(1, 1, n, dfn[u], w); } else { int u; scanf(\u0026#34;%d\u0026#34;, \u0026amp;u); printf(\u0026#34;%d\\n\u0026#34;, query(1, 1, n, dfn[u], dfn[u] + cnt[u] - 1)); } } return 0; } E. 分糖果 水题\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; (b + a - 1) / a \u0026lt;\u0026lt; endl; return 0; } F. 新字典 水题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; int p[26]; char check(string a, string b) { int l = min(a.length(), b.length()); for (int i = 0; i \u0026lt; l; ++i) { if (a[i] != b[i]) return p[a[i] - \u0026#39;a\u0026#39;] \u0026lt; p[b[i] - \u0026#39;a\u0026#39;] ? \u0026#39;s\u0026#39; : \u0026#39;t\u0026#39;; } return a.length() \u0026lt; b.length() ? \u0026#39;s\u0026#39; : \u0026#39;t\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; string s, t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; int T; cin \u0026gt;\u0026gt; T; while (T--) { string dic; cin \u0026gt;\u0026gt; dic; for (int i = 0; i \u0026lt; 26; ++i) p[dic[i] - \u0026#39;a\u0026#39;] = i; cout \u0026lt;\u0026lt; check(s, t) \u0026lt;\u0026lt; endl; } return 0; } G. 机器人 二分答案，需要注意二分下界是 \\(\\max_{i=1}^na_i\\)，初始任务也是任务😭\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;climits\u0026gt; #define int long long using namespace std; const int N = 100010; int n, m, t; int a[N]; bool check(int mid) { long long cnt = 0; for (int i = 1; i \u0026lt;= m; ++i) { cnt += max(0ll, (mid - a[i]) / t); } return cnt \u0026gt;= n; } signed main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; t; int l = 0, r = 1000000000000; for (int i = 1; i \u0026lt;= m; ++i) { cin \u0026gt;\u0026gt; a[i]; l = max(l, a[i]); } while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; return 0; } H. 游戏 基础的二维 dp， \\(f_{i, j}\\) 表示第 i 天还剩 j 资源能获得的最大强度值，每天枚举所有的 j 和买不买更新状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 5010; int f[N][N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); memset(f, -0x3f, sizeof(f)); f[0][0] = 0; for (int i = 1; i \u0026lt;= n; ++i) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); for (int j = 0; j \u0026lt; i; ++j) { // 不买 f[i][j + 1] = max(f[i][j + 1], f[i - 1][j]); // 买 if (j + 1 \u0026gt;= a) { f[i][j + 1 - a] = max(f[i][j + 1 - a], f[i - 1][j] + b); } } } int res = 0; for (int i = 0; i \u0026lt;= n; ++i) res = max(res, f[n][i]); printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } I. ABB 水题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; set\u0026lt;string\u0026gt; a; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n; cin \u0026gt;\u0026gt; n; string s; cin \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt; s.length() - 2; ++i) { if (s[i] != s[i + 1] \u0026amp;\u0026amp; s[i + 1] == s[i + 2]) a.insert(s.substr(i, 3)); } cout \u0026lt;\u0026lt; a.size() \u0026lt;\u0026lt; endl; return 0; } J. 负重爬楼梯 水题（线性 dp）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 100010; int a[N]; long long f[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } memset(f, 0x3f, sizeof(f)); f[1] = a[1]; f[0] = 0; for (int i = 2; i \u0026lt;= n; ++i) { f[i] = min(f[i - 2] + a[i], f[i - 1] + a[i]); } printf(\u0026#34;%lld\\n\u0026#34;, min(f[n], f[n - 1])); return 0; } K. 洒水器 直接暴力维护等差数列不好维护，但是我们可以维护等差数列的差分数列，等差数列公差一定，所以这个差分数列可以再用它的差分数列维护，最后前缀和两次输出答案即可。\n需要特判左边界，不需要特判右边界，因为已经出界了无所谓了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; long long s[N]; int p[N]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;p[i]); } for (int i = 1; i \u0026lt;= n; ++i) { int w; scanf(\u0026#34;%d\u0026#34;, \u0026amp;w); int lp = max(p[i] - w + 1, 1), rp = min(p[i] + w - 1, m); s[lp] += w - abs(p[i] - lp); s[lp + 1] -= w - abs(p[i] - lp); s[lp + 1] += 1; s[p[i] + 1] -= 2; s[rp + 2]++; } for (int i = 1; i \u0026lt;= m; ++i) { s[i] += s[i - 1]; } for (int i = 1; i \u0026lt;= m; ++i) { s[i] += s[i - 1]; printf(\u0026#34;%lld \u0026#34;, s[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } ","date":"2025-06-07T12:58:30Z","permalink":"https://invalidnamee.github.io/p/2025st27/","title":"2025春训第二十七场"},{"content":"题面可以看这里.\nA. 数列计数 最害怕的数学题。\n\\(\\prod_{i=1}^{n}\\binom{a_i}{b_i} \\) 等价于对于每一个 i，都有 \\(\\binom{a_i}{b_i}\\) 为奇数。\n对于 \\(\\binom{n}{k}\\)，根据（ChatGPT指出的）卢卡斯定理，取 p = 2 有\n\\[\\binom{n}{k} \\equiv \\binom{n\\ \\text{mod}\\ 2}{k\\ \\text{mod}\\ 2} \\binom{\\lfloor\\frac{n}{2}\\rfloor}{1}\\ (\\text{mod}\\ 2)\\]\n右边这一项同理可以不断展开，最终等价于**取出了 n 和 k 的所有二进制位算组合数再乘积。**显然要想保证是奇数，只能 k 的每个二进制位都不比 n 大。\n对于每一项做一次数位 dp，统计每一位都比 \\(a_i\\) 小的数的个数即可，时间复杂度是 \\(\\Theta(n\\log 10^9)\\)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; const int MOD = 998244353; int a[N]; long long f[31][2]; // 第i位，是否顶上界 int dp(int a, int l) { f[30][1] = 1; for (int i = 29; i \u0026gt;= 0; --i) { if (a \u0026gt;\u0026gt; i \u0026amp; 1) { // 可选 1 和 0 if (l \u0026gt;\u0026gt; i \u0026amp; 1) { f[i][1] = f[i + 1][1]; f[i][0] = (f[i + 1][0] * 2 + f[i + 1][1]) % MOD; } else { f[i][1] = f[i + 1][1]; f[i][0] = f[i + 1][0] * 2 % MOD; } } else { // 只能选 0 if (l \u0026gt;\u0026gt; i \u0026amp; 1) { f[i][1] = 0; f[i][0] = (f[i + 1][0] + f[i + 1][1]) % MOD; } else { f[i][1] = f[i + 1][1]; f[i][0] = f[i + 1][0]; } } } return (f[0][0] + f[0][1]) % MOD; } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } long long res = 1; for (int i = 1; i \u0026lt;= n; ++i) { int l; scanf(\u0026#34;%d\u0026#34;, \u0026amp;l); res = (res * dp(a[i], min(l, a[i]))) % MOD; } printf(\u0026#34;%lld\\n\u0026#34;, res); } return 0; } D. 弯曲筷子 这道题需要发现一个小结论，显然我当时没发现……\n先对 c 数组排序一下，排序后一根筷子只可能和他相邻的或者隔一个的筷子配对。所以问题就转化成了一个线性dp 的问题。对于每一个 i 只用考虑 i - 1 和 i - 2. dp时主要需要考虑兜底，即如何强制选上必须选的，状态转移方程很简单，可以参考下面的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 300010; pair\u0026lt;int, bool\u0026gt; c[N]; long long f[N][2]; long long p2(long long a) { return a * a; } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); memset(f, 0x3f, sizeof(long long) * (n * 2 + 1)); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;c[i].first); c[i].second = false; } for (int i = 1; i \u0026lt;= m; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); c[t].second = true; } f[0][1] = 0; sort(c + 1, c + n + 1); int pre = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (c[i - 1].second) { f[i][0] = f[i - 1][1]; // 一定要配对 f[i][1] = f[i - 1][0] + p2(c[i].first - c[i - 1].first); } else { f[i][0] = min(f[i - 1][0], f[i - 1][1]); // 随意 if (i \u0026gt;= 2) f[i][1] = min(f[i - 1][0] + p2(c[i].first - c[i - 1].first), f[i - 2][0] + p2(c[i].first - c[i - 2].first)); } } if (c[n].second) printf(\u0026#34;%lld\\n\u0026#34;, f[n][1]); else printf(\u0026#34;%lld\\n\u0026#34;, min(f[n][0], f[n][1])); } return 0; } E. 修复公路 我感觉这应该是最水的一道题，我们需要用最小的代价使不连通的图连通，显然就是把本来不连通的连通块作为节点建一棵树，答案是连通块数量 - 1.\n需要主意别把初始化写挂😭\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 300010; vector\u0026lt;int\u0026gt; ed[N]; bool vis[N]; void dfs(int x) { if (vis[x]) return; vis[x] = true; for (int y : ed[x]) { dfs(y); } } void solve() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { vis[i] = false; ed[i].clear(); } for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); if (i - t \u0026gt; 0) ed[i].push_back(i - t), ed[i - t].push_back(i); if (i + t \u0026lt;= n) ed[i].push_back(i + t), ed[i + t].push_back(i); } int cnt = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (!vis[i]) cnt++, dfs(i); } printf(\u0026#34;%d\\n\u0026#34;, cnt - 1); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { solve(); } return 0; } G. 宝石商店 这是一道纯数据结构题，不难发现\n\\[(a_i \\lor x) \\oplus (a_i \\land x) = a_i \\oplus x\\]\n问题转化成在区间 \\[l, r\\] 内找一个 i，使得 \\(a_i \\oplus x\\) 最大。于是可持久化字典树或者主席树套字典树都行。建议别写树套树，一错一个不吱声。\n我不作死，我写的是字典树。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010; int trie[N * 60][2], rt[N], tot; void add(int x, int cur, int pre) { for (int i = 30; i \u0026gt;= 0; --i) { bool t = x \u0026gt;\u0026gt; i \u0026amp; 1; trie[cur][t] = ++tot; trie[cur][t ^ 1] = trie[pre][t ^ 1]; cur = trie[cur][t], pre = trie[pre][t]; } } int query(int x, int l, int r) { int res = 0; for (int i = 30; i \u0026gt;= 0; --i) { bool t = x \u0026gt;\u0026gt; i \u0026amp; 1; if (trie[r][t ^ 1] \u0026amp;\u0026amp; trie[r][t ^ 1] != trie[l][t ^ 1]) { res += 1 \u0026lt;\u0026lt; i; l = trie[l][t ^ 1], r = trie[r][t ^ 1]; } else { l = trie[l][t], r = trie[r][t]; } } return res; } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--){ int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { rt[i] = ++tot; int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); add(t, rt[i], rt[i - 1]); } while (m--) { int l, r, x; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;x); printf(\u0026#34;%d\\n\u0026#34;, query(x, rt[l - 1], rt[r])); } memset(trie, 0, (tot + 1) * sizeof(trie[0])); memset(rt, 0, (n + 1) * sizeof(int)); tot = 0; } return 0; } I. 部落冲突 我这里魔改了一下并查集，这道题用并查集处理唯一的困难就是操作2（野蛮人 a 移动到部落 b 中），直接改野蛮人 a 的父亲可能会波及到他的子树，所以需要一种办法让每个野蛮人始终是叶子。于是我开了 n 个虚拟节点分别初始化成每个野蛮人的父亲，用来合并和交换，进行合并和交换的时候动的永远都是虚拟节点，这样随便改父亲就不会出问题了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 1000010; int rep[N], rnk[N * 2], fa[N * 2]; // 前 n 个表示野蛮人，中间表示初始虚拟节点 int getfa(int x) { return x == fa[x] ? x : fa[x] = getfa(fa[x]); } void solve() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); int tot = 2 * n; for (int i = 1; i \u0026lt;= n; ++i) { fa[i] = i + n; fa[i + n] = i + n; rep[i] = i + n; // 代表点暂时选中间的初始节点，不能动前 n 个 rnk[i + n] = i; } while (q--) { int op; scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); if (op == 4) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%d\\n\u0026#34;, rnk[getfa(a)]); } else { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); if (op == 1) { int r1 = rep[a], r2 = rep[b]; fa[r2] = r1; // 合并 rep[b] = r1; } else if (op == 2) { fa[a] = rep[b]; // 野蛮人只能是叶子 } else { swap(rnk[rep[a]], rnk[rep[b]]); swap(rep[a], rep[b]); } } } } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { solve(); } return 0; } J. 选择配送 这道题应该是第二水的题，尝试分类讨论分离两个点的参数，尝试去绝对值\n\\[|p_1 - p_2| + |q_1 - q_2| = \\max{|(p_1 + q_1) - (q_1 + q_2|), |(p_1 - q_1) - (p_2 + q_2)|}\\]\n只需要记录四个极端值 \\(\\max{x_i + y_i}, \\min{x_i + y_i},\\max{x_i - y_i},\\min{x_i - y_i}\\)就能找到对于每个候选配送站的最大距离。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; const int N = 1000010; int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n, m; long long mn_s = LLONG_MAX, mx_s = LLONG_MIN, mn_m = LLONG_MAX, mx_m = LLONG_MIN; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { long long x, y; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y); mx_s = max(mx_s, x + y); mn_s = min(mn_s, x + y); mx_m = max(mx_m, x - y); mn_m = min(mn_m, x - y); } long long res = LLONG_MAX; for (int i = 1; i \u0026lt;= m; ++i) { long long x, y; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y); long long su = x + y, me = x - y; res = min(res, max(max(abs(su - mx_s), abs(su - mn_s)), max(abs(me - mx_m), abs(me - mn_m)))); } printf(\u0026#34;%lld\\n\u0026#34;, res); } return 0; } ","date":"2025-06-05T13:59:39Z","permalink":"https://invalidnamee.github.io/p/2025st26/","title":"2025春训第二十六场"},{"content":"昨天栽在二分了，今天写了四个二分一个也没挂，爽😋\nA. 互质划分 事实上，只需要 n / 2 即可，如果所有 2 的倍数都能分开了，那其他的更能分开。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { long long n; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; max(1LL, n \u0026gt;\u0026gt; 1) \u0026lt;\u0026lt; endl; return 0; } B. 出租车 对于每一个居民二分最短距离，在根据最短距离二分出来左右边界的位置，然后检查边界是否合法，最后更新答案； \\(\\Theta(n\\log^2 n)\\)完全够了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 200010; int p[N], id[N], s[N], res[N]; int n, m; int findl(long long val) { int l = 1, r = n + m; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (p[mid] \u0026gt;= val) r = mid; else l = mid + 1; } return l; } int findr(int val) { int l = 1, r = n + m; while (l \u0026lt; r) { int mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (p[mid] \u0026lt;= val) l = mid; else r = mid - 1; } return l; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n + m; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;p[i]); } for (int i = 1; i \u0026lt;= n + m; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;id[i]); s[i] = s[i - 1] + id[i]; } for (int i = 1; i \u0026lt;= n + m; ++i) { if (!id[i]) { int l = 0, r = 1000000000; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (s[findr((long long)p[i] + mid)] - s[findl((long long)p[i] - mid) - 1]) r = mid; else l = mid + 1; } int L = findl((long long)p[i] - l), R = findr((long long)p[i] + l); // cout \u0026lt;\u0026lt; L \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; R \u0026lt;\u0026lt; endl; if (id[L] \u0026amp;\u0026amp; id[R]) if (p[i] - p[L] \u0026lt;= p[R] - p[i]) res[L]++; else res[R]++; else if (id[L]) res[L]++; else if (id[R]) res[R]++; else return 213; } } for (int i = 1; i \u0026lt;= n + m; ++i) { if (id[i]) printf(\u0026#34;%d \u0026#34;, res[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } C. 木雕玩具 继续二分，二分答案，然后验证需要的人数是否 ≥ 3 即可。以普遍理性而论，应该可以线性 dp 解决，但是这不影响我一直写挂……\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010; int a[N], n; bool check(int mid) { int t = 0, cur = -0x3f3f3f3f; for (int i = 1; i \u0026lt;= n; ++i) { if (a[i] - cur \u0026gt; mid) { t++; cur = a[i] + mid; } } return t \u0026lt;= 3; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } sort(a + 1, a + n + 1); int l = 0, r = 1000000000; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } printf(\u0026#34;%d\\n\u0026#34;, l); return 0; } E. 足球联赛 It is a 签到题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; int res[30]; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) { int a, b, c, d; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; if (c \u0026gt; d) res[a] += 3; else if (c == d) res[a]++, res[b]++; else res[b] += 3; } for (int i = 1; i \u0026lt;= n; ++i) { cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; return 0; } F. 果汁 用贪心的思想，尽可能的往右边倒，给后面更多的可能；同时这么做不影响前面的收益，因为想喝到必须全倒满，如果可以喝到的话先倒前面的和先倒后面的收益一样。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; const int N = 30010; int v[N]; void solve() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;v[i]); } v[m + 1] = 0x3f3f3f3f; map\u0026lt;int, int\u0026gt; mp; for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); mp[t]++; } int res = 0; for (auto [i, t] : mp) { if (v[i + 1] \u0026gt;= t) v[i + 1] -= t; else { t -= v[i + 1], v[i + 1] = 0; res += max(0, t - v[i]); } } printf(\u0026#34;%d\\n\u0026#34;, res); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { solve(); } return 0; } ","date":"2025-05-25T10:10:59Z","permalink":"https://invalidnamee.github.io/p/2025st23/","title":"2025春训第二十三场"},{"content":"A. 染色 数据非常小，直接暴力就可以，非常保险。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int l1, r1, l2, r2; cin \u0026gt;\u0026gt; l1 \u0026gt;\u0026gt; r1 \u0026gt;\u0026gt; l2 \u0026gt;\u0026gt; r2; int res = 0; for (int i = 0; i \u0026lt;= 100; ++i) { if (l1 \u0026lt;= i \u0026amp;\u0026amp; i \u0026lt; r2 \u0026amp;\u0026amp; l2 \u0026lt;= i \u0026amp;\u0026amp; i \u0026lt; r1) { res++; } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } B. 石头称重 本来很简单的题刚开始被我想复杂了，当然，还有别的因素影响，导致卡了不到一个小时……\n其实很简单，因为前面元素的和一定不大于后面的元素，所以情况一共有 \\(2^n\\) 种，而且选后面的无论如何都比任意选前面的大。\n这让我想到了二进制，每个数可以看做一个数位，选和不选是 0 和 1，完全满足上面的规律，例如 3(110) 一定小于 4(001)。\n因为第一个二进制数是 0，我们令 k = k - 1，这样就完全和二进制对上了，接下来只需要对 k 进行二进制分解把对应的位置加上就是答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int N = 60; long long w[N], s[N], k; int n; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;w[i]); s[i] = s[i - 1] + w[i]; } scanf(\u0026#34;%lld\u0026#34;, \u0026amp;k); if (k \u0026gt; (1ll \u0026lt;\u0026lt; n)) printf(\u0026#34;-1\\n\u0026#34;); else { k--; long long res = 0; for (int i = 0; i \u0026lt; n; ++i) { if (k \u0026gt;\u0026gt; i \u0026amp; 1) res += w[i + 1]; } printf(\u0026#34;%lld\\n\u0026#34;, res); } return 0; } C. 字符串 这道题也有那么一点纸老虎的样子，看着无从下手，但是如果发现了就非常简单。\n先考虑极限的情况，再考虑一般情况\n区间长度为 2，两个字符必须不同；\n区间长度为 3，三个字符必须互不相同；\n区间长度为 4，允许一个字符在两端各出现一次；\n长度更长的区间如果出现最多的字符间隔都不小于 2 依然是合法的。\n得出结论，只要相同字符间隔 ≥ 2 即可。于是就好办了，开一个状态 \\(f_{i, j, k}\\) 表示第 i 个位置选了 j，上一个位置选了 k 的方案数，线性 dp 即可。\n一个位置的字符选择受到前两个字符的影响，所以需要同时记录两个状态，这样从 i - 1 到 i 的时候就可以做到不重不漏。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 5010; const int MOD = 998244353; char s[N]; int cnt[N]; long long f[N][27][27]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); scanf(\u0026#34;%s\u0026#34;, s + 1); f[0][26][26] = 1; // 用了一种不可能的情况表示边界，这种情况会在 i = 3 的时候消失 for (int i = 1; i \u0026lt;= n; ++i) { if (s[i] != \u0026#39;?\u0026#39;) { int t = s[i] - \u0026#39;a\u0026#39;; for (int j = 0; j \u0026lt;= 26; ++j) { for (int k = 0; k \u0026lt;= 26; ++k) { if (j == t || k == t) continue; f[i][t][j] += f[i - 1][j][k]; f[i][t][j] %= MOD; } } } else { for (int t = 0; t \u0026lt; 26; ++t) { for (int j = 0; j \u0026lt;= 26; ++j) { for (int k = 0; k \u0026lt;= 26; ++k) { if (j == t || k == t) continue; f[i][t][j] += f[i - 1][j][k]; f[i][t][j] %= MOD; } } } } } long long res = 0; for (int i = 0; i \u0026lt;= 26; ++i) { for (int j = 0; j \u0026lt;= 26; ++j) { res = (res + f[n][i][j]) % MOD; } } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } D. 喵喵 这道题相对简单一点（因为虽然流程有点麻烦，但是一看容易看出来办法）\n求一下最短路同时记录编号最小的前驱，结束后从 1 号开始沿着记录的最短路的逆路径跑 dfs，在搜索树上树形 dp 统计答案即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 10010; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; ed[N]; int a[N], dis[N], pre[N], t; long long res; bool vis[N]; void dijkstra() { memset(dis, 0x3f, sizeof(dis)); priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; dis[1] = 0; q.push({0, 1}); while (!q.empty()) { int x = q.top().second; q.pop(); if (vis[x]) continue; vis[x] = true; for (auto [i, y] : ed[x]) { if (dis[y] \u0026gt; dis[x] + i) { dis[y] = dis[x] + i; pre[y] = x; q.push({-dis[y], y}); } else if (dis[y] == dis[x] + i) { pre[y] = min(pre[y], x); } } } } void dfs(int x, int l) { if (vis[x]) return; vis[x] = true; for (auto [i, y] : ed[x]) { if (vis[y]) continue; if (x == pre[y]) { dfs(y, l + i); a[x] += a[y]; } } res = max(res, (long long)a[x] * (l - t)); } int main() { int n, m; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;t); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int i = 1; i \u0026lt;= m; ++i) { int x, y, z; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); ed[x].push_back({z, y}); ed[y].push_back({z, x}); } dijkstra(); memset(vis, 0, sizeof(vis)); for (int i = 1; i \u0026lt;= n; ++i) { sort(ed[i].begin(), ed[i].end(), [](pair\u0026lt;int, int\u0026gt; a, pair\u0026lt;int, int\u0026gt; b) { return a.second \u0026lt; b.second; }); } dfs(1, 0); printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } E. 变量定义 比较水，没什么好说的，按要求做就行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 keys = [\u0026#34;include\u0026#34;, \u0026#34;using\u0026#34;, \u0026#34;namespace\u0026#34;, \u0026#34;return\u0026#34;, \u0026#34;main\u0026#34;, \u0026#34;int\u0026#34;, \u0026#34;float\u0026#34;, \u0026#34;double\u0026#34;, \u0026#34;string\u0026#34;, \u0026#34;char\u0026#34;] n = int(input().strip()) def check(s: str): if s in keys: return \u0026#39;No\u0026#39; if s[0] == \u0026#39;_\u0026#39; or s[0].isalpha(): for c in s: if c != \u0026#39;_\u0026#39; and not c.isalnum(): return \u0026#39;No\u0026#39; return \u0026#39;Yes\u0026#39; else: return \u0026#39;No\u0026#39; for _ in range(n): s = input() print(check(s.strip())) F. 跳远比赛 我因为 check 函数写挂\\(\\textcolor{green}{+11}\\)……\n典型的二分答案题，二分最大值，贪心验证即可。具体的，验证的时候应该贪心的取尽可能最左边的点，给后的选择留更多的余地，感性上这是正确的（事实上也是正确的）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; const long long MAXN = 1000000000000000000; typedef long long LL; pair\u0026lt;LL, LL\u0026gt; a[N]; int n, m; bool check(LL mid) { if (mid == 0) return true; LL cnt = 0, ls = -MAXN; for (int i = 1; i \u0026lt;= m; ++i) { // 这里的判断逻辑很容易挂，别问我怎么知道的 if (ls + mid \u0026gt; a[i].second) continue; if (a[i].first - ls \u0026lt; mid) ls = ls + mid; else ls = a[i].first; cnt += (a[i].second - ls) / mid + 1; ls += (a[i].second - ls) / mid * mid; } return cnt \u0026gt;= n; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; ++i) { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a[i].first, \u0026amp;a[i].second); } sort(a + 1, a + m + 1); LL l = 0, r = MAXN; while (l \u0026lt; r) { LL mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } printf(\u0026#34;%lld\\n\u0026#34;, l); return 0; } G. 宝藏 这道题也很简单，看着像是个图论，实际上是个二维 dp，图都不用建出来。记 \\(f_{i, j} \\) 表示走到 i 点用了 j 体力的时宝藏价值的最大值。\\(f_{i, 0}\\) 其实就是 i 山洞领一次的宝藏价值。更新状态时从低到高枚举 j，对于每一个 j 枚举所有边\n\\[f_{y, j} = \\max{{f_{y, j}, f_{x, j - w} + A_y}}\\]\n把所有的 f 取 max 可以。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; using namespace std; const int M = 10010; const int N = 1010; struct ed { int x, y, z; } ed[M]; int f[N][510]; int main() { int res = 0; int n, m, t; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;t); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;f[i][0]); for (int i = 1; i \u0026lt;= m; ++i) scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;ed[i].x, \u0026amp;ed[i].y, \u0026amp;ed[i].z); for (int i = 1; i \u0026lt;= t; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { auto \u0026amp;[x, y, z] = ed[j]; if (i \u0026gt;= z) { f[y][i] = max(f[y][i], f[x][i - z] + f[y][0]); res = max(res, f[y][i]); } } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } ","date":"2025-05-24T10:01:29Z","permalink":"https://invalidnamee.github.io/p/2025st22/","title":"2025春训第二十二场"},{"content":"A. 傻鹿尖塔 每次临死前贪心选择前面能选的最大的即可，但是需要注意不要直接中途 break，会影响之后的读入 😭😭😭\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; int n, m, k; int a[100010]; priority_queue\u0026lt;int\u0026gt; q; int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { while (!q.empty()) q.pop(); bool fail = false; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int i = 1; i \u0026lt;= n; ++i) { m -= a[i]; q.push(a[i]); if (m \u0026lt;= 0 \u0026amp;\u0026amp; !q.empty() \u0026amp;\u0026amp; k) { k--; m += q.top(); q.pop(); } if (m \u0026lt;= 0) { fail = true; printf(\u0026#34;%d\\n\u0026#34;, i - 1); break; } } if (!fail) printf(\u0026#34;%d\\n\u0026#34;, n); } return 0; } B. 树联网 树形 dp 统计子树大小即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int head[N], ne[N * 2], ver[N * 2], w[N * 2], tot; int cnt[N], n; long long res = 0; void add(int x, int y, int z) { ver[++tot] = y; ne[tot] = head[x]; head[x] = tot; w[tot] = z; } void dp(int x, int fa) { cnt[x] = 1; for (int i = head[x]; i; i = ne[i]) { int y = ver[i]; if (y == fa) continue; dp(y, x); cnt[x] += cnt[y]; res += (long long)w[i] * abs(n - cnt[y] * 2); } } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt; n; ++i) { int x, y, z; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); add(x, y, z); add(y, x, z); } dp(1, 0); printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } 剩下的不会了😇\n","date":"2025-05-22T10:04:01Z","permalink":"https://invalidnamee.github.io/p/2025st21/","title":"2025春训第二十一场"},{"content":"第一场打完觉的非常水，于是第二场立刻就被真实了，已老实求放过😇😇😇。\nA. 舞蹈机器人 熟悉的情况，熟悉的打表（\n打表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; const int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; s; void dfs(int x, int y, int dep, int lim, bool f) { if (dep == lim) { s.insert({x, y}); return; } for (int i = f; i \u0026lt; 4; i += 2) { dfs(x + dx[i], y + dy[i], dep + 1, lim, f ^ 1); } } int main() { int n = 50; for (int i = 1; i \u0026lt;= 20; ++i) { s.clear(); dfs(0, 0, 0, i, 0); dfs(0, 0, 0, i, 1); cout \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; return 0; } /* 4 12 24 40 60 84 112 4 8 12 16 20 24 28 1 2 3 4 5 6 7 4 * n * (n - 1) / 2 */ AC 代码\n1 2 3 4 5 6 7 n = int(input()) if n \u0026amp; 1: n = (n + 1) // 2 print(n * (n + 1) * 2) else: n = n // 2 + 1 print(n * n) B. 狗是啥呀 这道比较简单一点，找一个单次伤害最大的作为最后一击，前面的找一个净伤害最高的一直打即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; int main() { int n; long long x, mxd = LLONG_MIN, mxk = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; for (int i = 1; i \u0026lt;= n; ++i) { long long d, h; cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; h; mxk = max(mxk, d); mxd = max(mxd, d - h); } if (x \u0026lt;= mxk) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; else if (mxd \u0026lt;= 0) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 1 + (x - mxk + mxd - 1) / mxd \u0026lt;\u0026lt; endl; return 0; } C. 枢纽 看到这道题我直接就想到了点双联通分量缩点，于是写缩点写挂了（-14）……\n事实上只有一组查询，完全可以暴力解决，从 a 出发搜索，经过 b 就直接 return 把搜到的点打上标记；同理从 b 出发打标记。如此，所有的点被分成三大区。\n如果一个点两个标记都存在，表明他可以只经过 a 或者 b 到其他任何点，否则不能；\n如果只有 a 或者 b 的标记，这两块点之间必须经过 a 和 b 才行。\n所以答案是只被 a 标记的点个数 * 只被 b 标记的点个数。\n优雅的做法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010, M = 1000010; int head[N], ver[M], ne[M], tot = 1; bool vis[N][2]; void add(int x, int y) { ver[++tot] = y; ne[tot] = head[x]; head[x] = tot; } void dfs(int x, bool f, int t) { if (vis[x][f] || x == t) return; vis[x][f] = true; for (int i = head[x]; i; i = ne[i]) { int y = ver[i]; dfs(y, f, t); } } int main() { int n, m, a, b; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;a, \u0026amp;b); for (int i = 1; i \u0026lt;= m; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); add(x, y), add(y, x); } dfs(a, 0, b); dfs(b, 1, a); int t1 = 0, t2 = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (vis[i][0] \u0026amp;\u0026amp; !vis[i][1]) t1++; else if (vis[i][1] \u0026amp;\u0026amp; !vis[i][0]) t2++; } t1--, t2--; printf(\u0026#34;%lld\\n\u0026#34;, (long long)t1 * t2); return 0; } 丑陋的做法（缩点）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; const int N = 200010, M = 1000010; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; s; int head[N], ver[M], ne[M], tot = 1; int dfn[N], low[N], t; int bcc_id[N], bcc_siz[N * 2], bcc_cnt; bool cut[N]; vector\u0026lt;int\u0026gt; ed[N * 2], bcc[N]; stack\u0026lt;int\u0026gt; st; int fa[N * 2], dep[N * 2]; void add(int x, int y) { ver[++tot] = y; ne[tot] = head[x]; head[x] = tot; } void tarjan(int x, int from) { dfn[x] = low[x] = ++t; st.push(x); int cnt = 0; for (int i = head[x]; i; i = ne[i]) { if (i == (from ^ 1)) continue; int y = ver[i]; if (!dfn[y]) { tarjan(y, i); low[x] = min(low[x], low[y]); if (dfn[x] \u0026lt;= low[y]) { cnt++; if (x != 1 || cnt \u0026gt; 1) cut[x] = true; bcc_cnt++; int tp; do { tp = st.top(); st.pop(); bcc_id[tp] = bcc_cnt; bcc_siz[bcc_cnt]++; bcc[bcc_cnt].push_back(tp); } while (tp != y); bcc_siz[bcc_cnt]++; bcc[bcc_cnt].push_back(x); } } else low[x] = min(low[x], dfn[y]); } } void dfs(int x) { for (int y : ed[x]) { if (y == fa[x]) continue; fa[y] = x; dep[y] = dep[x] + 1; dfs(y); bcc_siz[x] += bcc_siz[y]; } } int check(int x, int y) { while (x) { if (fa[x] == y) return x; x = fa[x]; } return 0; } int main() { int n, m, a, b; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;a, \u0026amp;b); for (int i = 1; i \u0026lt;= m; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); if (x == y) continue; if (x \u0026gt; y) swap(x, y); if (s.find({x, y}) != s.end()) continue; s.insert({x, y}); add(x, y), add(y, x); } tarjan(1, 0); for (int i = 1; i \u0026lt;= n; ++i) { if (cut[i]) { bcc_id[i] = ++bcc_cnt; bcc_siz[bcc_cnt] = 1; } } for (int i = 1; i \u0026lt;= bcc_cnt; ++i) { if (!bcc[i].empty()) { for (int x : bcc[i]) { if (cut[x]) { bcc_siz[i]--; ed[bcc_id[x]].push_back(i); ed[i].push_back(bcc_id[x]); } } } else break; } if (!cut[a] || !cut[b]) { printf(\u0026#34;0\\n\u0026#34;); } else { dfs(1); int x = bcc_id[a], y = bcc_id[b]; if (dep[x] \u0026gt; dep[y]) swap(x, y); int f = check(y, x); if (f) { // x 是 y 的祖先 printf(\u0026#34;%lld\\n\u0026#34;, (long long)(n - bcc_siz[f] - 1) * (bcc_siz[y] - 1)); } else { printf(\u0026#34;%lld\\n\u0026#34;, (long long)(bcc_siz[x] - 1) * (bcc_siz[y] - 1)); } } return 0; } D. 魔法药水 这是一道 dp 题。\nn ≤ 100，意味着每秒递增的魔力值只会是 1 ~ 100 之间的整数。枚举选择的瓶数 t，维护一个状态 \\(f_{i, j, k}\\) 表示前 i 瓶药水选了 j 瓶，魔力值之和对 t 的余数为 k 时魔力值的最大值。对于每一个 t，如果存在状态 \\(f_{n, t, m % t}\\)，就尝试用这个状态更新答案。\n需要特别注意对每一个 t 是否存在合法的最终状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; long long f[110][110][110], a[110]; int main() { int n; long long m, res; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; res = m; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i]; } for (int t = 1; t \u0026lt;= n; ++t) { memset(f, -1, sizeof(f)); f[0][0][0] = 0; for (int i = 1; i \u0026lt;= n; ++i) { f[i][0][0] = 0; // i 个 药水 for (int j = 1; j \u0026lt;= t; ++j) { // 选了 j 个 for (int k = 0; k \u0026lt; t; ++k) { // 余数是 k f[i][j][k] = f[i - 1][j][k]; if (~f[i - 1][j - 1][((k - a[i]) % t + t) % t]) f[i][j][k] = max(f[i][j][k], f[i - 1][j - 1][((k - a[i]) % t + t) % t] + a[i]); } } } if (~f[n][t][m % t]) res = min(res, (m - f[n][t][m % t]) / t); } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-05-22T09:50:28Z","permalink":"https://invalidnamee.github.io/p/2025st20/","title":"2025春训第二十场"},{"content":"A. 熊孩子打卡 一道比较水的签到题，因为数据不算太大，直接开 map 统计就可以。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; map\u0026lt;int, int\u0026gt; mp; int main() { int n, res = 0, ls = __INT_MAX__; // 数据肯定到不了 __INT_MAX__ scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); if (ls == t) continue; else { mp[t]++; ls = t; res++; } } for (auto [a, b]: mp) { printf(\u0026#34;%d %d\\n\u0026#34;, a, b); } return 0; } B. 最省力整理法 不管怎么换最后体力应该是一样的，因为数据比较小，所以直接冒泡排序就可以。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 5010; int a[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } long long res = 0; for (int i = 1; i \u0026lt; n; ++i) { for (int j = 1; j \u0026lt;= n - i; ++j) { if (a[j] \u0026gt; a[j + 1]) { res += max(a[j], a[j + 1]); swap(a[j], a[j + 1]); } } } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } C. 穿心咒 这是高中题，两圆的位置关系有 内含、内切、相交、外切、外离，分别对应 0、1、2、1、0，根据圆心的距离和半径的关系判断即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; int p(int x) { return x * x; } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int x1, y1, r1, x2, y2, r2; scanf(\u0026#34;%d%d%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;r1, \u0026amp;x2, \u0026amp;y2, \u0026amp;r2); if (x1 == x2 \u0026amp;\u0026amp; y1 == y2 \u0026amp;\u0026amp; r1 == r2) printf(\u0026#34;-1\\n\u0026#34;); else if (p(x1 - x2) + p(y1 - y2) \u0026gt; p(r1 + r2) || p(x1 - x2) + p(y1 - y2) \u0026lt; p(r1 - r2)) printf(\u0026#34;0\\n\u0026#34;); else if (p(x1 - x2) + p(y1 - y2) == p(r1 + r2) || p(x1 - x2) + p(y1 - y2) == p(r1 - r2)) printf(\u0026#34;1\\n\u0026#34;); else printf(\u0026#34;2\\n\u0026#34;); } return 0; } D. 吃火锅 之前某次训练赛的 A 题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 510; const int M = 250010; const int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; int a[N][N], n; vector\u0026lt;int\u0026gt; ed[M]; int deg[M], f[M]; int calc(int x, int y) { return (x - 1) * n + y; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); } } for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { for (int k = 0; k \u0026lt; 4; ++k) { int x = i + dx[k], y = j + dy[k]; if (x \u0026gt; 0 \u0026amp;\u0026amp; x \u0026lt;= n \u0026amp;\u0026amp; y \u0026gt; 0 \u0026amp;\u0026amp; y \u0026lt;= n \u0026amp;\u0026amp; a[i][j] \u0026lt; a[x][y]) { ed[calc(i, j)].push_back(calc(x, y)); deg[calc(x, y)]++; } } } } queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n * n; ++i) { if (deg[i] == 0) q.push(i), f[i] = 1; } while (!q.empty()) { int x = q.front(); q.pop(); for (int y : ed[x]) { f[y] = max(f[y], f[x] + 1); if (--deg[y] == 0) q.push(y); } } int res = 0; for (int i = 1; i \u0026lt;= n * n; ++i) { res = max(res, f[i]); } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } E. 套路比赛 可以用分块来做，把 \\(n\\)个数按照除以 \\(\\lfloor \\sqrt n \\rfloor\\) 的余数分成 \\(\\lceil \\sqrt n \\rceil\\)块。\n第 i 轮淘汰，需要找 \\(m\\ \\text{mod}\\ (n - i)\\) 个人，如果为零，就赋值成 n - i，我们把这个人数记为 t；\n每次淘汰先从当前的人所在的块内开始暴力遍历，遇到未被淘汰的就 t -= 1；\n如果成功在块内找到了下一个被淘汰的（t == 0），标记上，并把当前块的计数 - 1，进行下一轮淘汰；\n否则按块遍历，t -= 块内剩余的人数（这个值可以预先维护好），直到某个块内剩余的人数比 t 多，暴力遍历该块，直到 t == 0，淘汰掉这个人。\n以此类推，执行 n - 1 次，剩下的人就是答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 /* 我这里把下标统一往前移了一位，为了方便取模 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; bool f[100010]; int siz[333]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int L = sqrt(n), cnt = n / L; for (int i = 0; i \u0026lt; n; ++i) { f[i] = true; siz[i / L]++; } int cur = 0; for (int i = 1; i \u0026lt; n; ++i) { int t = m % (n - i + 1), cur_bk = cur / L; if (!t) t = n - i + 1; while (cur / L == cur_bk \u0026amp;\u0026amp; t) { t -= f[cur]; cur++; cur %= n; } if (!t) { int tt = (cur - 1 + n) % n; f[tt] = false; siz[tt / L]--; } else { cur_bk = cur / L; while (siz[cur_bk] \u0026lt; t) { t -= siz[cur_bk]; cur_bk++; cur_bk %= cnt + 1; } cur = cur_bk * L; while (t) { t -= f[cur]; cur++; cur %= n; } int tt = (cur - 1 + n) % n; f[tt] = false; siz[tt / L]--; } } for (int i = 0; i \u0026lt; n; ++i) { if (f[i]) { printf(\u0026#34;%d\\n\u0026#34;, i + 1); return 0; } } return 0; } /* 0 1 2 3 4 5 6 7 8 9 0 1 _ 3 4 5 6 7 8 9 0 1 _ 3 4 _ 6 7 8 9 0 1 _ 3 4 _ 6 7 _ 9 0 _ _ 3 4 _ 6 7 _ 9 0 _ _ 3 4 _ _ 7 _ 9 _ _ _ 3 4 _ _ 7 _ 9 _ _ _ 3 4 _ _ _ _ 9 _ _ _ 3 _ _ _ _ _ 9 _ _ _ 3 _ _ _ _ _ _ */ F. 石子合并 如果数据小的话，直接用 STL 的堆就可以做，但是他没给数据范围，所以我采取了打表 + 找规律的做法。\n答案 = \\(1 · 0 + 2^0 · 2 + 2^1 · 3 + 2^2 · 4 + \\dots + (n - 1 - 2^0 - 2^1 - 2^2 - \\dots) · k\\).\n代码中注释掉的是打表的过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; // priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; // long long res[101], t[101]; int main() { unsigned long long n, res = 0; cin \u0026gt;\u0026gt; n; int i = 0; n--; while (n) { if (n \u0026gt;= (1ull \u0026lt;\u0026lt; i)) res += (1ull \u0026lt;\u0026lt; i) * (i + 2), n -= (1ull \u0026lt;\u0026lt; i); else res += n * (i + 2), n = 0; i++; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; // for (int t = 1; t \u0026lt;= 100; ++t) { // int i = 0; // n = t - 1; // while (n) { // if (n \u0026gt;= (1ull \u0026lt;\u0026lt; i)) res += (1ull \u0026lt;\u0026lt; i) * (i + 2), n -= (1ull \u0026lt;\u0026lt; i); // else res += n * (i + 2), n = 0; // i++; // } // cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // res = 0; // // for (int i = 1; i \u0026lt;= n; ++i) q.push(1); // // while (q.size() \u0026gt; 1) { // // int x = q.top(); q.pop(); // // int y = q.top(); q.pop(); // // q.push(x + y); // // res[n] += x + y; // // } // // q.pop(); // } // for (int i = 1; i \u0026lt;= 100; ++i) t[i] = res[i] - res[i - 1]; // for (int i = 1; i \u0026lt;= 100; ++i) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // cout \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-05-18T14:28:05Z","permalink":"https://invalidnamee.github.io/p/2025st19/","title":"2025春训第十九场"},{"content":"废掉了，拼尽全力无法战胜，做的时候感觉自己差点爆零，以 3 / 8 的优异成绩拿下榜一。这套题前面的题都是主打一个直觉上的欺骗，后面难的不会做。\nA. 序列重排 首先，结论是答案只可能是 0, 1, 2。\n序列中 0 的个数不超过 \\(\\lfloor \\frac{n + 1}{2} \\rfloor\\)，把 0 穿插到其他数中间肯定是可以放得下的，所以答案是 0；\n如果不满足上述条件，0 不能都穿插到其他数中间，那么一定有相邻的数加起来是 0，只能考虑剩余的数，我们要尽可能空出来最小的数。首先考虑空出来 1，除非除了 0 都是 1，否则让任意一个 不是 1 的数和一大堆 0 相邻，剩下的 1 都放一块，这样 1 就能空出来了，所以如果至少有一个数不是 1，那么答案是 1；如果全是 1，那没办法空出 1 了，就尽可能空出 2，显然是可行的，把 0 和 1 交叉放，所有的和都是 0 或者 1，就空出了 2，所以答案是 2。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int a[1000010]; int main() { int n, zcnt = 0, m = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[++m]); if (!a[m]) zcnt++; } sort(a + 1, a + m + 1); if (zcnt \u0026lt;= (n + 1) / 2) printf(\u0026#34;0\\n\u0026#34;); else if (a[m] == 1) printf(\u0026#34;2\\n\u0026#34;); else printf(\u0026#34;1\\n\u0026#34;); return 0; } B. 划分 这道题也是，只是看起来难，但是实际上只需要预处理前缀和，只考虑分成两段的情况即可。\nWhy？因为假设最大的结果是分成多块得到的，那么随意找一个分块的边界为参考点左侧分一块右侧分一块，最大公约数显然不变，所以分两段一定会包含所有分多块的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; long long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; } const int N = 100010; long long s[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;s[i]); s[i] += s[i - 1]; } long long res = 0; for (int i = 1; i \u0026lt; n; ++i) { res = max(res, gcd(s[n] - s[i], s[i])); } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } C. 蛋糕 可以用贪心的思想，能不切就不切，实在是迫不得已了再切。\n首先把 n 二进制拆分，从低到高遍历二进制位，如果这一位是 1 而且正好有现成的那就直接用一个现成的，然后把剩下的蛋糕两两配对组成大的给后面备用；如果没有，就从右边找最近的有蛋糕的位置，一直切直到有，然后用掉一个切出来的；如果是 0 不用处理，直接把手上的都组成大的给后面备用。\n一轮流程跑下来之后就能凑出来 n 了。\n正确性：如果能凑出来，那么手上的蛋糕总和一定不小于 n，对于低位剩下的零头他无法对任何高位做出贡献，即使切割大的来给他补一下也是无效操作，因为一来就是 2 个，剩下的零头还是凑不回去，他注定只能剩着，把多余的往高位凑已经最大程度的利用了所有二进制位。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int cnt[64]; int main() { long long n, tot = 0; int m; scanf(\u0026#34;%lld%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; ++i) { long long t; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;t); cnt[(int)(log2(t) + 0.3)]++; tot += t; } if (tot \u0026lt; n) { printf(\u0026#34;-1\\n\u0026#34;); return 0; } int res = 0; for (int i = 0; i \u0026lt; 64; ++i) { if (i \u0026gt; 0) cnt[i] += cnt[i - 1] / 2, cnt[i - 1] %= 2; if (n \u0026gt;\u0026gt; i \u0026amp; 1) { if (cnt[i]) cnt[i]--; else { int p = -1; for (int j = i; j \u0026lt; 64; ++j) { if (cnt[j]) { p = j; break; } } for (int j = p; j \u0026gt; i; --j) { cnt[j]--; cnt[j - 1] += 2; res++; } if (!cnt[i]) return 123; cnt[i]--; } } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } ","date":"2025-04-14T08:07:18Z","permalink":"https://invalidnamee.github.io/p/2025st18/","title":"2025春训第十八场"},{"content":"A. 最大公约数 直接枚举 1 ~ n 对于每一个数从他不等于自己的约数里面找个最大的，然后全部取个 max。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { int n, res = 1; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { int l = sqrt(i); for (int j = 2; j \u0026lt;= l; ++j) { if (i % j == 0) { res = max(res, i / j); break; } } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } B. 数的变换 非常的水。\n约数中每有一个约数 2，次数 + 1；\n每有一个约数 3，次数 + 2（因为算完之后还需要处理造出来的一个 2；\n每有一个约数 5，次数 + 3（因为算完之后还需要处理造出来的两个 2）；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { long long n, t = 0; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); while (n % 5 == 0) n /= 5, t += 3; while (n % 3 == 0) n /= 3, t += 2; while (n % 2 == 0) n /= 2, t ++; if (n == 1) printf(\u0026#34;%lld\\n\u0026#34;, t); else printf(\u0026#34;-1\\n\u0026#34;); } return 0; } C. 回文 这道题其实可以直接暴力，因为一共只可能有 \\(\\binom{2}{26}\\)种可能的不能配对的方式，于是就有不多于 \\(\\binom{2}{26}^2\\)种可能的交换情况，于是直接枚举所有情况交换即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; int a[26]; map\u0026lt;pair\u0026lt;int, int\u0026gt;, int\u0026gt; mp; int mn = 0x3f3f3f3f; int ord(char c) { return c - \u0026#39;a\u0026#39;; } long long getmin(int x, int y) { return min(min(a[x], a[y]), mn * 2); } int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; 26; ++i) { cin \u0026gt;\u0026gt; a[i]; mn = min(mn, a[i]); } string s; cin \u0026gt;\u0026gt; s; s = \u0026#39; \u0026#39; + s; long long res = 0; for (int i = 1; i \u0026lt;= (n / 2); ++i) { if (s[i] != s[n - i + 1]) { res += min(min(a[ord(s[i])], a[ord(s[n - i + 1])]), mn * 2); int lv = ord(s[i]), rv = ord(s[n - i + 1]); if (lv \u0026gt; rv) swap(lv, rv); mp[{lv, rv}]++; } } long long ss = 0; for (auto [p, t] : mp) { if (t \u0026gt; 1) { ss = min(ss, -2ll * min(min(a[p.first], a[p.second]), mn * 2)); } for (auto [pp, _] : mp) { if (pp == p) continue; ss = min(ss, min( getmin(p.first, pp.first) + getmin(p.first, pp.second), getmin(p.first, pp.second) + getmin(p.second, pp.first) ) - getmin(p.first, p.second) - getmin(pp.first, pp.second) ); } } res = min(res, res + ss); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } E. 船长的自助餐 一道数据比较友好的 dp 题，至于我为什么在红温，当然是没好好读题就去做了 😇😇😇\n连着吃 \\(\\lceil \\log_{\\frac{2}{3}}{M} \\rceil\\)次胃容量就变成 0 了，当然如果你没发现这个，直接把胃容量整个当一个状态塞进去应该也是不会 TLE 的，如果能离散化一下会更快。\n记 \\(f_{i, j, 1}\\) 为吃到第 i 天，已经连续吃了 j 次，并且第 i 天吃了的情况下能吃的最大值； \\(f_{i, j, 0}\\) 为第 i 天没吃的情况下的最大值。\n\\[f_{i, 1, 0} = \\max { f_{i - 1, j, 0} }\\]\n\\[f_{i, j, 0} = \\max {f_{i - 1, j, 0}, f_{i - 1, j, 1} } \\ (j \\neq 1)\\]\n\\[f_{i, j, 1} = \\max{f_{i - 1, j, 0} + \\min {m_j, A_i}, f_{i - 1, j - 1, 1} + \\min {m_j, a_i } } \\ (m_j = 连续吃了 j 次后胃容量)\\]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #define int long long using namespace std; const int N = 1010; int n, m[70], a[N]; long long f[N][70][2]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m[1]); int l; for (l = 2; m[l - 1]; ++l) m[l] = m[l - 1] * 2 / 3; l--; for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= l; ++j) { f[i][1][0] = max(f[i][1][0], f[i - 1][j][0]); } for (int j = 1; j \u0026lt;= l; ++j) { f[i][j][0] = max(f[i][j][0], max(f[i - 1][j][0], f[i - 1][j][1])); } f[i][1][1] = f[i - 1][1][0] + min(m[1], a[i]); for (int j = 2; j \u0026lt;= l; ++j) { f[i][j][1] = max(f[i - 1][j][0] + min(m[j], a[i]), f[i - 1][j - 1][1] + min(m[j], a[i])); } } long long res = 0; for (int i = 1; i \u0026lt;= l; ++i) { res = max(res, max(f[n][i][0], f[n][i][1])); } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } ","date":"2025-04-14T07:40:29Z","permalink":"https://invalidnamee.github.io/p/2025st17/","title":"2025春训第十七场"},{"content":"差点就 ak 了，有点可惜，感谢学姐手下留情😭。\nA. Number Maximization 签到题 * 1\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { string s; cin \u0026gt;\u0026gt; s; sort(s.begin(), s.end(), greater\u0026lt;char\u0026gt;()); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } B. Simplified Calendar System 签到题 * 2\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b, c, d, e, f, g; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d \u0026gt;\u0026gt; e \u0026gt;\u0026gt; f \u0026gt;\u0026gt; g; cout \u0026lt;\u0026lt; (d - 1 + (e - a) + (f - b) * 30 + (g - c) * 360) % 7 + 1 \u0026lt;\u0026lt; endl; return 0; } C. Letter Frequency 签到题 * 3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; string s[30]; int main() { int n, len = 0; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; s[i]; len = max(len, (int)s[i].length()); } for (int i = 1; i \u0026lt;= len; ++i) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34;; map\u0026lt;char, int\u0026gt; mp; for (int j = 1; j \u0026lt;= n; ++j) { if (s[j].length() \u0026gt;= i) mp[s[j][i - 1]]++; } int mx = 0; for (auto [a, b] : mp) mx = max(mx, b); for (auto [a, b] : mp) if (b == mx) cout \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; a; cout \u0026lt;\u0026lt; endl; } return 0; } D. Pseudo Pseudo Random Numbers 数据非常的小，所以直接暴力枚举检查就行，签到题 * 4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; int n, k; bool check(int mask) { int ls = -1, len = 0; for (int i = 0; i \u0026lt; n; ++i) { if ((mask \u0026gt;\u0026gt; i \u0026amp; 1) != ls) len = 1; else len++; ls = mask \u0026gt;\u0026gt; i \u0026amp; 1; if (len \u0026gt; k) return false; } return true; } int main() { int t = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) { if (check(i)) t++; } cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; return 0; } E. Word Tree 没什么特别的，就是最小生成树。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; string s[1010]; int fa[1010]; vector\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; ed; int dis(string a, string b) { int n = a.length(); int d = 0; for (int i = 0; i \u0026lt; n; ++i) { d += abs(a[i] - b[i]); } return d; } int getfa(int x) { return x == fa[x] ? x : fa[x] = getfa(fa[x]); } int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n, l; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; l; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; s[i]; fa[i] = i; for (int j = 1; j \u0026lt; i; ++j) { ed.push_back({dis(s[i], s[j]), {i, j}}); } } int res = 0; sort(ed.begin(), ed.end()); for (auto [w, p] : ed) { int x = getfa(p.first), y = getfa(p.second); if (x == y) continue; else { fa[y] = x; res = max(res, w); } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } F. House Prices Going Up 树状数组（线段树）模板题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 500010; long long tr[N]; int n; void add(int u, int v) { for (; u \u0026lt;= n; u += u \u0026amp; -u) { tr[u] += v; } } long long query(int u) { long long res = 0; for (; u; u -= u \u0026amp; -u) { res += tr[u]; } return res; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); add(i, t); } int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while (q--) { char s[2]; int x, y; scanf(\u0026#34;%s%d%d\u0026#34;, s, \u0026amp;x, \u0026amp;y); if (s[0] == \u0026#39;U\u0026#39;) add(x, y); else printf(\u0026#34;%lld\\n\u0026#34;, query(y) - query(x - 1)); } return 0; } G. Which Number 到这里难度开始正常了，这道题是二分答案+容斥原理，先二分答案，然后用容斥原理检查前面合法的数的个数。\n我不慎 WA 了一次好像是爆 long long 了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; using namespace std; long long a[20], k; long long n; bool check(long long mid) { __int128_t cnt = 0; for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; k); ++mask) { __int128_t t = 1; int op = 0; for (int j = 0; j \u0026lt; k; ++j) { if (mask \u0026gt;\u0026gt; j \u0026amp; 1) { op++; t *= a[j]; } } op = (op \u0026amp; 1) ? -1 : 1; cnt += (mid / t) * op; } return cnt \u0026gt;= n; } int main() { scanf(\u0026#34;%lld%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 0; i \u0026lt; k; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); } __int128_t l = 1, r = __LONG_LONG_MAX__; while (l \u0026lt; r) { long long mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } printf(\u0026#34;%lld\\n\u0026#34;, (long long)l); return 0; } I. Share Auction 又是一道二分题，考虑这样一个问题，对于一个 lot 如果一块一块的 bid 每一块的收益都会逐渐减小，目标状态是使得最后 bid 了 v 之后目标状态是一个相对均匀的状态。具体来说是让其中的一部分（有可能是全部）在投了 v 之后再投 1 时或者的收益在误差允许的范围内尽可能相等，这样就能最大程度保证每次投的都是最优解。\n于是可以二分最终投一块钱的收益，然后计算想把收益压到 ≤ mid 的时候需要 bid 多少，和 v 比较，找到一个尽可能接近 v 的（可以稍微大一点，因为有的情况最后好几个都相等，一降低每个都得 bid 1，无法到 v，但是不影响最后计算，因为都一样，最后投哪个都行）。找到之后按二分的 check 函数的逻辑再跑一次，这一次要加上最大限制 v，跑的过程中记录收益累加即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 100010; struct Node { double rate; int tot_val; int voted = 0, other_vote; bool operator \u0026lt;(const Node \u0026amp;_) const { return rate \u0026lt; _.rate; } double vote(int t) { double r = (double)voted / (voted + other_vote) * tot_val; voted += t; rate = (double)(voted + 1) / (voted + other_vote + 1) * tot_val - (double)voted / (voted + other_vote) * tot_val; return (double)voted / (voted + other_vote) * tot_val - r; } } a[N]; int n, v; long long check(double val) { long long res = 0; for (int i = 1; i \u0026lt;= n; ++i) { int l = 0, r = 100000000; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; auto bk = a[i]; bk.vote(mid); if (bk.rate \u0026lt; val) r = mid; else l = mid + 1; } res += l; } return res; } int main() { double L = 0, R = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;v); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[i].tot_val, \u0026amp;a[i].other_vote); a[i].vote(0); R = max(R, a[i].rate); } while (R - L \u0026gt; 1e-9) { double mid = (L + R) / 2; if (check(mid) \u0026gt;= v) L = mid; else R = mid; } double res = 0; for (int i = 1; i \u0026lt;= n; ++i) { int l = 0, r = v; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; auto bk = a[i]; bk.vote(mid); if (bk.rate \u0026lt; L) r = mid; else l = mid + 1; } res += a[i].vote(l); v -= l; } if (v) return 123; else printf(\u0026#34;%f\\n\u0026#34;, res); return 0; } J. Desert Travel 基本功大考核，最小生成树 + 树上倍增，思维难度不是很大，但是比较有操作难度，这中间炸了死哪都不知道。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 5010; struct Edge { int x, y; double w; } a[N * (N - 1) / 2]; int x[N], y[N]; int fa[N]; int f[N][15], dep[N]; double g[N][15]; vector\u0026lt;pair\u0026lt;double, int\u0026gt;\u0026gt; ed[N]; int getfa(int x) { return x == fa[x] ? x : fa[x] = getfa(fa[x]); } void dfs(int x) { for (int i = 1; i \u0026lt; 15; ++i) { f[x][i] = f[f[x][i - 1]][i - 1]; g[x][i] = max(g[x][i - 1], g[f[x][i - 1]][i - 1]); } for (auto [w, y] : ed[x]) { if (y == f[x][0]) continue; g[y][0] = w; f[y][0] = x; dep[y] = dep[x] + 1; dfs(y); } } int main() { int n, m = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { fa[i] = i; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x[i], \u0026amp;y[i]); for (int j = 1; j \u0026lt; i; ++j) { a[++m] = {j, i, sqrt(pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2))}; } } sort(a + 1, a + m + 1, [](Edge a, Edge b) { return a.w \u0026lt; b.w; }); for (int i = 1; i \u0026lt;= m; ++i) { int x = getfa(a[i].x), y = getfa(a[i].y); if (x == y) continue; fa[y] = x; ed[a[i].x].push_back({a[i].w, a[i].y}); ed[a[i].y].push_back({a[i].w, a[i].x}); } dep[1] = 1; dfs(1); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while (q--) { int x, y; double res = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); if (dep[x] \u0026lt; dep[y]) swap(x, y); for (int i = 14; i \u0026gt;= 0; --i) { if (dep[f[x][i]] \u0026gt;= dep[y]) { res = max(res, g[x][i]); x = f[x][i]; } } if (x != y) { for (int i = 14; i \u0026gt;= 0; --i) { if (f[x][i] != f[y][i]) { res = max(res, max(g[x][i], g[y][i])); x = f[x][i], y = f[y][i]; } } res = max(res, max(g[x][0], g[y][0])); } printf(\u0026#34;%f\\n\u0026#34;, res); } return 0; } ","date":"2025-04-08T05:25:12Z","permalink":"https://invalidnamee.github.io/p/2025st16/","title":"2025春训第十六场"},{"content":"A. Lucky 7 一道签到题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; bool cont(int n) { for (char c : to_string(n)) { if (c == \u0026#39;7\u0026#39;) return true; } return false; } int main() { int n; cin \u0026gt;\u0026gt; n; bool c1 = cont(n), c2 = n % 7 == 0; if (!c1 \u0026amp;\u0026amp; !c2) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else if (!c1 \u0026amp;\u0026amp; c2) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; else if (c1 \u0026amp;\u0026amp; !c2) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 3 \u0026lt;\u0026lt; endl; return 0; } B. We Want You Happy! 两道签到题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; struct Customer { int id, s, d, t; } a[1010]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i].id \u0026gt;\u0026gt; a[i].s \u0026gt;\u0026gt; a[i].d \u0026gt;\u0026gt; a[i].t; } sort(a + 1, a + n + 1, [](Customer a, Customer b) { return a.s \u0026lt; b.s; }); int curt = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (curt \u0026gt; a[i].s + a[i].t) continue; if (curt \u0026lt; a[i].s) curt = a[i].s; curt += a[i].d; cout \u0026lt;\u0026lt; a[i].id \u0026lt;\u0026lt; endl; } return 0; } C. Snailography 生成一个下标矩阵然后对着矩阵输出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; int t[30][30]; int main() { int n; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; int x = 0, y = 1; int cur = n * n; while (cur \u0026gt; 0) { while (x + 1 \u0026lt;= n \u0026amp;\u0026amp; t[x + 1][y] == 0) t[++x][y] = cur--; while (y + 1 \u0026lt;= n \u0026amp;\u0026amp; t[x][y + 1] == 0) t[x][++y] = cur--; while (x - 1 \u0026gt; 0 \u0026amp;\u0026amp; t[x - 1][y] == 0) t[--x][y] = cur--; while (y - 1 \u0026gt; 0 \u0026amp;\u0026amp; t[x][y - 1] == 0) t[x][--y] = cur--; } for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { if (t[i][j] \u0026lt;= s.length()) cout \u0026lt;\u0026lt; s[t[i][j] - 1]; } } cout \u0026lt;\u0026lt; endl; return 0; } D. Good Goalie 肯定不行的情况，原点到直线的距离大于 r；\n肯定是 0 的情况 \\(|x|\\) ≤ r；\n其余情况，先把 x, y 取一下绝对值，对称变换不会影响答案\n答案是蓝色的角 \\(\\arctan \\frac{x}{y} - \\arccos \\frac{d}{r}\\)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { double y, x, r; while (cin \u0026gt;\u0026gt; y \u0026gt;\u0026gt; x \u0026gt;\u0026gt; r) { double d = fabs(x * y) / sqrt(x * x + y * y); if (d \u0026lt;= r) { if (fabs(r) \u0026gt;= fabs(x)) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else { x = fabs(x), y = fabs(y); double theta = atan(x / y) - acos(d / r); cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(6) \u0026lt;\u0026lt; theta * 180 / acos(-1) \u0026lt;\u0026lt; endl; } } else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } return 0; } E. Most Valuable Pez 分组背包。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; int f[12010], s[13]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= 12; ++j) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[j]); s[j] += s[j - 1]; } for (int j = m; j; --j) { for (int k = 1; k \u0026lt;= 12 \u0026amp;\u0026amp; k \u0026lt;= j; ++k) { f[j] = max(f[j], f[j - k] + s[k]); } } } printf(\u0026#34;%d\\n\u0026#34;, f[m]); return 0; } G. Not So Close 经典的状压dp，用一个二进制数 mask 表示一行的状态。只考虑当前行合法状态需要满足 mask » 1 \u0026amp; mask == 0，因为不能相邻；相邻两行的状态 i，j 需要满足 i « 1 \u0026amp; j == 0 and i \u0026amp; j == 0 and i » 1 \u0026amp; j == 0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; using namespace std; const int MOD = 1000000007; long long f[1010][1 \u0026lt;\u0026lt; 10]; int main() { int r, n; cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; n; f[0][0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt; (1 \u0026lt;\u0026lt; r); ++j) { if (j \u0026gt;\u0026gt; 1 \u0026amp; j) continue; for (int k = 0; k \u0026lt; (1 \u0026lt;\u0026lt; r); ++k) { if ((k \u0026gt;\u0026gt; 1 \u0026amp; k) || (k \u0026amp; j) || (k \u0026gt;\u0026gt; 1 \u0026amp; j) || (k \u0026lt;\u0026lt; 1 \u0026amp; j)) continue; f[i][j] = (f[i][j] + f[i - 1][k]) % MOD; } } } long long res = 0; for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; r); ++mask) { res = (res + f[n][mask]) % MOD; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } H. The Duel of Smokin’ Joe 统计逆序对数量，如果是奇数就是 Smokin Joe!，否则就是 Oh No!.\n原理是一次交换一定会改变逆序对数量的奇偶性，如果原来是奇数，那一定需要奇数次，先手必胜；反之后手必胜。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int tr[N], a[N], n; void add(int u) { for (; u \u0026lt;= n; u += u \u0026amp; -u) { tr[u]++; } } int query(int u) { int res = 0; for (; u; u -= u \u0026amp; -u) { res += tr[u]; } return res; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } long long cnt = 0; for (int i = n; i; --i) { cnt += query(a[i]); add(a[i]); } if (cnt \u0026amp; 1) printf(\u0026#34;Smokin Joe!\\n\u0026#34;); else printf(\u0026#34;Oh No!\\n\u0026#34;); return 0; } 归并排序是什么，感觉不如树状数组（）\nJ. Grow Measure Cut Repeat 因为每次 cut 都是单调不增的，所以不会发生第一次 cut 过的树第二次不 cut 的情况，这就好办了。维护两个线段树，一个维护忽略所有裁剪的前提下的高度，一个维护只考虑最后一次裁剪的情况下的高度。\n说起来简单，但是实际上非常不好写，毕竟用线段树维护等差数列本来就比较复杂。具体的，第一颗树需要两个懒标记一个是首项，一个是公差；第二棵树需要三个懒标记，一个首项，一个公差，还有一个覆盖标记（因为裁剪之后要把所有的数覆盖成新的H），同时需要注意边界，我就因为边界快调死了😭。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 500000; int seq[N]; struct SemgentTree { long long a[N], tag[N]; bool cover[N]; void pushdown(int u, int l, int r) { if (cover[u]) { int mid = (l + r) \u0026gt;\u0026gt; 1; a[u \u0026lt;\u0026lt; 1] = a[u], a[u \u0026lt;\u0026lt; 1 | 1] = a[u] + tag[u] * (mid - l + 1); tag[u \u0026lt;\u0026lt; 1] = tag[u], tag[u \u0026lt;\u0026lt; 1 | 1] = tag[u]; tag[u] = 0; a[u] = 0; cover[u \u0026lt;\u0026lt; 1] = cover[u \u0026lt;\u0026lt; 1 | 1] = true; cover[u] = 0; } if (a[u] || tag[u]) { int mid = (l + r) \u0026gt;\u0026gt; 1; a[u \u0026lt;\u0026lt; 1] += a[u], a[u \u0026lt;\u0026lt; 1 | 1] += a[u] + tag[u] * (mid - l + 1); tag[u \u0026lt;\u0026lt; 1] += tag[u], tag[u \u0026lt;\u0026lt; 1 | 1] += tag[u]; tag[u] = 0; a[u] = 0; } } void reset(int u, int l, int r, long long val) { cover[u] = true; a[u] = val, tag[u] = 0; } void modify(int u, int l, int r, int ql, int qr, int a1, int d) { if (ql \u0026gt; qr) return; // !!!!! if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { a[u] += a1 + (l - ql) * d; // 首项 tag[u] += d; // 公差 } else { pushdown(u, l, r); int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) modify(u \u0026lt;\u0026lt; 1, l, mid, ql, qr, a1, d); if (qr \u0026gt; mid) modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr, a1, d); } } long long query(int u, int l, int r, int p) { if (l == r) return a[u]; else { pushdown(u, l, r); int mid = (l + r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) return query(u \u0026lt;\u0026lt; 1, l, mid, p); else return query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, p); } } } smt, limt; void print(int t) { for (int i = 1; i \u0026lt;= t; ++i) { printf(\u0026#34;%lld \u0026#34;, min(limt.query(1, 1, 100000, i), smt.query(1, 1, 100000, i))); } printf(\u0026#34;\\n\u0026#34;); } int main() { int q, n = 100000; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while (q--) { char s[2]; scanf(\u0026#34;%s\u0026#34;, s); if (s[0] == \u0026#39;A\u0026#39;) { int l, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;k); smt.modify(1, 1, n, max(1, l - k + 1), l, max(1, k - l + 1), 1); smt.modify(1, 1, n, l + 1, min(n, l + k - 1), k - 1, -1); limt.modify(1, 1, n, max(1, l - k + 1), l, max(1, k - l + 1), 1); limt.modify(1, 1, n, l + 1, min(n, l + k - 1), k - 1, -1); } else if (s[0] == \u0026#39;B\u0026#39;) { int p; scanf(\u0026#34;%d\u0026#34;, \u0026amp;p); printf(\u0026#34;%lld\\n\u0026#34;, min(smt.query(1, 1, n, p), limt.query(1, 1, n, p))); } else { int H; scanf(\u0026#34;%d\u0026#34;, \u0026amp;H); limt.reset(1, 1, n, H); } } return 0; } K. Bad Bunny 点双联通分量缩点，然后树上倍增求路径上割点的个数，如果端点不是割点，就额外加上端点。\n说着很简单，调的时候也是很折磨，因为我是现学的点双联通分量缩点，之前只学过强联通和边双联通。点双的缩点更复杂，把双联通分量缩点，同时还需要把割点复制一份单独拎出来连接，第一次写的时候容易挂。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; const int N = 200010; int head[N], head2[N], ver[N * 4], ne[N * 4], tot = 1; int dfn[N], low[N], id[N], t, bcc_cnt, rt; vector\u0026lt;int\u0026gt; bcc[N]; int cut[N], cut_id[N]; int f[N][20], g[N][20], dep[N]; stack\u0026lt;int\u0026gt; st; void add(int head[], int x, int y) { ver[++tot] = y; ne[tot] = head[x]; head[x] = tot; } void tarjan(int x, int from) { dfn[x] = low[x] = ++t; st.push(x); int cnt = 0; for (int i = head[x]; i; i = ne[i]) { if (i == (from ^ 1)) continue; int y = ver[i]; if (!dfn[y]) { cnt++; tarjan(y, i); low[x] = min(low[x], low[y]); if (dfn[x] \u0026lt;= low[y]) { bcc_cnt++; int tp; if (x != rt || cnt \u0026gt;= 2) cut[x] = true; do { tp = st.top(); st.pop(); id[tp] = bcc_cnt; bcc[bcc_cnt].push_back(tp); } while (tp != y); bcc[bcc_cnt].push_back(x); id[x] = bcc_cnt; } } else { low[x] = min(low[x], dfn[y]); } } } void dfs(int x) { g[x][0] = cut_id[x]; for (int i = 1; i \u0026lt; 20; ++i) { f[x][i] = f[f[x][i - 1]][i - 1]; g[x][i] = g[x][i - 1] + g[f[x][i - 1]][i - 1]; } for (int i = head2[x]; i; i = ne[i]) { int y = ver[i]; if (y == f[x][0]) continue; f[y][0] = x; dep[y] = dep[x] + 1; dfs(y); } } int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;input\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif // !ONLINE_JUDGE int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); add(head, x, y); add(head, y, x); } rt = 1; tarjan(1, 0); for (int i = 1; i \u0026lt;= n; ++i) { if (cut[i]) { id[i] = ++bcc_cnt; cut_id[bcc_cnt] = true; } } for (int i = 1; i \u0026lt;= bcc_cnt; ++i) { for (int y : bcc[i]) { if (cut[y]) { add(head2, id[y], i); add(head2, i, id[y]); } } } dep[1] = 1; dfs(1); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while (q--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); int res = !cut[x] + !cut[y]; x = id[x], y = id[y]; if (dep[x] \u0026lt; dep[y]) swap(x, y); for (int i = 19; i \u0026gt;= 0; --i) { if (dep[f[x][i]] \u0026gt;= dep[y]) { res += g[x][i]; x = f[x][i]; } } if (x != y) { for (int i = 19; i \u0026gt;= 0; --i) { if (f[x][i] != f[y][i]) { res += g[x][i] + g[y][i]; x = f[x][i], y = f[y][i]; } } res += g[x][0] + g[y][0]; x = f[x][0]; } if (cut_id[x]) res++; printf(\u0026#34;%d\\n\u0026#34;, res); } return 0; } ","date":"2025-04-06T14:53:26Z","permalink":"https://invalidnamee.github.io/p/2025st15/","title":"2025春训第十五场"},{"content":"时隔好久，战斗爽终于复刻了😋，拿个榜一真不容易。\nA. Christmas Tree Adapter 终于有签到题了。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a, w, v; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; w \u0026gt;\u0026gt; v; if (a * v \u0026lt;= w) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } B. Cool Phone Numbers 而且签到题还不止一道。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; set\u0026lt;char\u0026gt; st; int main() { string s; cin \u0026gt;\u0026gt; s; for (char c : s) { if (isdigit(c)) st.insert(c); } cout \u0026lt;\u0026lt; st.size() \u0026lt;\u0026lt; endl; return 0; } C. Ready for Contest 竟然有四道。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; using namespace std; bool a[100010][4]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); a[x][y] = true; } for (int i = 1; i \u0026lt;= n; ++i) { if (a[i][1] \u0026amp; a[i][2]) printf(\u0026#34;%d\\n\u0026#34;, i); } return 0; } D. Fixing the Tournament 尽可能把排名低的两两组队，最后如果会输，还需要加上输的那一场。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { int n, r; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; min((int)floor(log2((1 \u0026lt;\u0026lt; n) - r + 1)) + 1, n) \u0026lt;\u0026lt; endl; return 0; } E. Identical Letters 比较经典的滑动窗口问题，枚举 26 个字母，遍历数组双指针维护到每一个位置时当前字母能构成的最长连续序列的长度，全部取 max 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); string s; int n, m; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; m; n = s.length(); s = \u0026#39; \u0026#39; + s; int res = 0; for (char c = \u0026#39;a\u0026#39;; c \u0026lt;= \u0026#39;z\u0026#39;; ++c) { for (int i = 1, j = 1, del = 0; i \u0026lt;= n; ++i) { if (s[i] != c) del++; while (j \u0026lt;= i \u0026amp;\u0026amp; del \u0026gt; m) if (s[j++] != c) del--; res = max(res, i - j + 1 - del); } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } F. Espresso Made Your Way 我没有调红温，绝对没有🤮🤮🤮，那个 +13 的绝对不是我😭\n设原来一杯的权重为 1，那么第一杯加进来的权重也是 1，再加第二杯的时候，因为前面已经浪费了一杯了，已有的这两杯的混合物变成一杯了，所以可以认为第二杯和前面两杯的量合起来是等价的，权重为 2，同理后面的权重是 4, 8, 16, 32……\n所以最后调出来的东西☕️（🥛）占的比例肯定是\n\\[\\frac{1}{2^n}(k_0 + \\sum_{i = 0}^{n - 1}k_{i + 1} 2^i)\\]\n其中 n 为浪费的杯数，k 为 0 或 1. 其实求和符号里的就是一个整数的二进制表示，所以整个式子其实等价于 \\(\\frac{k}{2^n}, k \\in [0, 2^n] \\cap \\mathbb{Z}\\)。然后就好说了，枚举 k 验证能不能成立就行。需要注意枚举的范围，应该枚举到 \\(\\log_2{10^{12}}\\)！！！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; long long c1, m1, c2, m2; int main() { cin \u0026gt;\u0026gt; c1 \u0026gt;\u0026gt; m1 \u0026gt;\u0026gt; c2 \u0026gt;\u0026gt; m2; if (c1 * m2 \u0026gt; c2 * m1) swap(c1, c2), swap(m1, m2); if (c1 == 0 || c2 == 0 || m1 == 0 || m2 == 0) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else { m1 += c1, m2 += c2; int i = 0; while (true) { __int128_t l = 0, r = (1ll \u0026lt;\u0026lt; i); bool f = false; while (l \u0026lt;= r) { __int128_t mid = (l + r) \u0026gt;\u0026gt; 1; if (mid * m2 \u0026gt; (__int128_t)c2 * (1ll \u0026lt;\u0026lt; i)) r = mid - 1; else if (mid * m1 \u0026lt; (__int128_t)c1 * (1ll \u0026lt;\u0026lt; i)) l = mid + 1; else { f = true; break; } } if (f) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; return 0; } i++; } } return 0; } 这是正着试的办法，还可以反着尝试，更 easy 一些，不需要二分尝试，把 C 和 M 不断除以 2，直到最后一个不相等的位置。\nG. Speed Ups 相对比较好做，线性 dp 维护到每一个加速的位置的最短时间（这里指的是可以踩到这个加速的情况，不包括上一个加速没用完路过这里的情况），然后枚举起点和所有加速的位置，算走到终点的时长取 min.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iomanip\u0026gt; #define int long long using namespace std; struct Node { int x, m, d; } a[1010]; int f[1010]; signed main() { int n, l; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;l); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;a[i].x, \u0026amp;a[i].m, \u0026amp;a[i].d); } sort(a + 1, a + n + 1, [](Node a, Node b) { return a.x \u0026lt; b.x; }); for (int i = 1; i \u0026lt;= n; ++i) { f[i] = 0x3f3f3f3f; for (int j = 0; j \u0026lt; i; ++j) { if ((long long)a[j].m * a[j].d \u0026lt;= (a[i].x - a[j].x)) { f[i] = min(f[i], f[j] + a[j].d + (a[i].x - a[j].x - a[j].m * a[j].d)); } } } double res = 1e18; for (int i = 0; i \u0026lt;= n; ++i) { if ((long long)a[i].x + (long long)a[i].m * a[i].d \u0026lt;= l) res = min(res, (double)(f[i] + a[i].d + (l - a[i].m * a[i].d - a[i].x))); else res = min(res, (double)(f[i]) + (double)(l - a[i].x) / a[i].m); } printf(\u0026#34;%lf\\n\u0026#34;, res); return 0; } H. Magnetic Attractions 众所周知，根据高中物理知识，这个区域是一个圆形区域，以 s 为原点， \\(\\vec{sS}\\) 方向为 x 轴，垂直的方向为 y 轴重新建一个坐标系，记 S 的新的坐标为 (d, 0).\n\\[\\frac{s}{x^2 + y^2} = \\frac{S}{(x - d)^2 + y^2}\\]\n整理可得\n\\[(x - \\frac{s}{s - S})^2 + y^2 = \\frac{sd - sd^2}{s - S}\\]\n\\[r^2 = \\frac{sd - sd^2}{s - S}\\]\n直接套圆的面积公式就能算出来\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { double s1, x1, y1, s2, x2, y2; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; s2 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; double d = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2)); double r2 = pow(s1 * d / (s2 - s1), 2) - s1 * d * d / (s1 - s2), pi = acos(-1); printf(\u0026#34;%lf\\n\u0026#34;, pi * r2); return 0; } I. Hotel Rooms 单点修改，区间查询，线段树或者树状数组都可以，个人感觉树状数组好写一点，于是就写的树状数组，也是一遍秒了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; using namespace std; int n, m; int tr[500010]; bool f[500010]; void add(int u, int val) { for (; u \u0026lt;= n; u += u \u0026amp; -u) { tr[u] += val; } } int query(int u) { int res = 0; for (; u; u -= u \u0026amp; -u) { res += tr[u]; } return res; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { add(i, 1); } for (int i = 1; i \u0026lt;= m; ++i) { char s[2]; scanf(\u0026#34;%s\u0026#34;, s); if (s[0] == \u0026#39;A\u0026#39;) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); printf(\u0026#34;%d\\n\u0026#34;, query(r) - query(l - 1)); } else { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); if (!f[x]) f[x] = true, add(x, -1); } } return 0; } ","date":"2025-04-04T11:21:25Z","permalink":"https://invalidnamee.github.io/p/2025st14/","title":"2025春训第十四场"},{"content":"A. 团结 其实非常简单，但是我中招了😭\n他这个操作等价于先把 \\(\\gcd_{i = 1}^{n} A_i\\)算出来，然后在 1 ～ n 里面选一些数和前面的结果取 gcd，直到结果为 1.\n最坏最坏的情况，就是 gcd(n - 1, n) = 1，然后和前面的取 gcd 一定是 1，代价是 3；所以只需要枚举代价是否存在 1 和代价是 2 的两种情况即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 100010; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } int a[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } int g = a[1]; if (g == 1) printf(\u0026#34;0\\n\u0026#34;); else if (gcd(g, n) == 1) printf(\u0026#34;1\\n\u0026#34;); else if (gcd(g, n - 1) == 1) printf(\u0026#34;2\\n\u0026#34;); else printf(\u0026#34;3\\n\u0026#34;); return 0; }\tB. 染色 简单的 dfs 题，从根开始往下搜，遇到不符合的就染色，统计次数即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 100010; vector\u0026lt;int\u0026gt; ed[N]; int col[N], t[N]; int res; void dfs(int x) { if (col[x] != t[x]) { col[x] = t[x]; res++; } for (int y : ed[x]) { col[y] = col[x]; dfs(y); } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 2; i \u0026lt;= n; ++i) { int p; scanf(\u0026#34;%d\u0026#34;, \u0026amp;p); ed[p].push_back(i); } for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;t[i]); } dfs(1); printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } C. 三元组 （还在 TLE 但是有戏）\nE. 思维导图 一笔画问题，离散 2-2 刚讲了。对于每个连通块，记度数为奇数的点有 k 个，则需要画 \\(\\lceil \\frac{k}{2} \\rceil\\) 次。把连通块的答案累加即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 10010; int deg[N]; vector\u0026lt;int\u0026gt; ed[N]; int cnt; bool v[N]; void dfs(int x) { if (v[x]) return; v[x] = true; if (deg[x] \u0026amp; 1) cnt++; for (int y : ed[x]) { dfs(y); } } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); ed[x].push_back(y); ed[y].push_back(x); deg[x]++, deg[y]++; } int res = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (!v[i]) { cnt = 0; dfs(i); if (!cnt) res++; else res += (cnt + 1) \u0026gt;\u0026gt; 1; }\t} printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } F. ESP_8266 这就是个单纯的模拟题，没什么需要注意的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import re l = [] while True: try: s = input() l.append(s) except EOFError: break s = \u0026#39;\\n\u0026#39;.join(l) pos = 0 for i in re.findall(r\u0026#39;\\([+-]\\d{2}\\)\u0026#39;, s): if i[1] == \u0026#39;+\u0026#39;: pos += int(i[2:4]) else: pos -= int(i[2:4]) print(pos) ","date":"2025-04-04T11:19:59Z","permalink":"https://invalidnamee.github.io/p/2025st13/","title":"2025春训第十三场"},{"content":"A. 拼写检查 按要求模拟就行，只需要注意 如果要检查的单词在词表中出现，则原样输出该单词。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 s = input() n = int(input()) l = [input() for _ in range(n)] if s in l: print(s) else: for t in l: f = False if (len(s) == len(t)): if (sum(s[i] != t[i] for i in range(len(s))) == 1): f = True elif (len(s) == len(t) + 1): for i in range(len(s)): if (s[:i] + s[i + 1:] == t): f = True break elif (len(s) == len(t) - 1): for i in range(len(t)): if (s == t[:i] + t[i + 1:]): f = True break if f: print(t) break else: print(\u0026#39;NOANSWER\u0026#39;) B. 翻转 有点类似线性dp的思想，核心问题就是 0 和 1 的分界点在哪。预处理把右侧全变成 1 的操作数。\n特别的对于 i = n， 时如果是 s\n\\[i\\] = 0，翻转一次；如果 s\n\\[i\\] = 1，不用翻转；\n其他情况，如果 s\n\\[i\\] = 1，不用动；如果 s\n\\[i\\] = 0 并且 s\n\\[i + 1\\] = 0，不用消耗翻转次数（因为把对于 \\[s\\[i + 1\\], n] 的最后一次翻转改成对于 \\[s\\[i\\], n] 的翻转就行），否则翻转两次（先把后面全变 0，然后一起变成 1）。\n然后从左到右遍历，枚举分界点，遍历到 i 时把 i 变成 1，然后考虑当前翻转次数的奇偶性\n如果是偶数，后面的序列不变，可以直接用前面维护的结果；\n如果是奇数，后面序列翻转，如果 s\n\\[i + 1\\] 本来是 1，那只能再翻转一次了；如果 s\n\\[i + 1\\] 本来是 0，说明维护的时候已经翻转了一次，直接把最后一次无效翻转撤销掉即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; int a[100010], b[100010]; int main() { int n, t = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%1d\u0026#34;, \u0026amp;a[i]); } a[n + 1] = 1; for (int i = n; i; --i) { if (a[i] || a[i + 1] == a[i]) b[i] = b[i + 1]; else if (i == n) b[i] = 1; else b[i] = b[i + 1] + 2; } int res = b[1]; for (int i = 1; i \u0026lt;= n; ++i) { if ((a[i] ^ (t \u0026amp; 1)) \u0026amp;\u0026amp; a[i] != a[i - 1]) t++; res = min(res, t + ((t \u0026amp; 1) ? (a[i + 1] ? b[i + 1] + 1 : b[i + 1] - 1) : b[i + 1])); } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } C. 集合 比较暴力的做法（容易爆空间），可以用分治的思想，预处理 k 小的，暴力 k 大的，平均每次查询只需要 1000 次左右计算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; unordered_map\u0026lt;int, int\u0026gt; s; int n; struct FenwickTree { int val[100001]; bool mark[100001]; void add(int u) { if (mark[u]) return; mark[u] = true; for (; u \u0026lt;= n; u += u \u0026amp; -u) { val[u] += 1; } } int query(int u) { int res = 0; for (; u; u -= u \u0026amp; -u) { res += val[u]; } return res; } } tr[101]; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int q; cin \u0026gt;\u0026gt; q; n = q; while (q--) { char c; int x; cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; x; if (c == \u0026#39;+\u0026#39;) { if (s[x] == 0) { for (int i = 1; i \u0026lt;= 100; ++i) { if (x % i == 0) { if (x / i \u0026lt;= 100000) tr[i].add(x / i); } } } s[x]++; } else { if (x \u0026gt; 100) { int i; for (i = 1; s[i * x]; ++i); cout \u0026lt;\u0026lt; i * x \u0026lt;\u0026lt; endl; } else { int l = 1, r = 100000; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (tr[x].query(mid) \u0026lt; mid) r = mid; else l = mid + 1; } cout \u0026lt;\u0026lt; l * x \u0026lt;\u0026lt; endl; } } } return 0; } 不那么暴力的做法，因为没有删除操作，所以对于每一个 k，后一次得到的答案一定是在前一次答案的后面，于是把较小的 k 打上标记，每次查询从标记开始往后面查即可（但是我没想到，还在暴力树状数组+二分）。\nD. 计数 线性dp，大概思路很好想，比较难做到的是不重不漏，我🧠不行，于是写了个 \\(O(2^n \\times n^3)\\)的大暴力对拍拍出来了。\n每个 \\(A_i\\) 只能有被删和不被删两种情况，令 \\(f_{i, 0}\\) 表示只考虑 \\[1, i\\] 这个区间的内的数的情况下第 i 个数不被删的方案数，\\(f_{i, 1}\\) 表示被删的方案数。\n如果 \\(A_i\\) 前有比他小的数，记第一个比他小的数为 \\(A_j\\)。\n首先考虑 \\(f_{i, 0}\\)，\\(A_i\\) 可以删的区间有 \\[k, i - 1\\]，其中 j + 1 ≤ k ≤ i - 1，在不全删掉的情况下，从左到右删和从右到左删一定是不重复的，所以方案数是 \\(\\sum_{k = j + 1}^{i - 1} f_{i, 0}\\)；如果 \\[j + 1, i - 1\\] 全删掉了，方案数就是 j 的方案数 \\(f_{j, 0} + f_{j, 1}\\)，合并一下有\n\\[f_{i, 0} = \\sum_{k = j}^{i - 1} f_{k, 0} + f_{j, 1}\\]\n考虑 \\(f_{i, 1}\\)，\\(A_i\\) 可以被 \\(A_j\\) 删也可以被能删掉 \\(A_j\\) 的点删，所以\n\\[f_{i, 1} = f_{j, 0} + f_{j, 1}\\]\n如果没有比他小的数， 他可以 \\[k, i - 1\\]，1 ≤ k ≤ i - 1，方案数就是不全删的方案数 + 全删的方案数（就是 1）\n\\[f_{i, 0} = \\sum_{k = 1}^{i - 1}f_{k, 0} + 1\\]\n他不可能被左边的删掉，所以 \\(f_{i, 1} = 0\\).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; const int MOD = 998244353; const int N = 300010; int st[N], tp; long long f[N][2], s[N]; int a[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); s[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); while (tp \u0026amp;\u0026amp; a[i] \u0026lt;= a[st[tp]]) tp--; if (!tp) { f[i][0] = s[i - 1]; } else { f[i][0] = (((s[i - 1] - s[st[tp] - 1] + f[st[tp]][1]) % MOD) + MOD) % MOD; f[i][1] = (f[st[tp]][0] + f[st[tp]][1]) % MOD; } s[i] = (s[i - 1] + f[i][0]) % MOD; st[++tp] = i; } printf(\u0026#34;%lld\\n\u0026#34;, (f[n][0] + f[n][1]) % MOD); return 0; } 📎 大暴力，枚举所有子序列，挨个检查合法性（如果一个点被删了，那么一定有一个比他小的点没有被删，并且这两个点路径上的所有点都被删了）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; using namespace std; int a[20]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i]; } int t = 0; for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; n); ++mask) { bool big_f = true; for (int i = 1; i \u0026lt;= n; ++i) { if (((mask \u0026gt;\u0026gt; (i - 1)) ^ 1) \u0026amp; 1) { bool f = false; for (int j = 1; j \u0026lt;= n; ++j) { if ((mask \u0026gt;\u0026gt; (j - 1)) \u0026amp; 1) { if (a[j] \u0026lt; a[i]) { bool ck = true; int l = min(i, j), r = max(i, j); for (int ii = l + 1; ii \u0026lt; r; ++ii) { if (mask \u0026gt;\u0026gt; (ii - 1) \u0026amp; 1) { ck = false; break; } } if (ck) { f = true; break; } } } } if (!f) { big_f = false; break; } } } t += big_f; } cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-04-02T11:30:01Z","permalink":"https://invalidnamee.github.io/p/2025st12/","title":"2025春训第十二场"},{"content":"刚开始一看发现啥都不会，细看发现以为简单的很复杂，以为很复杂的很简单。\nA. 游戏 约数尽可能多，所以应该让约数尽可能小，那就让他都是 2，找一个最大的 i，使得 l ≤ (1 « i) ≤ r 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; for (int i = 30; i \u0026gt;= 0; --i) { if (l \u0026lt;= (1 \u0026lt;\u0026lt; i) \u0026amp;\u0026amp; (1 \u0026lt;\u0026lt; i) \u0026lt;= r) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; return 0; } } return 0; } B. 或 只需要依次考虑每个二进制位是否含 1。于是可以从第 0 位开始一位一位找这个范围内是否包含一个 1 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); long long res = 0; for (int i = 0; i \u0026lt; 30; ++i) { if (l \u0026lt; r || (l \u0026amp; 1) || (r \u0026amp; 1)) res |= 1 \u0026lt;\u0026lt; i; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1; } printf(\u0026#34;%lld\\n\u0026#34;, res); } return 0; } C. 最长子序列 非常反直觉的一道题，看上去很简单，实际上很恶心。\n长度很好算，直接开个桶标记一下就行，主要问题是如何构造出字典序最小的合法子序列。不难想出要让尽可能靠前的位置选到最优解，所以可以基于贪心的思想构造。\n维护每个元素出现的位置序列第一次出现的位置和最后出现的位置；\n从小到大遍历最后出现的位置，设该位置是 a 最后出现的位置，把前面的所有没有选过的元素加入备选集合；\n根据奇偶性贪心地从备选集合里选出当前最优的那个数，同时保证这个数如果在备选集合重复出现，选择的一定是最左边的一个，输出这个数；\n将这个数所在位置左侧的所有备选项全部删掉，如果删掉的一个元素在右侧仍有出现则通过位置序列找到第一个合法位置更新第一次出现的位置；\n如果这个数不是 a 则转 3，如果是 a 则结束挑选转 2。\n解释第 5 条步骤：a 的存在限制了其他元素可选的位置，如果先选了 a 的位置后面其他元素，那么 a 就一定选不到了；但是如果 a 已经选走了，那么 a 将不会对其他元素的选择产生限制，因此可以扩大挑选范围以保证最优。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 300010; int a[N], fp[N], p[N], ne[N]; // fp 是第一次出现的位置，ne 是下一次出现的位置，p 是维护 ne 的过程量 multiset\u0026lt;int\u0026gt; s; // 备选集合 bool v[N]; int ls[N]; // 最后出现的位置 int main() { int n, m = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); if (!fp[a[i]]) { m++; fp[a[i]] = i; p[a[i]] = i; } else { ne[p[a[i]]] = i; p[a[i]] = i; } } printf(\u0026#34;%d\\n\u0026#34;, m); bool f = true; // true: 找最大 false: 找最小 for (int i = n, t = 0; i; --i) { if (!v[a[i]]) { ne[i] = n + 1; v[a[i]] = true, ls[m - t++] = i; } } memset(v, 0, sizeof(v)); int lstp = 0; // 上次出现的位置 for (int i = 1; i \u0026lt;= m; ++i) { for (int j = ls[i - 1] + 1; j \u0026lt;= ls[i]; ++j) { if (!v[a[j]]) s.insert(a[j]); } if (v[a[ls[i]]]) continue; while (!s.empty()) { multiset\u0026lt;int\u0026gt;::iterator it; if (f) it = --s.end(); else it = s.begin(); int num = *it; v[num] = true; printf(\u0026#34;%d \u0026#34;, num); s.erase(num); // 全部删掉 for (int j = lstp + 1; j \u0026lt;= fp[num]; ++j) { if (!v[a[j]]) { s.erase(s.find(a[j])); // 只删一个 while (fp[a[j]] \u0026lt; fp[num]) fp[a[j]] = ne[fp[a[j]]]; } } lstp = fp[num]; f ^= 1; if (num == a[ls[i]]) break; } } printf(\u0026#34;\\n\u0026#34;); return 0; } E. 精灵球 数据分层，预处理间隔不大于 1000 的查询，暴力处理间隔大于 1000 的查询，最坏 1e8 的计算量完全可以过。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int a[N]; long long b[1010][1010]; int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int j = 1; j \u0026lt;= 1000; ++j) { b[j][i % j] += a[i]; } } while (q--) { int op, x, y; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;op, \u0026amp;x, \u0026amp;y); if (op == 1) { if (x \u0026lt;= 1000) printf(\u0026#34;%lld\\n\u0026#34;, b[x][y % x]); else { long long res = 0; for (int i = y; i \u0026lt;= n; i += x) res += a[i]; for (int i = y - x; i \u0026gt; 0; i -= x) res += a[i]; printf(\u0026#34;%lld\\n\u0026#34;, res); } } else { for (int j = 1; j \u0026lt;= 1000; ++j) { b[j][x % j] += y - a[x]; } a[x] = y; } } return 0; } F. 钢条(stick) 我一直在从切割的角度看，没想到从切出的段的角度看。\n首先 n 是没用的，只看 k 即可。切了 k 刀之后会切出来 k + 1 段，只要有一段长度 ≥ \\(\\frac{n}{2}\\)就不合法，每一段 ≥ \\(\\frac{n}{2}\\)的概率是相等的而且是独立的（因为不可能两段都满足，和总长度为 n 矛盾），都是 \\(\\frac{1}{2 ^ k}\\)，所以不合法概率是 \\(\\frac{k + 1}{2 ^ k}\\)，合法概率是 \\(1 - \\frac{k + 1}{2 ^ k}\\)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int a = m + 1, b = 1 \u0026lt;\u0026lt; m; int g = gcd(a, b); cout \u0026lt;\u0026lt; (b - a) / g \u0026lt;\u0026lt; \u0026#39;/\u0026#39; \u0026lt;\u0026lt; b / g \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-03-29T05:15:28Z","permalink":"https://invalidnamee.github.io/p/2025st11/","title":"2025春训第十一场"},{"content":"A. 鲁的学生 大水题，但是我没看到要取模连 WA 两次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int MOD = 1000000007; int main() { long long res = 0; int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); res += (long long)i * (n - i + 1) % MOD * t % MOD; res %= MOD; } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } B. 鲁的探险 n 个点 n 条边，而且每个点都至少有 1 度，显然这张图是基环树（一棵树随便加一条边构成的连通的只有一个环的图）构成森林。所有的点最后都会走到对应连通块的环里，随后绕一圈结束；明白了这点那么做法就很简单了，记点 i 的答案为 \\(val_i\\)\n划分连通块；\n对每个连通块找到环的位置；\n对于每个环，环上的点的 \\(A_i\\) 求和赋给这个环上的所有点；\n从所有环上的点开始搜索反图，更新其他点的 \\(val_i\\)。\n代码比较恶心，如需参考，请谨慎。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010; vector\u0026lt;int\u0026gt; ed[N]; int pre[N]; int a[N], vis[N], tot; int cir[N]; long long sum[N]; bool mark[N]; bool v[N]; // 这里我原来是把 val 用作标记数组，然后因为有 val 是 0 但是确实访问过的数据导致不是爆栈就是 t // 发现之后一怒之下开了这个 vvvvv bool vvvvv[N]; long long val[N]; void bfs(int i) { queue\u0026lt;int\u0026gt; q; q.push(i); vis[i] = tot; while (!q.empty()) { int x = q.front(); q.pop(); for (int y : ed[x]) { if (vis[y]) continue; vis[y] = tot; q.push(y); } if (!vis[pre[x]]) { vis[pre[x]] = tot; q.push(pre[x]); } } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;pre[i]); ed[pre[i]].push_back(i); } for (int i = 1; i \u0026lt;= n; ++i) { if (!vis[i]) { tot++; bfs(i); } } queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++i) { if (!mark[vis[i]]) { mark[vis[i]] = true; int x, y; for (x = i; !v[x]; x = pre[x]) { v[x] = true; } y = x; do { cir[y] = vis[i]; sum[vis[i]] += a[y]; y = pre[y]; } while (y != x); } } for (int i = 1; i \u0026lt;= n; ++i) { if (cir[i]) { q.push(i); vvvvv[i] = true; val[i] = sum[cir[i]]; } } while (!q.empty()) { int x = q.front(); q.pop(); for (int y : ed[x]) { if (vvvvv[y]) continue; vvvvv[y] = true; val[y] = val[x] + a[y]; q.push(y); } } for (int i = 1; i \u0026lt;= n; ++i) { printf(\u0026#34;%lld\\n\u0026#34;, val[i]); } return 0; } C. 他会输出啥 我用 python 写的，实际上用 C++ 区别不大，注意别爆 int 就行。\n思路是把第二个循环直接用等差数列求和公式算出来，只跑第一层循环时间复杂度是完全够的的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def fun(a, b, c): if a in range(a, b, c): t = len(range(a, b, c)) return a * t + c * t * (t - 1) // 2 else: return 0 input() s = input() a, b, c = map(int, s[s.find(\u0026#39;(\u0026#39;) + 1:s.find(\u0026#39;)\u0026#39;)].split(\u0026#39;,\u0026#39;)) s = input() d, e, f = s[s.find(\u0026#39;(\u0026#39;) + 1:s.find(\u0026#39;)\u0026#39;)].split(\u0026#39;,\u0026#39;) if d.isalpha() and e.isalpha(): print(sum(fun(i, i, int(f)) for i in range(a, b, c))) elif d.isalpha(): print(sum(fun(i, int(e), int(f)) for i in range(a, b, c))) elif e.isalpha(): print(sum(fun(int(d), i, int(f)) for i in range(a, b, c))) else: print(sum(fun(int(d), int(e), int(f)) for i in range(a, b, c))) ","date":"2025-03-24T09:41:59Z","permalink":"https://invalidnamee.github.io/p/2025st10/","title":"2025 春训第十场"},{"content":"A. 鲁的智力 我刚开始看到这道题之后默默的放弃了，选择了后面的 dp 题。\n最小排名：至少有多少个人比他分数高。\n最大排名：至少有多少个人比他分数低。\n两边都是考虑极限情况，以第一种为例。一个人要想稳定的分数比另一个人高，那必然每道题都比另一个高，于是问题转化成至少有几个人每道题分数都比他高。设第 i 道题的排名是 \\(a_i\\)，考虑一道题的时候，情况是确定的，这道题比他高的人肯定满足所有题都比他高；两道题的时候，考虑边界情况——第二道题比他高的人和第一道题比他高的人最大程度的不重叠，所以人数应该是 \\(\\max{0, a_2 + a_1 - m - 1}\\)；现在相当于前两道题已经合成一道大的题了，再不断往下计算就能算出来最后的结果。第二种同理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int a[1010]; int main() { int n, m, l, r; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; l = r = m - 1; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i]; l = max(0, a[i] + l - m); r = max(0, (m - a[i]) + r - (m - 1)); } cout \u0026lt;\u0026lt; l + 1 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m - r \u0026lt;\u0026lt; endl; return 0; } B. 鲁的女孩 最优的配对方案是一个正序一个倒序一一配对。关键的性质是 1 ≤ a, b ≤ 100，开两个数组记录 \\[1, 100\\] 每个数的个数，然后双指针扫描一次即可得出答案。事实可以证明，挺容易写挂的（比如我）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int a[210], b[210]; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { int ta, tb; cin \u0026gt;\u0026gt; ta \u0026gt;\u0026gt; tb; a[ta]++, b[tb]++; int mx = -0x3f3f3f3f; int l = 0, r = 101; int lc = 0, rc = 0; while (l \u0026lt;= 100 \u0026amp;\u0026amp; r \u0026gt; 0) { if (lc \u0026amp;\u0026amp; rc) { mx = max(mx, l + r); int tmp = min(lc, rc); lc -= tmp, rc -= tmp; } if (!rc) rc = b[--r]; if (!lc) lc = a[++l]; } cout \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; endl; } return 0; } C. 鲁的石板 前排警告，最好别用 vector 一直申请内存容易 TLE😭\n这题好像有数学的方法可以一个式子秒了，没关系，我会一个矩阵快速幂秒了。\n线性 dp 的方法是开一个状态数组 f\n\\[N\\]\\[2\\]，f\n\\[i\\]\\[0\\] = 表示涂到第 i 块且第 i 块颜色和第一块一致的方案数，f\n\\[i\\]\\[1\\] 表示涂到第 i 块且第 i 块颜色和第一块不一致的方案数，答案是 f\n\\[n\\]\\[1\\]。\n\\[f_{i, 0} = f_{i - 1, 1}\\]\n\\[f_{i, 1} = (m - 1)f_{i - 1, 0} + (m - 2)f_{i - 1, 1}\\]\n用矩阵乘法写这个递推式\n\\[\\begin{pmatrix} f_{i - 1, 0} \u0026amp; f_{i - 1, 1} \\end{pmatrix} \\begin{pmatrix} 0 \u0026amp; m - 1\\ 1 \u0026amp; m - 2 \\end{pmatrix} = \\begin{pmatrix} f_{i, 0} \u0026amp; f_{i, 1} \\end{pmatrix}\\]\n显然答案是 \\([\\begin{pmatrix} m \u0026amp; 0\\end{pmatrix}\\begin{pmatrix} 0 \u0026amp; m - 1 \\ 1 \u0026amp; m - 2 \\end{pmatrix}^{n - 1}]{1, 2}\\)，即 \\(m\\begin{pmatrix} 0 \u0026amp; m - 1 \\ 1 \u0026amp; m - 2 \\end{pmatrix}^{n - 1}{1, 2}\\).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MOD = 1000000007; long long mat[2][2], res[2][2], a[2][2], b[2][2]; void mul(long long a[][2], long long b[][2]) { static long long t[2][2]; t[0][1] = t[0][0] = t[1][1] = t[1][0] = 0; for (int k = 0; k \u0026lt; 2; ++k) { for (int i = 0; i \u0026lt; 2; ++i) { for (int j = 0; j \u0026lt; 2; ++j) { t[i][j] = (t[i][j] + a[i][k] * b[k][j] % MOD) % MOD; } } } for (int i = 0; i \u0026lt; 2; ++i) { for (int j = 0; j \u0026lt; 2; ++j) { a[i][j] = t[i][j]; } } } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); if (n == 1) { cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; continue; } mat[0][0] = 0, mat[0][1] = m - 1, mat[1][0] = 1, mat[1][1] = m - 2; res[0][0] = res[1][1] = 1, res[0][1] = res[1][0] = 0; n--; while (n) { if (n \u0026amp; 1) mul(res, mat); mul(mat, mat); n \u0026gt;\u0026gt;= 1; } printf(\u0026#34;%d\\n\u0026#34;, (long long)m * res[0][1] % MOD); } return 0; } D. 游览计划 提供一个暴力的解法，具体有多暴力见下图，差点拼尽全力无法战胜了……\n暴力的流程是\n对于每一个点跑一遍 bfs 找到到所有其他点的最短路；\n对于每一个点找到最短路最长的三个点，记下来；\n暴力枚举中间点 B, C，枚举到 B 距离最长的三个 A，到 C 距离最长的三个 D，过滤所有A, B, C, D 重复情况，把路径加起来更新答案。\n这个做法显然是正确的，存了三个最远的点保证了最坏的情况下也不至于全部冲突。\n代码后续更新了一下，不会 997ms 了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 4010, M = 5010; int head[N], ne[M * 2], ver[M * 2], tot; int d[N][N], q[N], hh, tt; int mxp[N][3]; inline void read(int \u0026amp;_) { _ = 0; char c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) _ = _ * 10 + c - 48, c = getchar(); } inline void add(int x, int y) { ver[++tot] = y; ne[tot] = head[x]; head[x] = tot; } int main() { int n, m; read(n), read(m); for (int i = 1; i \u0026lt;= m; ++i) { int x, y; read(x), read(y); add(x, y); add(y, x); } memset(d, -1, sizeof(d)); for (int i = 1; i \u0026lt;= n; ++i) { hh = tt = 0; d[i][i] = 0; q[tt] = i; while (hh \u0026lt;= tt) { int x = q[hh++]; if (d[i][x] \u0026gt;= d[i][mxp[i][0]]) { mxp[i][2] = mxp[i][1], mxp[i][1] = mxp[i][0]; mxp[i][0] = x; } else if (d[i][x] \u0026gt;= d[i][mxp[i][1]]) { mxp[i][2] = mxp[i][1]; mxp[i][1] = x; } else if (d[i][x] \u0026gt;= d[i][mxp[i][2]]) { mxp[i][2] = x; } for (int j = head[x]; j; j = ne[j]) { int y = ver[j]; if (~d[i][y]) continue; d[i][y] = d[i][x] + 1; q[++tt] = y; } } } int res = 0; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt; i; ++j) { for (int k = 0; k \u0026lt; 3; ++k) { if (mxp[i][k] == j) continue; for (int p = 0; p \u0026lt; 3; ++p) { if (i != mxp[j][p] \u0026amp;\u0026amp; mxp[i][k] != mxp[j][p]) res = max(res, d[mxp[i][k]][i] + d[i][j] + d[j][mxp[j][p]]); } } } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } ","date":"2025-03-24T09:41:34Z","permalink":"https://invalidnamee.github.io/p/2025st9/","title":"2025春训第九场"},{"content":"旧版的和 hyoi 一起崩了，所以再发一遍升级版\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; class Hipre { vector\u0026lt;int\u0026gt; a; public: void mv(int t) { vector\u0026lt;int\u0026gt; b(t, 0); b.insert(b.end(), a.begin(), a.end()); a = b; } Hipre() { a = vector\u0026lt;int\u0026gt;(1, 0); } Hipre(int n) { if (!n) { a = vector\u0026lt;int\u0026gt;(1, 0); } else while (n) { a.push_back(n % 10); n /= 10; } } int length() const { return a.size(); } int to_int() { int res = 0, mul = 1; for (int i = 0; i \u0026lt; a.size(); ++i) { res += a[i] * mul; mul *= 10; } return res; } int \u0026amp;operator [](const int \u0026amp;p) { return a[p]; } friend istream \u0026amp;operator \u0026gt;\u0026gt;(istream \u0026amp;cin, Hipre \u0026amp;a) { static string s; cin \u0026gt;\u0026gt; s; a.a = vector\u0026lt;int\u0026gt;(s.length()); for (int i = 0; i \u0026lt; s.length(); ++i) { a.a[i] = s[s.length() - i - 1] - 48; } while (a.length() \u0026gt; 1 \u0026amp;\u0026amp; a.a.back() == 0) a.a.pop_back(); return cin; } friend ostream \u0026amp;operator \u0026lt;\u0026lt;(ostream \u0026amp;cout, const Hipre \u0026amp;a) { for (int i = a.length() - 1; i \u0026gt;= 0; --i) cout \u0026lt;\u0026lt; a.a[i]; return cout; } bool operator \u0026lt;(const Hipre \u0026amp;c) const { if (length() != c.length()) return length() \u0026lt; c.length(); else { for (int i = length() - 1; i \u0026gt;= 0; --i) { if (a[i] != c.a[i]) return a[i] \u0026lt; c.a[i]; } return false; } } bool operator ==(const Hipre \u0026amp;c) const { if (length() != c.length()) return false; else { for (int i = length() - 1; i \u0026gt;= 0; --i) { if (a[i] != c.a[i]) return false; } return true; } } Hipre operator +(const Hipre \u0026amp;c) { auto \u0026amp;b = c.a; Hipre res; res.a = vector\u0026lt;int\u0026gt;(max(a.size(), b.size()) + 1, 0); for (int i = 0; i \u0026lt; res.length(); ++i) { if (i \u0026lt; a.size() \u0026amp;\u0026amp; i \u0026lt; b.size()) res[i] += a[i] + b[i]; else if (i \u0026lt; a.size()) res[i] += a[i]; else if (i \u0026lt; b.size()) res[i] += b[i]; if (res[i] \u0026gt; 9) res.a[i + 1] += 1, res[i] -= 10; } while (res.length() \u0026gt; 1 \u0026amp;\u0026amp; res.a.back() == 0) res.a.pop_back(); return res; } Hipre operator -(const Hipre \u0026amp;c) { Hipre res = *this; for (int i = 0; i \u0026lt; res.length(); ++i) { if (i \u0026lt; c.length()) res[i] -= c.a[i]; if (res[i] \u0026lt; 0) res[i] += 10, res.a[i + 1] -= 1; } while (res.length() \u0026gt; 1 \u0026amp;\u0026amp; res.a.back() == 0) res.a.pop_back(); return res; } Hipre operator *(const Hipre \u0026amp;c) { auto \u0026amp;b = c.a; Hipre res; res.a = vector\u0026lt;int\u0026gt;(a.size() + b.size(), 0); for (int i = 0; i \u0026lt; a.size(); ++i) { for (int j = 0; j \u0026lt; b.size(); ++j) { res.a[i + j] += a[i] * b[j]; } } for (int i = 0; i \u0026lt; res.length() - 1; ++i) { res.a[i + 1] += res[i] / 10; res[i] %= 10; } while (res.length() \u0026gt; 1 \u0026amp;\u0026amp; res.a.back() == 0) res.a.pop_back(); return res; } Hipre operator *=(const int \u0026amp;c) { if (c) a.resize(a.size() + (int)floor(log10(c)) + 1); for (int i = 0; i \u0026lt; a.size(); ++i) { a[i] *= c; } for (int i = 0; i \u0026lt; a.size() - 1; ++i) { if (a[i] \u0026gt; 9) a[i + 1] += a[i] / 10, a[i] %= 10; } while (a.size() \u0026gt; 1 \u0026amp;\u0026amp; a.back() == 0) a.pop_back(); return *this; } Hipre operator *(const int \u0026amp;c) { Hipre t = *this; return t *= c; } Hipre operator /(const int \u0026amp;c) { Hipre res; res.a = vector\u0026lt;int\u0026gt;(a.size()); int t = 0; for (int i = a.size() - 1; i \u0026gt;= 0; --i) { t = t * 10 + a[i]; if (t \u0026gt;= c) res[i] = t / c; t %= c; } while (res.length() \u0026gt; 1 \u0026amp;\u0026amp; res.a.back() == 0) res.a.pop_back(); return res; } Hipre operator /(Hipre c) { Hipre res, b = *this; int l = b.length() - c.length(); res.a = vector\u0026lt;int\u0026gt;(l + 1, 0); c.mv(b.length() - c.length()); for (int i = l; i \u0026gt;= 0; --i) { while (!(b \u0026lt; c)) { b = b - c; res[i]++; } c.a.erase(c.a.begin()); } while (res.length() \u0026gt; 1 \u0026amp;\u0026amp; res.a.back() == 0) res.a.pop_back(); return res; } Hipre operator %(Hipre c) { Hipre b = *this; int l = b.length() - c.length(); c.mv(b.length() - c.length()); for (int i = l; i \u0026gt;= 0; --i) { while (!(b \u0026lt; c)) { b = b - c; } c.a.erase(c.a.begin()); } while (b.length() \u0026gt; 1 \u0026amp;\u0026amp; b.a.back() == 0) b.a.pop_back(); return b; } }; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); Hipre a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; a / b \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-03-22T03:15:46Z","permalink":"https://invalidnamee.github.io/p/high-precision/","title":"高精全家桶（升级版）"},{"content":"这次训练赛主打一个特殊情况 RE，不细心一点有一万个坑能让程序炸掉……\nA. 能量传输 不难（不容易）发现，k 越小聚集到的位置越多，操作次数越小，所以做法是\n统计 1 的个数，找到除了 1 以外的最小的约数作为 k；\n每 k 个 1 分成一组，各组独立计算最小操作次数；\n使得操作数最小的位置一定是中位数，所以把到位置中位数的距离求和即可。\n注意特判 0 个，会炸掉！！！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;vector\u0026gt; #define int long long using namespace std; int a[100010], b[100010]; int len; signed main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n, s = 0, l; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i]; s += a[i]; } if (s == 0) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } l = sqrt(s); int t = s; for (int i = 2; i \u0026lt;= l; ++i) { if (s % i == 0) { t = i; break; } } long long res = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (a[i]) b[++len] = i; if (len == t) { int pos = b[(len + 1) / 2]; for (int j = 1; j \u0026lt;= len; ++j) { res += abs(b[j] - pos); } len = 0; } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } B. 能源危机 你说的对，但是我可以用 Python，用 C++ 写高精的话大概思路就是除数后面补零直到最高位和被除数对齐，减到不能再减，然后除数删一个零继续减，高精全家桶传送门。\n1 2 3 4 5 import sys sys.set_int_max_str_digits(300000) a = int(input()) b = int(input()) print(a // b) C. 鲁星救援 没什么技术含量，来来回回搜的很恶心。先从 s 搜到 p，把路上的点全都标记上；然后，把标记上的点都加到一个新队列里，搜 t 即可。\nps：注意按照题目说的顺序搜。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; /* 上代表 1，右代表 2，下代表 3，左代表 4 */ const int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1}; int a[1010][1010]; int dis[1010][1010]; bool vis[1010][1010]; pair\u0026lt;int, int\u0026gt; pre[1010][1010]; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n, m, sx, sy, tx, ty, px, py; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; sx \u0026gt;\u0026gt; sy \u0026gt;\u0026gt; tx \u0026gt;\u0026gt; ty \u0026gt;\u0026gt; px \u0026gt;\u0026gt; py; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { cin \u0026gt;\u0026gt; a[i][j]; } } // 边界全都堵上，防止搜出去数组越界 RE for (int i = 1; i \u0026lt;= n; ++i) a[i][0] = a[i][m + 1] = 1; for (int i = 1; i \u0026lt;= m; ++i) a[0][i] = a[n + 1][i] = 1; queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; q.push({sx, sy}); vis[sx][sy] = true; bool f = false; while (!q.empty()) { auto x = q.front(); q.pop(); if (x == make_pair(px, py)) { f = true; while (!q.empty()) { q.pop(); } memset(vis, 0, sizeof(vis)); if (pre[x.first][x.second] == make_pair(0, 0)) { vis[sx][sy] = true; dis[sx][sy] = 1; q.push({sx, sy}); break; } do { q.push(x); dis[x.first][x.second] = 1; vis[x.first][x.second] = true; x = pre[x.first][x.second]; } while (x != make_pair(sx, sy)); vis[sx][sy] = true; dis[sx][sy] = 1; q.push(make_pair(sx, sy)); break; } for (int i = 0; i \u0026lt; 4; ++i) { auto y = x; y.first += dx[i], y.second += dy[i]; if (a[y.first][y.second] || vis[y.first][y.second]) continue; pre[y.first][y.second] = x; vis[y.first][y.second] = true; q.push(y); } } if (!f) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } while (!q.empty()) { auto x = q.front(); q.pop(); for (int i = 0; i \u0026lt; 4; ++i) { auto y = x; y.first += dx[i], y.second += dy[i]; if (dis[y.first][y.second] || a[y.first][y.second]) continue; dis[y.first][y.second] = dis[x.first][x.second] + 1; q.push(y); } } cout \u0026lt;\u0026lt; dis[tx][ty] - 1 \u0026lt;\u0026lt; endl; return 0; } E. 俄罗斯方块 (tetris) 简化版：覆盖墙壁.\n我做这道题的时候用线性的 dp 打表找规律做的，实际上是可以直接推出来的。\n最后三个方块只要放进去一定会堵死，直接忽略；枚举最后一个完整的矩形块的形状，只有以下四种形状\n两个 1 × 4 的方块并排；\n一个 2 × 2 的方块；\n两个相同 L 形方块，中间可以夹多个 1 × 4 的方块；\n两个不同 L 形方块 + 一个 1 × 4 的方块，中间同样可以夹多个 1 × 4 的方块。\n如下图\n计 \\(f_i\\) 为 2 × i 时的方案数，不难得出\n\\[f_i = f_{i - 4} + f_{i - 2} + 2 (f_{i - 4} + f_{i - 8} + \\dots) + 2 (f_{i - 6} + f_{i - 10} + \\dots)\\]\n维护一个 f 数组的前缀和即可得到线性的做法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int MOD = 1000000007; int f[10000010]; int s[10000010], s2[10000010]; int main() { int n; while (cin \u0026gt;\u0026gt; n) { f[0] = 1; s[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { f[i] = 0; if (i - 2 \u0026gt;= 0) f[i] = (f[i] + f[i - 2]) % MOD; if (i - 4 \u0026gt;= 0) f[i] = (f[i] + f[i - 4]) % MOD; if (i \u0026gt;= 4) f[i] = (f[i] + 2 * s[i - 4] % MOD) % MOD; if (i \u0026gt;= 6) f[i] = (f[i] + 2 * s[i - 6] % MOD) % MOD; if (i \u0026gt;= 4) s[i] = (f[i] + s[i - 4]) % MOD; else s[i] = f[i]; } cout \u0026lt;\u0026lt; f[n] \u0026lt;\u0026lt; endl; } return 0; } 显然这还不够，数据范围是 1e18 还需要再优化，于是又到了喜闻乐见的矩阵快速幂环节。\n显然奇数是不可能的，对于偶数的情况重新编号一下（好看）\n\\[f_i = f_{i - 1} + f_{i - 2} + 2 (f_{i - 2} + f_{i - 4} + \\dots) + 2 (f_{i - 3} + f_{i - 5} + \\dots)\\]\n后面两项可以合并\n\\[f_i = f_{i - 1} + f_{i - 2} + 2 \\sum_{j = 0}^{i - 2}{f_j}\\]\n这样就好构造矩阵了，其中 \\(s_i = \\sum_{j = 0}^i{f_j}\\)\n\\[\\begin{pmatrix} f_{i - 2} \u0026amp; f_{i - 1} \u0026amp; s_{i - 2} \\end{pmatrix} \\begin{pmatrix} 0 \u0026amp; 1 \u0026amp; 0\\ 1 \u0026amp; 1 \u0026amp; 1\\ 0 \u0026amp; 2 \u0026amp; 1\\ \\end{pmatrix} = \\begin{pmatrix} f_{i - 1} \u0026amp; f_{i} \u0026amp; s_{i - 1} \\end{pmatrix}\\]\n累乘可以得到\n\\[\\begin{pmatrix} 1 \u0026amp; 1 \u0026amp; 1 \\end{pmatrix} \\begin{pmatrix} 0 \u0026amp; 1 \u0026amp; 0\\ 1 \u0026amp; 1 \u0026amp; 1\\ 0 \u0026amp; 2 \u0026amp; 1\\ \\end{pmatrix} ^{n - 1} = \\begin{pmatrix} f_{n - 1} \u0026amp; f_{n} \u0026amp; s_{n - 1} \\end{pmatrix}\\]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MOD = 1000000007; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; mul(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; b) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(3, vector\u0026lt;int\u0026gt;(3, 0)); for (int k = 0; k \u0026lt; 3; ++k) { for (int i = 0; i \u0026lt; 3; ++i) { for (int j = 0; j \u0026lt; 3; ++j) { res[i][j] = (res[i][j] + (long long)a[i][k] * b[k][j] % MOD) % MOD; } } } return res; } int main() { long long n; while (cin \u0026gt;\u0026gt; n) { if (n \u0026amp; 1) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else { n \u0026gt;\u0026gt;= 1; n--; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; mat = { {0, 1, 0}, {1, 1, 1}, {0, 2, 1} }, res = { {1, 0, 0}, {0, 1, 0}, {0, 0, 1} }; while (n) { if (n \u0026amp; 1) res = mul(res, mat); mat = mul(mat, mat); n \u0026gt;\u0026gt;= 1; } cout \u0026lt;\u0026lt; ((long long)res[1][0] + res[1][1] + 2 * res[1][2]) % MOD \u0026lt;\u0026lt; endl; } } return 0; } ","date":"2025-03-22T03:07:17Z","permalink":"https://invalidnamee.github.io/p/2025st8/","title":"2025春训第八场"},{"content":"众所周知离散课本 204 页 17 题让用 Dijkstra 和 Floyd 求一个 9 个结点的图的最短路径。2025 年 3 月 18 日上午，我抄了一节史纲课的 Dijkstra 过程和 Floyd 的邻接矩阵，心中愤懑不平。于是中午回宿舍猛敲代码零点几秒就把全部都过程都输出出来了，遂把代码打包跟离散作业一起交上去了。\n但是这样还不够，写的代码还能再水一篇博客（虽然不会有人看😭）\n图的存储 手敲 最好是把边一条一条敲出来，格式如 x y w，表示 x 和 y 间有一条边权为 w 的边(这道题是无向边).\ndat.txt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 9 15 1 2 6 1 3 3 1 4 2 2 3 2 3 4 2 2 5 1 4 5 6 4 6 10 5 6 10 5 7 2 6 8 2 5 8 3 7 9 3 5 9 6 8 9 4 标出来点数和边数方便程序读。\n电脑存 Dijkstra 最好用邻接表——说白了就是开 n 个单链表，可以用 C++ 的 vector 或者 Python 的 list 模拟，好处是占用相对邻接矩阵较小，而且遍历方便，适合不那么稠密的图。\nFloyd 只能用邻接矩阵，因为 Floyd 算法就是在矩阵上定义的。\n算法实现 这里暂时以书上的描述为准，方便理解。本地有 C++ 环境的话可以自己跑一下玩玩。实际上 Floyd 比 Dijkstra 好写很多，和直觉是相反的。\nDijkstra dijkstra.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 10; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; ed[N]; // 边表，存边 int d[N]; bool inP[N]; // 标记是否在 P 集合中 int main() { // 从 dat.txt 中读取数据 freopen(\u0026#34;dat.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;out_dij.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) { int x, y, z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; // 两条有向边模拟无向边 ed[x].push_back({z, y}); ed[y].push_back({z, x}); } // 初始化距离为无穷大 memset(d, 0x3f, sizeof(d)); d[1] = 0; for (int i = 1; i \u0026lt;= n; ++i) { // 寻找加入 P 集合的点 int x = 0; for (int j = 1; j \u0026lt;= n; ++j) { if (d[j] \u0026lt; d[x] \u0026amp;\u0026amp; !inP[j]) x = j; } inP[x] = true; // 用这个点更新其他相连的 T 集合中的点 for (auto [v, y] : ed[x]) { if (!inP[y]) d[y] = min(d[y], d[x] + v); } // 输出过程中的 P 集合，T 集合和 d 数组 cout \u0026lt;\u0026lt; \u0026#34;round \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;*****************************\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;P : \u0026#34;; for (int i = 1; i \u0026lt;= n; ++i) { if (inP[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T : \u0026#34;; for (int i = 1; i \u0026lt;= n; ++i) { if (!inP[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;d : \u0026#34;; for (int i = 1; i \u0026lt;= n; ++i) { if (d[i] == 0x3f3f3f3f) cout \u0026lt;\u0026lt; \u0026#34;inf\u0026#34; \u0026lt;\u0026lt; \u0026#39; \u0026#39;; else cout \u0026lt;\u0026lt; d[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;*****************************\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } Floyd floyd.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; const int N = 10; int D[N][N][N]; int main() { // 从 dat.txt 中读取数据 freopen(\u0026#34;dat.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;out_floyd.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); // 读取 \u0026amp; 预处理数据 int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; // 全部初始化成无穷大 memset(D, 0x3f, sizeof(D)); // 邻接矩阵主对角线初始化成 0 for (int i = 1; i \u0026lt;= n; ++i) D[0][i][i] = 0; for (int i = 1; i \u0026lt;= m; ++i) { int x, y, z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; D[0][x][y] = D[0][y][x] = z; } // 输出邻接矩阵 cout \u0026lt;\u0026lt; \u0026#34;A\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { if (D[0][i][j] == 0x3f3f3f3f) cout \u0026lt;\u0026lt; \u0026#34; inf\u0026#34;; else cout \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; D[0][i][j]; } cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; // FLoyd 并输出 D_k for (int k = 1; k \u0026lt;= n; ++k) { cout \u0026lt;\u0026lt; \u0026#34;D_\u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { D[k][i][j] = min(D[k - 1][i][j], D[k - 1][i][k] + D[k - 1][k][j]); if (D[k][i][j] == 0x3f3f3f3f) cout \u0026lt;\u0026lt; \u0026#34; inf\u0026#34;; else cout \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; D[k][i][j]; } cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } return 0; } 补充说明 Dijkstra 可以用堆优化，优化后的 Dijkstra 可以应对结点数和边数都在十万级别的数据。\n上面的代码没有写堆优化一方面是时间复杂度的瓶颈在输出过程上，另一方面是保证对初学者的可读性。\n在同时带边权和点权的无向图上跑堆优化的 Dijkstra 详见我的另一篇 article，欢迎🎉🎉🎉。\nFloyd 一般实现的时候不会开三维数组（可能是因为空间占用太大），不难发现如果不输出 D_k 的话第一维是多余的，直接在原邻接矩阵上操作不会影响结果， d[i][j] = min(d[i][j], d[i][k] + d[j][k]) 即可。\n附录：代码输出 out_dij.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 round 1 ***************************** P : 1 T : 2 3 4 5 6 7 8 9 d : 0 6 3 2 inf inf inf inf inf ***************************** round 2 ***************************** P : 1 4 T : 2 3 5 6 7 8 9 d : 0 6 3 2 8 12 inf inf inf ***************************** round 3 ***************************** P : 1 3 4 T : 2 5 6 7 8 9 d : 0 5 3 2 8 12 inf inf inf ***************************** round 4 ***************************** P : 1 2 3 4 T : 5 6 7 8 9 d : 0 5 3 2 6 12 inf inf inf ***************************** round 5 ***************************** P : 1 2 3 4 5 T : 6 7 8 9 d : 0 5 3 2 6 12 8 9 12 ***************************** round 6 ***************************** P : 1 2 3 4 5 7 T : 6 8 9 d : 0 5 3 2 6 12 8 9 11 ***************************** round 7 ***************************** P : 1 2 3 4 5 7 8 T : 6 9 d : 0 5 3 2 6 11 8 9 11 ***************************** round 8 ***************************** P : 1 2 3 4 5 6 7 8 T : 9 d : 0 5 3 2 6 11 8 9 11 ***************************** round 9 ***************************** P : 1 2 3 4 5 6 7 8 9 T : d : 0 5 3 2 6 11 8 9 11 ***************************** out_floyd.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 A 0 6 3 2 inf inf inf inf inf 6 0 2 inf 1 inf inf inf inf 3 2 0 2 inf inf inf inf inf 2 inf 2 0 6 10 inf inf inf inf 1 inf 6 0 10 2 3 6 inf inf inf 10 10 0 inf 2 inf inf inf inf inf 2 inf 0 inf 3 inf inf inf inf 3 2 inf 0 4 inf inf inf inf 6 inf 3 4 0 D_1 0 6 3 2 inf inf inf inf inf 6 0 2 8 1 inf inf inf inf 3 2 0 2 inf inf inf inf inf 2 8 2 0 6 10 inf inf inf inf 1 inf 6 0 10 2 3 6 inf inf inf 10 10 0 inf 2 inf inf inf inf inf 2 inf 0 inf 3 inf inf inf inf 3 2 inf 0 4 inf inf inf inf 6 inf 3 4 0 D_2 0 6 3 2 7 inf inf inf inf 6 0 2 8 1 inf inf inf inf 3 2 0 2 3 inf inf inf inf 2 8 2 0 6 10 inf inf inf 7 1 3 6 0 10 2 3 6 inf inf inf 10 10 0 inf 2 inf inf inf inf inf 2 inf 0 inf 3 inf inf inf inf 3 2 inf 0 4 inf inf inf inf 6 inf 3 4 0 D_3 0 5 3 2 6 inf inf inf inf 5 0 2 4 1 inf inf inf inf 3 2 0 2 3 inf inf inf inf 2 4 2 0 5 10 inf inf inf 6 1 3 5 0 10 2 3 6 inf inf inf 10 10 0 inf 2 inf inf inf inf inf 2 inf 0 inf 3 inf inf inf inf 3 2 inf 0 4 inf inf inf inf 6 inf 3 4 0 D_4 0 5 3 2 6 12 inf inf inf 5 0 2 4 1 14 inf inf inf 3 2 0 2 3 12 inf inf inf 2 4 2 0 5 10 inf inf inf 6 1 3 5 0 10 2 3 6 12 14 12 10 10 0 inf 2 inf inf inf inf inf 2 inf 0 inf 3 inf inf inf inf 3 2 inf 0 4 inf inf inf inf 6 inf 3 4 0 D_5 0 5 3 2 6 12 8 9 12 5 0 2 4 1 11 3 4 7 3 2 0 2 3 12 5 6 9 2 4 2 0 5 10 7 8 11 6 1 3 5 0 10 2 3 6 12 11 12 10 10 0 12 2 16 8 3 5 7 2 12 0 5 3 9 4 6 8 3 2 5 0 4 12 7 9 11 6 16 3 4 0 D_6 0 5 3 2 6 12 8 9 12 5 0 2 4 1 11 3 4 7 3 2 0 2 3 12 5 6 9 2 4 2 0 5 10 7 8 11 6 1 3 5 0 10 2 3 6 12 11 12 10 10 0 12 2 16 8 3 5 7 2 12 0 5 3 9 4 6 8 3 2 5 0 4 12 7 9 11 6 16 3 4 0 D_7 0 5 3 2 6 12 8 9 11 5 0 2 4 1 11 3 4 6 3 2 0 2 3 12 5 6 8 2 4 2 0 5 10 7 8 10 6 1 3 5 0 10 2 3 5 12 11 12 10 10 0 12 2 15 8 3 5 7 2 12 0 5 3 9 4 6 8 3 2 5 0 4 11 6 8 10 5 15 3 4 0 D_8 0 5 3 2 6 11 8 9 11 5 0 2 4 1 6 3 4 6 3 2 0 2 3 8 5 6 8 2 4 2 0 5 10 7 8 10 6 1 3 5 0 5 2 3 5 11 6 8 10 5 0 7 2 6 8 3 5 7 2 7 0 5 3 9 4 6 8 3 2 5 0 4 11 6 8 10 5 6 3 4 0 D_9 0 5 3 2 6 11 8 9 11 5 0 2 4 1 6 3 4 6 3 2 0 2 3 8 5 6 8 2 4 2 0 5 10 7 8 10 6 1 3 5 0 5 2 3 5 11 6 8 10 5 0 7 2 6 8 3 5 7 2 7 0 5 3 9 4 6 8 3 2 5 0 4 11 6 8 10 5 6 3 4 0 ","date":"2025-03-18T14:43:12Z","permalink":"https://invalidnamee.github.io/p/dm01/","title":"离散数学：最短路的代码实现"},{"content":"写了一半，群里发出来官方题解了……但是我码风比他的好，可读性强一点，但是为了强迫症和留作记录，我必须写完😇。所以这篇博客的性质已经从题解 transform 成赛后的感想了。\n个人感觉有点像是水赛的感觉，L1 非常顺利，L2 和 L3 的最后两道开始调不出来，最终结果是 190 分(我的 L3-1 的 30 分还被队友吃了😭），L1 拿满，L2 的 3，4 WA，L3 的 2 TLE，3 没看。\n我的 windows 还没回来，所以用的机房的编译一下就死机的电脑（但这不是我没存代码的理由），只能事后重敲一遍代码了，顺便回忆一下当时的心情。\nL1 基础级 L1 的 8 道题都非常顺利，没有被卡，可惜速度还是没有 @xx liu (qwertyuiop) 快。\nL1-1 遇见YFffffff 1 print(\u0026#39;Hello YFffffff\u0026#39;) L1-2 桃之夭夭，灼灼其华 1 2 3 n = int(input()) s = max(map(int, input().split())) print(s, \u0026#39;sad\u0026#39; if s \u0026amp; 1 else \u0026#39;love\u0026#39;) L1-3 体温预警系统 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 n = int(input()) if n: t = [0 for i in range(4)] s = [\u0026#39;zhengchang\u0026#39;, \u0026#39;dire\u0026#39;, \u0026#39;gaore\u0026#39;, \u0026#39;yichangshuju\u0026#39;] for i in range(n): tmp = round(float(input()) * 10) if tmp in range(360, 373): t[0] += 1 elif tmp in range(373, 381): t[1] += 1 elif tmp in range(381, 411): t[2] += 1 else: t[3] += 1 print(\u0026#39;\\n\u0026#39;.join(f\u0026#39;{s[i]}:{t[i]}\u0026#39; for i in range(4) if t[i])) else: print(\u0026#39;wuxiaoshuju\u0026#39;) L1-4 破碎的心，无法挽回的距离 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; int a[110]; int main() { int n, res = 0x3f3f3f3f; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i]; } for (int p = 1; p \u0026lt;= 100; ++p) { int s = 0; for (int i = 1; i \u0026lt;= n; ++i) { s += (a[i] - p) * (a[i] - p); } res = min(res, s); } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } L1-5 心碎？抽卡时间！ 1 2 3 4 5 6 7 8 9 10 a = list(map(int, input().split())) b = list(map(int, input().split())) for i in range(4): if a[i] \u0026lt; b[i]: print(\u0026#39;spider YFffffff\u0026#39;) break else: a[i + 1] += (a[i] - b[i]) // 5 else: print(a[4] if a[4] else \u0026#39;QAQ\u0026#39;) L1-6 字符串糕手 1 2 3 4 5 6 7 8 l = int(input()) s = input() res = 1000 for i in range(l // 2, l): t = s[:i] + s[i::-1] res = min(res, i * 2 + 1 - l) if s == (s[:i] + s[i::-1])[:l] else res res = min(res, i * 2 - l) if s == (s[:i] + s[i - 1::-1])[:l] else res print(res) L1-7 若敢来氪，必叫你大败而归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 l = [] n, x = map(int, input().split()) for i in range(n): a = input().split() l.append((-int(a[1]), -int(a[2]), -int(a[3]), int(a[4]), a[0])) cnt = 0 l.sort() for i in l: if x - i[3] \u0026gt;= 0: print(i[4]) x -= i[3] cnt += 1 else: break print(cnt) L1-8 回到她的身边好吗 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 n, m, k, p = map(int, input().split()) a = [(0, 0)] for i in range(m): a.append(tuple(map(int, input().split()))) a.append((n, n)) a.sort() for i in range(1, len(a)): if a[i][0] - a[i - 1][1] \u0026gt; k: if p and k: p, k = p - 1, k - 1 else: print(\u0026#39;buguanle\u0026#39;, a[i - 1][1]) break else: print(\u0026#39;YES\u0026#39;, k) 这个时候 L1 顺着做完了，还在沾沾自喜。\nL2 进阶级 实话说我感觉不是很困难的，但是 wa 了两道题。\nL2-1 来自YFffffff的挑战 这个策略当时有一定蒙的成分，实际上也是正确的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int T; cin \u0026gt;\u0026gt; T; while (T--) { int n; string s, t = \u0026#34;\u0026#34;; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; if (n == 1 || s[1] \u0026gt;= s[0]) cout \u0026lt;\u0026lt; s[0] \u0026lt;\u0026lt; s[0] \u0026lt;\u0026lt; endl; else { for (char c : s) { if (t.empty() || c \u0026lt;= t.back()) t += c; else break; } cout \u0026lt;\u0026lt; t; for (int i = t.length() - 1; i \u0026gt;= 0; --i) cout \u0026lt;\u0026lt; t[i]; cout \u0026lt;\u0026lt; endl; } } return 0; } L2_2 不要刁难我们了 最短路板子题，做到这儿的时候也还是非常顺利，这时候心态已经被机房电脑磨的差不多了，这次不怪电脑怪我没事先拷过来一份新的编译器，我在本地调试的时候因为 \u0026gt;\u0026gt;\u0026gt; 不能连续，auto 遍历 vector 不能用被折磨的要死，还好是一遍过了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 200010; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; ed[N]; int w[N]; long long dis[N], cnt[N]; bool vis[N]; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n, m, s, t; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; w[i]; for (int i = 1; i \u0026lt;= m; ++i) { int x, y, z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; ed[x].push_back({z, y}); ed[y].push_back({z, x}); } priority_queue\u0026lt;pair\u0026lt;long long, int\u0026gt;, vector\u0026lt;pair\u0026lt;long long, int\u0026gt;\u0026gt;, greater\u0026lt;pair\u0026lt;long long, int\u0026gt;\u0026gt;\u0026gt; q; memset(dis, 0x3f, sizeof(dis)); cnt[s] = 1; dis[s] = 0; q.push({dis[s], s}); while (!q.empty()) { int x = q.top().second; q.pop(); if (vis[x]) continue; vis[x] = true; for (auto [v, y] : ed[x]) { if (dis[y] \u0026gt; dis[x] + w[y] + v) { dis[y] = dis[x] + w[y] + v; cnt[y] = cnt[x]; q.push({dis[y], y}); } else if (dis[y] == dis[x] + w[y] + v) { cnt[y] += cnt[x]; } } } cout \u0026lt;\u0026lt; dis[t] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; cnt[t] \u0026lt;\u0026lt; endl; return 0; } L2-3 花非花，雾非雾 我 wa 掉的做法是开了个队列存储边，有更改的时候从更改的点出发 dfs 更新所有能更新的点，但是问题在于我 dfs 的路径并不一定是按照边从前到后更新的；其实当时又想到用并查集，但是最后又暂时放弃了。\n这道题最后的有效关系图一定是一个森林，每个连通子图都是有向树，边从根指向叶子，其中只有根结点的 a 已经给出，从根到叶子跑一遍 dfs 就可以更新出所有点的 a；用并查集可以维护一个子图内是否已经有一个 a 已经给出的根节点，对于一个 U 关系，两个已经有根的子图连在一起或者子图内部连边可能会矛盾，即使不矛盾这条边也是多余的，所以全部都判定为无效即可。\nps: dfs 会爆栈，别问我怎么知道的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 40010; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; ed[N]; int fa[N], a[N]; bool f[N]; // 维护是否已经有根 int getfa(int x) { return x == fa[x] ? x : fa[x] = getfa(fa[x]); } int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) fa[i] = i; while (m--) { char c; cin \u0026gt;\u0026gt; c; if (c == \u0026#39;U\u0026#39;) { int x, y, w; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; w; int px = getfa(x), py = getfa(y); if (px == py || (f[px] \u0026amp; f[py])) continue; fa[py] = px; f[px] ^= f[py]; ed[x].push_back({w, y}); ed[y].push_back({w, x}); } else { int x, w; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; w; if (!f[getfa(x)]) { a[x] = w; f[getfa(x)] = true; } } } queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++i) { if (a[i]) q.push(i); } while (!q.empty()) { int x = q.front(); q.pop(); for (auto [v, y] : ed[x]) { if (a[y]) continue; a[y] = a[x] ^ v; q.push(y); } } for (int i = 1; i \u0026lt;= n; ++i) { if (!a[i]) { cout \u0026lt;\u0026lt; \u0026#34;sad\u0026#34; \u0026lt;\u0026lt; endl; return 0; } } for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; } L2-4 是留不住你的冰寒飞影 我现在还认为滑动窗口是可行的，考场上写的可能逻辑还是有点小问题，本质上我当时写的单调队列只是没有具象化的把点合并了。照着题解的思路写完代码之后发现我当时的问题是维护的范围小了，一个滑动窗口能 0 代价到达的最左端和最右端由左侧第二个和右侧第二个点决定，而不是窗口的左右端点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int a[N]; int l[N], r[N], t; int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n, k, m; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;k, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } t = 0; a[0] = -0x3f3f3f3f, a[n + 1] = 0x3f3f3f3f; for (int i = 1; i \u0026lt;= n; ++i) { if (i == 1 \u0026amp;\u0026amp; a[i + 1] - a[i] \u0026gt; k || i == n \u0026amp;\u0026amp; a[i] - a[i - 1] \u0026gt; k) { t++; l[t] = r[t] = a[i]; } else if (a[i] - a[i - 1] \u0026lt;= k) { l[t] = min(l[t], a[i] - k); r[t] = max(r[t], a[i - 1] + k); } else if (a[i + 1] - a[i] \u0026lt;= k) { t++; l[t] = r[t] = a[i]; } } for (int i = 2; i \u0026lt;= t; ++i) { m -= (l[i] - r[i - 1] + k - 1) / k; } if (m \u0026gt;= 0) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); } return 0; } L3 登顶级 L3-1 银白之森 想到敲了二十多分钟基环树 dp 代码，我自己都想笑😇😇😇。这是一张后继图，每个点初度为1，所以构成基环树，然后我就想偏了。其实不用区分环内环外直接一起倍增预处理一下然后把 k 二进制分解算就行。还是忘不了之前一道树上倍增 + 环形dp 的基环树题😮‍💨，我写着写着发现环里面还得倍增，然后用了同一个倍增数组，又写了一会儿才发现问题的严重性，直接把代码全删了重写了一遍。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int f[N][50]; long long g[N][50]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;f[i][0]); g[i][0] = f[i][0]; } for (int j = 1; j \u0026lt; 50; ++j) { for (int i = 1; i \u0026lt;= n; ++i) { f[i][j] = f[f[i][j - 1]][j - 1]; g[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1]; } } while (m--) { int x; long long k, res = 0; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;x, \u0026amp;k); for (int i = 0; i \u0026lt; 50; ++i) { if (k \u0026gt;\u0026gt; i \u0026amp; 1) { res += g[x][i]; x = f[x][i]; } } printf(\u0026#34;%lld\\n\u0026#34;, res); } return 0; } L3-2 摸球游戏 当时矩阵快速幂 t 了，按说不该 t 的；但是这不是重点，重点是：我要向我高中数学老师道歉😭，这道题是一阶线性递推求通项，我把他当二阶的了，甚至还试图找特征方程。2025/03/07 晚上 22:00 我突然意识到了问题的严重性，于是一个不动点求出来等比数列的递推式然后秒了。他的题解太麻烦了，其实这就是一道平平无奇的高中概率题，果然上大学🧠会退化。\n计球的总个数为 n，i 次操作后的期望为 \\(E_i\\)，根据期望递推，有\n\\[E_i = \\frac{E_{i - 1}}{n}E_{i - 1} + \\frac{n - E_{i - 1}}{n}(E_{i - 1} + 1)\\]\n化简得\n\\[E_i = \\frac{n - 1}{n}E_{i - 1} + 1\\]\n计算不动点，解方程 \\(x = \\frac{n - 1}{n}x + 1\\)得，\\(x= n\\). 所以有\n\\[E_i - n = \\frac{n - 1}{n}(E_{i - 1} - n)\\]\n后面就不用我教了，首项是 n - a，公比是 \\(\\frac{n - 1}{n}\\)等比数列通向公式直接求 \\(E_k\\)即可。\n对不起 90 老师，过了半年就忘干净了😭😭😭.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; using namespace std; int MOD = 1000000007; long long power(long long n, long long p) { long long res = 1, base = n; while (p) { if (p \u0026amp; 1) res = res * base % MOD; base = base * base % MOD; p \u0026gt;\u0026gt;= 1; } return res; } int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int T; long long a, b, c, k; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; k; b += a; cout \u0026lt;\u0026lt; (((a - b + MOD) % MOD * power((b - 1) * power(b, MOD - 2) % MOD, k)) % MOD + b + MOD) % MOD \u0026lt;\u0026lt; endl; } return 0; } L3-3 电荷 这道自己做是真做不出来，正确的结论是一个 D 合法当且仅当按 x 排序检查和按 y 排序检查至少有一个可以通过，其余情况通过适当交换可以转化成按 x 和 y 检查的一种。如果我自己想只能想到按其中一个排序，调代码的时候也是调的非常头疼。\n代码还可以压一压，排序和前缀后缀 max 和 min 可以写成一个函数。但是我已经不想看这个💩了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 100010; pair\u0026lt;int, int\u0026gt; a[N]; int pre_mn[N], pre_mx[N], pos_mn[N], pos_mx[N]; int n; long long pow2(int t) { return (long long)t * t; } long long calc(int l, int r) { if (l == 1 \u0026amp;\u0026amp; r == n) return 0; int mn = 0x3f3f3f3f, mx = -0x3f3f3f3f; if (l != 1) mn = min(mn, pre_mn[l - 1]), mx = max(mx, pre_mx[l - 1]); if (r != n) mn = min(mn, pos_mn[r + 1]), mx = max(mx, pos_mx[r + 1]); return max(pow2(mx - mn), max(pow2(mx), pow2(mn)) + max(pow2(a[l].first), pow2(a[r].first))); } bool check(long long mid) { for (int i = 1, j = 1; i \u0026lt;= n; ++i) { while (j \u0026lt;= n \u0026amp;\u0026amp; (long long)(a[j].first - a[i].first) * (a[j].first - a[i].first) \u0026lt;= mid) { if (calc(i, j) \u0026lt;= mid) return true; j++; } if (calc(i, j - 1) \u0026lt;= mid) return true; } return false; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[i].first, \u0026amp;a[i].second); } sort(a + 1, a + n + 1); pre_mn[0] = 0x3f3f3f3f; pre_mx[0] = -0x3f3f3f3f; pos_mn[n + 1] = 0x3f3f3f3f; pos_mx[n + 1] = -0x3f3f3f3f; for (int i = 1; i \u0026lt;= n; ++i) { pre_mx[i] = max(pre_mx[i - 1], a[i].second); pre_mn[i] = min(pre_mn[i - 1], a[i].second); } for (int i = n; i; --i) { pos_mx[i] = max(pos_mx[i + 1], a[i].second); pos_mn[i] = min(pos_mn[i + 1], a[i].second); } long long l = 0, r = 80000000000000000; while (l \u0026lt; r) { long long mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } long long res = l; for (int i = 1; i \u0026lt;= n; ++i) swap(a[i].first, a[i].second); sort(a + 1, a + n + 1); pre_mn[0] = 0x3f3f3f3f; pre_mx[0] = -0x3f3f3f3f; pos_mn[n + 1] = 0x3f3f3f3f; pos_mx[n + 1] = -0x3f3f3f3f; for (int i = 1; i \u0026lt;= n; ++i) { pre_mx[i] = max(pre_mx[i - 1], a[i].second); pre_mn[i] = min(pre_mn[i - 1], a[i].second); } for (int i = n; i; --i) { pos_mx[i] = max(pos_mx[i + 1], a[i].second); pos_mn[i] = min(pos_mn[i + 1], a[i].second); } l = 0, r = 80000000000000000; while (l \u0026lt; r) { long long mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } res = min(res, l); printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } 终于补完了，奖励自己歇一晚上😴😴😴\n","date":"2025-03-18T13:34:31Z","permalink":"https://invalidnamee.github.io/p/tianti2025cd/","title":"第四届成都信息工程大学天梯赛"},{"content":"这训练赛怎么越来越水了，C 考场上没做出来，D 调了很久，但是实际上都不怎么算难，剩下的四道就是纯粹的大水题了。\nA. 抽牌 我代码写的比较麻烦，实际上没必要。\n答案为 0：已经满足其中一个条件了；\n答案为 1：花色相同的牌中，有两个相同或者差 1 或 2；\n答案为 2：以上都不满足。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; t[128]; int main() { for (int i = 0; i \u0026lt; 3; ++i) { char c; int tmp; cin \u0026gt;\u0026gt; tmp \u0026gt;\u0026gt; c; t[c].push_back(tmp); } int res = 3; for (int i = 0; i \u0026lt; 128; ++i) { if (!t[i].empty()) { sort(t[i].begin(), t[i].end()); if (t[i].size() == 1) res = min(res, 2); else if (t[i].size() == 2) { if (t[i][1] - t[i][0] == 2 || t[i][1] - t[i][0] == 1) res = min(res, 1); else res = min(res, 2); if (t[i][0] == t[i][1]) res = min(res, 1); } else if (t[i].size() == 3) { if (t[i][0] + 1 == t[i][1] \u0026amp;\u0026amp; t[i][1] + 1 == t[i][2]) { res = 0; break; } else if (t[i][0] == t[i][1] \u0026amp;\u0026amp; t[i][1] == t[i][2]) { res = 0; break; } else if (t[i][0] == t[i][1] || t[i][1] == t[i][2]) { res = min(res, 1); } else if (t[i][1] - t[i][0] == 2 || t[i][1] - t[i][0] == 1 || t[i][2] - t[i][1] == 2 || t[i][2] - t[i][1] == 1) { res = min(res, 1); } } } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } B. 区间求和 直接前缀和 + map/二分 就行。\nps：别学我把 int 爆了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; #define int long long using namespace std; map\u0026lt;long long, int\u0026gt; mp; signed main() { long long res = 0; int n, m; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); vector\u0026lt;long long\u0026gt; s(n + 1, 0); mp[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;s[i]); s[i] += s[i - 1]; res += mp[s[i] - m]; mp[s[i]] ++; } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } C. 鲁的要塞 对于一组要塞，他们的的指挥中心的横(纵)坐标必然是他们横(纵)坐标的中位数，个数为偶数的情况任取中间的两个点都是可以的，所以中心的坐标一定在已有的数值中选；暴力枚举已经给出的点横纵坐标自由组合，对每个点分别求距离，排序前缀和更新答案即可。\nps：别学我把 int 爆了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #define int long long using namespace std; int p[110][2]; int a[110], b[110]; signed main() { int n, k; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;p[i][0], \u0026amp;p[i][1]); } memset(a, 0x3f, sizeof(a)); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { for (int k = 1; k \u0026lt;= n; ++k) { b[k] = abs(p[i][0] - p[k][0]) + abs(p[j][1] - p[k][1]); } sort(b + 1, b + n + 1); for (int k = 1; k \u0026lt;= n; ++k) { b[k] += b[k - 1]; a[k] = min(a[k], b[k]); } } } for (int i = 1; i \u0026lt;= k; ++i) printf(\u0026#34;%lld\\n\u0026#34;, a[i]); return 0; } D. 能源晶体 这是一道 dp 题。\n**关键性质：**题目中的方案数等价于用总长为 n 的长度为 \\[1, k\\] 的单调不减的线段右端点对齐覆盖 \\[1, k\\] 这个区间的方案数。这么做解除了 k 个位置的限制，并且仍然保持了 k 元组的有序性（这里的线段长包括端点，长度为 l，表示最后 l 个数都 +1）\n定义状态：\\(f_{i, j}\\)，表示目前用了 i 个模块，最后一条线段长度为 j 的方案数，答案显然是 \\(f_{n, k}\\).\n状态转移：\\(f_{i, j} = \\sum_{l = 1}^{j}{f_{i - l, l}}\\)，求和可以在 dp 的过程中用前缀和优化，时间复杂度降到 \\(O(nk)\\).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; const int MOD = 998244353; int f[5010][5010]; int n, k; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 1; i \u0026lt;= k; ++i) f[0][i] = 1; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= k; ++j) { if (j \u0026lt;= i) f[i][j] = (f[i][j - 1] + f[i - j][j]) % MOD; else f[i][j] = f[i][j - 1]; } } cout \u0026lt;\u0026lt; ((f[n][k] - f[n][k - 1]) % MOD + MOD) % MOD \u0026lt;\u0026lt; endl; return 0; } E. 资料页数 鉴定为水题，把脚注的行数捆绑到行里面暴力模拟即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; const int N = 200010; vector\u0026lt;int\u0026gt; ed[N]; int f[N]; int n, m, k; bool dp(int x, int fa) { f[x] = 1; int t = 0; for (int y : ed[x]) { if (y == fa) continue; if (!dp(y, x)) return false; if (f[y]) t++; f[x] += f[y]; } if (t \u0026gt; 2) return false; else if (t == 2) { if (f[x] != k) return false; else f[x] = 0; } else { f[x] %= k; } return true; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 1; i \u0026lt; n * k; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); ed[x].push_back(y); ed[y].push_back(x); } if (dp(1, 1)) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } F. 再破难关 代码量略大的水题，把状态压成 16 位二进制数，状态个数一共只有 \\(2^{16}\\)个，直接 bfs 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; queue\u0026lt;int\u0026gt; q; int s = 0, t = 0; int f[100000]; int g[4][4]; void to_g(int mask) { for (int i = 0; i \u0026lt; 16; ++i) { g[i / 4][i % 4] = mask \u0026gt;\u0026gt; i \u0026amp; 1; } } int to_s() { int res = 0; for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { res |= g[i][j] \u0026lt;\u0026lt; (i * 4 + j); } } return res; } int main() { memset(f, -1, sizeof(f)); int s, t; for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { scanf(\u0026#34;%1d\u0026#34;, \u0026amp;g[i][j]); } } s = to_s(); for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { scanf(\u0026#34;%1d\u0026#34;, \u0026amp;g[i][j]); } } t = to_s(); f[s] = 0; q.push(s); while (!q.empty()) { int x = q.front(); q.pop(); if (x == t) { printf(\u0026#34;%d\\n\u0026#34;, f[x]); return 0; } to_g(x); for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { if (i \u0026lt; 3 \u0026amp;\u0026amp; g[i][j] != g[i + 1][j]) { swap(g[i][j], g[i + 1][j]); int y = to_s(); if (!(~f[y])) { f[y] = f[x] + 1; q.push(y); } swap(g[i][j], g[i + 1][j]); } if (j \u0026lt; 3 \u0026amp;\u0026amp; g[i][j] != g[i][j + 1]) { swap(g[i][j], g[i][j + 1]); int y = to_s(); if (!(~f[y])) { f[y] = f[x] + 1; q.push(y); } swap(g[i][j], g[i][j + 1]); } } } } return 0; } ","date":"2025-03-15T13:52:11Z","permalink":"https://invalidnamee.github.io/p/2025st7/","title":"2025春训第七场"},{"content":"感觉这次做的还行，主要还是简单题多了一点。数学题赛后被 GPT 秒了，而我追着 GPT 问了半天……\nA. 魔法石 签到题，但是有点绕（我就被坑了）。有解的条件是三个数都相等或者两个数相等，另一个比这两个小；前者直接输出三个相等的，后者输出一个较大的和两个较小的即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { long long a[3]; scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;a[0], \u0026amp;a[1], \u0026amp;a[2]); sort(a, a + 3); if (a[0] != a[1] \u0026amp;\u0026amp; a[1] != a[2]) printf(\u0026#34;NO\\n\u0026#34;); else if (a[1] \u0026lt; a[2]) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n%lld %lld %lld\\n\u0026#34;, a[1], a[0], a[0]); return 0; } B. 回文立方数 直接枚举 \\(i \\in [1, \\lfloor \\sqrt[3]{N} \\rfloor]\\)，验证 i³ 是否回文，找最大的即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; bool check(long long t) { string s = to_string(t); for (int i = 0; i \u0026lt; s.length(); ++i) { if (s[i] != s[s.length() - i - 1]) return false; } return true; } int main() { long long n, t = 0; cin \u0026gt;\u0026gt; n; for (int i = 1; (long long)i * i * i \u0026lt;= n; ++i) { if (check((long long)i * i * i)) { t = (long long)i * i * i; } } printf(\u0026#34;%lld\\n\u0026#34;, t); return 0; } C. gcd 还没问明白 GPT，但是强迫症趋势我必须在第七场前发第六场，所以先🐦一下。\n这是事后不知道什么原理过了的代码，似乎要求 a 是 b - a 的倍数而且和 b - a 二进制位不重叠。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int n; cin \u0026gt;\u0026gt; n; long long ans = 0; for (int d = 1; d \u0026lt;= n; d++){ for (int a = d; a + d \u0026lt;= n; a += d) { if ((a ^ (a + d)) == d) { ans++; } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } E. 摘Galo 类似树形背包问题，树形dp回溯的时候用孩子的 f 数组更新父亲的 f 数组，最后父亲的 \\(f_1 = min{f_1, w}\\)，注意优化常数，容易被卡成 TLE。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 100010; int head[N], ne[N], ver[N], tot; int w[N]; vector\u0026lt;long long\u0026gt; f[N]; int cnt[N]; int n, k; void add(int x, int y) { ver[++tot] = y; ne[tot] = head[x]; head[x] = tot; } void dp(int x) { cnt[x] = 1; long long s = 0; for (int i = head[x]; i; i = ne[i]) { int y = ver[i]; dp(y); cnt[x] += cnt[y]; for (int j = min(k + 1, cnt[x]); j; --j) { for (int l = min(cnt[y], j); l \u0026gt;= 0; --l) { f[x][j] = max(f[x][j], f[x][j - l] + f[y][l]); } } } f[x][1] = max(f[x][1], (long long)w[x]); } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 2; i \u0026lt;= n; ++i) { int f; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;f, \u0026amp;w[i]); add(f, i); } for (int i = 1; i \u0026lt;= n; ++i) { f[i] = vector\u0026lt;long long\u0026gt;(k + 2, 0); } dp(1); long long res = 0; for (int i = 0; i \u0026lt;= k + 1; ++i) { res = max(res, f[1][i]); } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } F. 队列安排 排序，从小到大排就行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; long long a[100010]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); } sort(a + 1, a + n + 1); long long s = 0; for (int i = 1; i \u0026lt; n; ++i) { a[i] += a[i - 1]; s += a[i]; } printf(\u0026#34;%lld\\n\u0026#34;, s); return 0; } ","date":"2025-03-15T13:51:32Z","permalink":"https://invalidnamee.github.io/p/2025st6/","title":"2025春训第六场"},{"content":"又是熟悉的博弈问题，又是熟悉的做不出来，不过剩下三道能做出来的都挺有意思的，相对比较满足。\nA. 游戏 答案= min(max(从小到大交替选，从大到小交替选)，max(A从最大的连续选，A从最小的连续选)).\n提示：A 希望答案尽可能大，所以由 A 决策决定的应取 max，B 希望答案尽可能小，所以由 B 决策决定的应该取 min.\n建议：给 @xx liu (qwertyuiop) 佬磕一个\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int a[100010]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } sort(a + 1, a + n + 1); long long A = 0, B = 0; long long res; for (int i = n; i \u0026gt; 0; i -= 2) A += a[i]; for (int i = n - 1; i \u0026gt; 0; i -= 2) B += a[i]; res = abs(A) - abs(B); A = 0, B = 0; for (int i = 1; i \u0026lt;= n; i += 2) A += a[i]; for (int i = 2; i \u0026lt;= n; i += 2) B += a[i]; res = max(res, abs(A) - abs(B)); A = 0, B = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (i \u0026lt;= (n + 1) / 2) A += a[i]; else B += a[i]; } long long t1 = abs(A) - abs(B); A = 0, B = 0; reverse(a + 1, a + n + 1); for (int i = 1; i \u0026lt;= n; ++i) { if (i \u0026lt;= (n + 1) / 2) A += a[i]; else B += a[i]; } res = min(max(t1, abs(A) - abs(B)), res); printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } B. 音符 单调队列优化的 dp 效率最高， 或者线段树也行，两版代码都贴一下。\n\\[res = \\max_{i = 1}^{n} \\max_{j \u0026lt; i\\ \\land\\ a_i - a_j \u0026lt;= k}{i - j + 1 + \\max_{k \u0026lt; j\\ \\land \\ a_{j - 1} - a_k \u0026lt;= k}{j - k}}\\]\n一个双指针维护内层 max，一个单调队列维护 \\(\\max_{j \u0026lt; i\\ \\land\\ a_i - a_j \u0026lt;= k}{- j + 1 + \\max_{k \u0026lt; j\\ \\land \\ a_j - a_k \u0026lt;= k}{j - k + 1}}\\)，就可以实现 O(n).\n单调队列代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; const int N = 500010; int a[N], q[N]; long long f[N]; int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } long long res = 0; int pre_max = 0; sort(a + 1, a + n + 1); int hh = 0, tt = -1, t = 0; for (int i = 1, j = 1; i \u0026lt;= n; ++i) { while (hh \u0026lt;= tt \u0026amp;\u0026amp; a[i] - a[q[hh]] \u0026gt; k) hh++; while (j \u0026lt;= i \u0026amp;\u0026amp; a[i] - a[j] \u0026gt; k) j++; if (hh \u0026lt;= tt) res = max(res, i + f[q[hh]]); f[i] = -i + 1 + pre_max; pre_max = max(pre_max, i - j + 1); while (hh \u0026lt;= tt \u0026amp;\u0026amp; f[i] \u0026gt;= f[q[tt]]) tt--; q[++tt] = i; } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } 线段树暴戾代码（离散化疑似反向优化了）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; const int N = 500010; map\u0026lt;int, int\u0026gt; mp; int a[N], b[N]; long long tr[N * 4], f[N][2], s[N]; void pushup(int u) { tr[u] = max(tr[u \u0026lt;\u0026lt; 1], tr[u \u0026lt;\u0026lt; 1 | 1]); } void init(int u, int l, int r) { if (l == r) tr[u] = l == 0 ? 0 : -__LONG_LONG_MAX__; else { int mid = l + r \u0026gt;\u0026gt; 1; init(u \u0026lt;\u0026lt; 1, l, mid), init(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r); pushup(u); } } void modify(int u, int l, int r, int p, int v) { if (l == r) tr[u] = v; else { int mid = l + r \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) modify(u \u0026lt;\u0026lt; 1, l, mid, p, v); else modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, p, v); pushup(u); } } long long query(int u, int l, int r, int ql, int qr) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return tr[u]; else { long long res = -__LONG_LONG_MAX__; int mid = l + r \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) res = max(res, query(u \u0026lt;\u0026lt; 1, l, mid, ql ,qr)); if (qr \u0026gt; mid) res = max(res, query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr)); return res; } } int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); init(1, 0, n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); mp[a[i]]; } int m = 0; for (auto \u0026amp;i : mp) { i.second = ++m; b[m] = i.first; } for (int i = 1; i \u0026lt;= n; ++i) { s[mp[a[i]]]++; } for (int i = 1; i \u0026lt;= m; ++i) s[i] += s[i - 1]; long long res = 0; for (int i = 1; i \u0026lt;= m; ++i) { int l = 0, r = i - 1; while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (b[mid] \u0026lt; b[i] - k) l = mid; else r = mid - 1; } f[i][0] = max(f[i - 1][0], s[i] - s[l]); f[i][1] = s[i] + query(1, 0, n, l, i - 1); modify(1, 0, n, i, -s[i] + f[i][0]); } for (int i = 1; i \u0026lt;= m; ++i) { res = max(res, f[i][1]); } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } 非常反直觉，其实我敲线段树比上面的单调队列快，单调队列比较考验思维，不像我们线段树和二分查找，直接背板子就行了。\nC. 星星点灯 过滤掉所有边权大于 m 的边，然后跑最小生成树，同时统计边权和，最后加上 连通块个数 * m 就是答案。相对比较 easy.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1010; struct edge { int x, y, z; } ed[N * N]; int fa[N]; int getfa(int x) { return x == fa[x] ? x : fa[x] = getfa(fa[x]); } int main() { int val, n, m = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;val, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) fa[i] = i; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); if (i \u0026lt; j) ed[++m] = {i, j, t}; } } sort(ed + 1, ed + m + 1, [](edge a, edge b) { return a.z \u0026lt; b.z; }); long long res = 0; for (int i = 1; i \u0026lt;= m; ++i) { if (ed[i].z \u0026gt; val) break; int x = ed[i].x, y = ed[i].y; x = getfa(x), y = getfa(y); if (x == y) continue; else { fa[y] = x; res += ed[i].z; } } for (int i = 1; i \u0026lt;= n; ++i) if (i == fa[i]) res += val; printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } D. 翘课 类似于分组背包问题，先把每一天单独的旷 \\[0, k\\] 节课的后呆在教学楼的时间算出来，然后跑分组背包dp即可。（理论上可以在维护每天单独的时间的同时做分组背包dp，但是我不知道为什么一直写挂）\nps：说的很简单，但是内部逻辑其实有点绕。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; a[510]; int f[510][510]; int g[510][510]; int main() { int n, m, k; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); if (t) a[i].push_back(j); } } memset(f, 0x3f, sizeof(f)); memset(g, 0x3f, sizeof(g)); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt; a[i].size(); ++j) { // 旷课 j 节 int t = a[i].size() - j; // 上课 t 节 for (int k = t - 1; k \u0026lt; a[i].size(); ++k) { f[i][j] = min(f[i][j], a[i][k] - a[i][k - t + 1] + 1); } } f[i][a[i].size()] = 0; } g[0][0] = 0; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= k; ++j) { for (int l = 0; l \u0026lt;= j; ++l) { g[i][j] = min(g[i][j], g[i - 1][l] + f[i][j - l]); } } } int res = 0x3f3f3f3f; for (int i = 0; i \u0026lt;= k; ++i) { res = min(res, g[n][i]); } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } ","date":"2025-03-11T12:48:31Z","permalink":"https://invalidnamee.github.io/p/2025st5/","title":"2025春训第五场"},{"content":"因为后面有一场校赛，这场训练赛没什么印象了。\nA. 美丽数 先考虑合法情况，从高位到低位从小到大试填。该位填 i 合法当且仅当 i 和上一位不相等且用掉一次 i 之后剩下的状态是合法状态（即个数最大的数的个数不大于 \\(\\lceil \\frac{总数}{2} \\rceil\\)）\n如果填到某一位时，任何 i 都不合法，那么整体就不合法，输出 -1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int cnt[10]; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { vector\u0026lt;int\u0026gt; res; int s = 0; for (int i = 0; i \u0026lt; 10; ++i) { cin \u0026gt;\u0026gt; cnt[i]; s += cnt[i]; } int pre = 0; while (s) { bool flag = false; for (int i = 0; i \u0026lt; 10; ++i) { if (i != pre \u0026amp;\u0026amp; cnt[i]) { int mx = 0; for (int j = 0; j \u0026lt; 10; ++j) { if (i == j) continue; mx = max(mx, cnt[j]); } if (s - 1 - 2 * mx \u0026gt;= -1 \u0026amp;\u0026amp; s - 1 - 2 * (cnt[i] - 1) \u0026gt;= 0) { flag = true; res.push_back(i); s--; cnt[i]--; pre = i; break; } } } if (!flag) break; } if (s) cout \u0026lt;\u0026lt; -1; for (int i : res) cout \u0026lt;\u0026lt; i; cout \u0026lt;\u0026lt; endl; } return 0; } B. 军训 大水题，如果相邻两个位置的数相差不为 1，就需要切割一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; using namespace std; int a[1000010]; int main() { int n, t = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); a[0] = -1; for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); if (a[i] != a[i - 1] + 1 \u0026amp;\u0026amp; a[i] != a[i - 1] - 1) t++; } printf(\u0026#34;%d\\n\u0026#34;, t - 1); return 0; } D. 发工资 经典的贪心问题，把区间按照右端点排序，对于每一个区间，查找区间内最靠左的金砖给他，找不到就跳过。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; pair\u0026lt;int, int\u0026gt; a[1000010]; map\u0026lt;int, int\u0026gt; s; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[i].first, \u0026amp;a[i].second); } for (int i = 1; i \u0026lt;= m; ++i) { int c; scanf(\u0026#34;%d\u0026#34;, \u0026amp;c); s[c]++; } sort(a + 1, a + n + 1, [](pair\u0026lt;int, int\u0026gt; a, pair\u0026lt;int, int\u0026gt; b) { return a.second \u0026lt; b.second; }); int res = 0; for (int i = 1; i \u0026lt;= n; ++i) { auto it = s.lower_bound(a[i].first); if (it != s.end() \u0026amp;\u0026amp; it-\u0026gt;first \u0026lt;= a[i].second) { it-\u0026gt;second--; if (it-\u0026gt;second == 0) s.erase(it); res++; } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } E. 筹备计划 最优解应该是开两个权值线段树，分别维护中位数和合法位置。对于每次查询，查询第一个线段树找到中位数，然后在第二个线段树中查左侧第一个和右侧第一个合法位置，比较两个位置的结果即可；比较时还需要再开一个线段树维护前缀和和后缀和。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010; struct SegmentTree { long long tr[N * 4]; int tag[N * 4]; SegmentTree() { memset(tag, -1, sizeof(tag)); } void pushup(int u) { tr[u] = tr[u \u0026lt;\u0026lt; 1] + tr[u \u0026lt;\u0026lt; 1 | 1]; } void pushdown(int u, int l, int r) { if (~tag[u]) { int mid = l + r \u0026gt;\u0026gt; 1; tag[u \u0026lt;\u0026lt; 1] = tag[u \u0026lt;\u0026lt; 1 | 1] = tag[u]; if (tag[u]) tr[u \u0026lt;\u0026lt; 1] = mid - l + 1, tr[u \u0026lt;\u0026lt; 1 | 1] = r - mid; else tr[u \u0026lt;\u0026lt; 1] = tr[u \u0026lt;\u0026lt; 1 | 1] = 0; tag[u] = -1; } } void modify(int u, int l, int r, int p, long long v) { if (l == r) tr[u] += v; else { pushdown(u, l, r); int mid = l + r \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) modify(u \u0026lt;\u0026lt; 1, l, mid, p, v); else modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, p, v); pushup(u); } } void modify(int u, int l, int r, int ql, int qr, int v) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { if (v) tr[u] = r - l + 1; else tr[u] = 0; tag[u] = v; } else { pushdown(u, l, r); int mid = l + r \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) modify(u \u0026lt;\u0026lt; 1, l, mid, ql, qr, v); if (qr \u0026gt; mid) modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr, v); pushup(u); } } long long query(int u, int l, int r, int ql, int qr) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return tr[u]; else { pushdown(u, l, r); long long res = 0; int mid = l + r \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) res = query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr); if (qr \u0026gt; mid) res += query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr); return res; } } int kth_element(int u, int l, int r, long long k) { if (l == r) return l; else { pushdown(u, l, r); int mid = l + r \u0026gt;\u0026gt; 1; if (tr[u \u0026lt;\u0026lt; 1] \u0026gt;= k) return kth_element(u \u0026lt;\u0026lt; 1, l, mid, k); else return kth_element(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, k - tr[u \u0026lt;\u0026lt; 1]); } } } cnt, pos, sum; int n, q; long long calc(int p) { long long res = 0; if (p \u0026gt; 1) res = (long long)p * cnt.query(1, 1, n, 1, p - 1) - sum.query(1, 1, n, 1, p - 1); if (p \u0026lt; n) res += (long long)(-p) * cnt.query(1, 1, n, p + 1, n) + sum.query(1, 1, n, p + 1, n); return res; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); cnt.modify(1, 1, n, i, t); sum.modify(1, 1, n, i, (long long)t * i); } pos.modify(1, 1, n, 1, n, 1); while (q--) { int t, a, b; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;t, \u0026amp;a, \u0026amp;b); if (t == 1) { cnt.modify(1, 1, n, a, b); sum.modify(1, 1, n, a, (long long)a * b); } else if (t == 2) { cnt.modify(1, 1, n, a, -b); sum.modify(1, 1, n, a, -(long long)a * b); } else if (t == 3) { pos.modify(1, 1, n, a, b, 1); } else { pos.modify(1, 1, n, a, b, 0); } int p = cnt.kth_element(1, 1, n, cnt.query(1, 1, n, 1, n) + 1 \u0026gt;\u0026gt; 1); int pre_cnt = pos.query(1, 1, n, 1, p), l = -1, r = -1; if (pre_cnt) l = pos.kth_element(1, 1, n, pre_cnt); if (pre_cnt \u0026lt; pos.query(1, 1, n, 1, n)) r = pos.kth_element(1, 1, n, pre_cnt + 1); if (~l \u0026amp;\u0026amp; ~r) { if (calc(l) \u0026lt;= calc(r)) printf(\u0026#34;%lld\\n\u0026#34;, l); else printf(\u0026#34;%lld\\n\u0026#34;, r); } else if (~l) printf(\u0026#34;%lld\\n\u0026#34;, l); else if (~r) printf(\u0026#34;%lld\\n\u0026#34;, r); else printf(\u0026#34;-1\\n\u0026#34;); } return 0; } 我当时用的更暴力的两个 log 的做法卡过去了——线段树只打标记，用二分查找找到合法位置，浪费了线段树本身的分治结构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010; long long tr[N], sum[N]; int s[N * 4], lazy[N * 4]; int n, q; inline void pushup(int u) { s[u] = s[u \u0026lt;\u0026lt; 1] + s[u \u0026lt;\u0026lt; 1 | 1]; } inline void pushdown(int u, int l, int r) { if (~lazy[u]) { int mid = l + r \u0026gt;\u0026gt; 1; s[u \u0026lt;\u0026lt; 1] = lazy[u] * (mid - l + 1), s[u \u0026lt;\u0026lt; 1 | 1] = lazy[u] * (r - mid); lazy[u \u0026lt;\u0026lt; 1] = lazy[u \u0026lt;\u0026lt; 1 | 1] = lazy[u]; lazy[u] = -1; } } inline void modify(int u, int l, int r, int ql, int qr, int v) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { s[u] = (r - l + 1) * v; lazy[u] = v; } else { pushdown(u, l, r); int mid = l + r \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) modify(u \u0026lt;\u0026lt; 1, l, mid, ql, qr, v); if (qr \u0026gt; mid) modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr, v); pushup(u); } } inline int smt_query(int u, int l, int r, int ql, int qr) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return s[u]; else { pushdown(u, l, r); int mid = l + r \u0026gt;\u0026gt; 1, res = 0; if (ql \u0026lt;= mid) res = smt_query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr); if (qr \u0026gt; mid) res += smt_query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr); return res; } } inline void add(int u, int k) { int tmp = u; for (; u \u0026lt;= n; u += u \u0026amp; -u) { tr[u] += k; sum[u] += (long long)tmp * k; } } inline long long query(int u) { long long res = 0; for (; u; u -= u \u0026amp; -u) { res += tr[u]; } return res; } inline long long qs(int u) { long long res = 0; for (; u; u -= u \u0026amp; -u) { res += sum[u]; } return res; } inline long long f(int p) { return (long long)p * query(p) * 2 - qs(p) * 2 + qs(n) - (long long)query(n) * p; } void smt_print() { for (int i = 1; i \u0026lt;= n; ++i) { printf(\u0026#34;%d \u0026#34;, smt_query(1, 1, n, i, i)); } printf(\u0026#34;\\n\u0026#34;); } void print() { for (int i = 1; i \u0026lt;= n; ++i) { printf(\u0026#34;%d \u0026#34;, query(i) - query(i - 1)); } printf(\u0026#34;\\n\u0026#34;); for (int i = 1; i \u0026lt;= n; ++i) { printf(\u0026#34;%d \u0026#34;, qs(i) - qs(i - 1)); } printf(\u0026#34;\\n\u0026#34;); } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); add(i, t); } memset(lazy, -1, sizeof(lazy)); while (q--) { int t, a, b; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;t, \u0026amp;a, \u0026amp;b); if (t == 1) { add(a, b); } else if (t == 2) { add(a, -b); } else if (t == 3) { modify(1, 1, n, a, b, 0); } else { modify(1, 1, n, a, b, 1); } int l = 1, r = n; long long s = query(n); while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (query(mid) * 2 \u0026gt;= s) r = mid; else l = mid + 1; } if (smt_query(1, 1, n, l, l) == 0) printf(\u0026#34;%d\\n\u0026#34;, l); else { int L, R; int p = l; l = 0, r = p; while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (smt_query(1, 1, n, mid, p) \u0026lt; p - mid + 1) l = mid; else r = mid - 1; } L = l; l = p, r = n + 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (smt_query(1, 1, n, p, mid) \u0026lt; mid - p + 1) r = mid; else l = mid + 1; } R = l; if (L == 0 \u0026amp;\u0026amp; R == n + 1) printf(\u0026#34;-1\\n\u0026#34;); else if (L == 0) printf(\u0026#34;%d\\n\u0026#34;, R); else if (R == n + 1) printf(\u0026#34;%d\\n\u0026#34;, L); else if (f(L) \u0026lt;= f(R)) printf(\u0026#34;%d\\n\u0026#34;, L); else printf(\u0026#34;%d\\n\u0026#34;, R); } } return 0; } ","date":"2025-03-11T12:47:01Z","permalink":"https://invalidnamee.github.io/p/2025st4/","title":"2025春训第四场"},{"content":"更新记录 本人实力有限，有一些题至今还没做出来，之后会时不时填坑，故把填坑记录加到最上面了，目前还差 I, K, L。\n2025/03/11 更新了 J 题的解法。\n2025/03/16 更新了 J 题解法的解释。\nProblem A. 精准切割 这里提供一种暴力的方法，以左下角为原点，长边为 x 轴，短边为 y 轴建立平面直角坐标系（为保证精度，所有坐标乘 n，因为 n 是分母），暴力尝试主对角线在一列格子左侧和右侧的截距，记为 \\(y_1,y_2\\)记 \\(t = \\lfloor \\frac{y_1}{n} \\rfloor \\times n\\)，如果 \\((y_1 - t) + (y_2 - t) = n\\) 表明切割是对称的，该块被均分。\n我感觉一定有不暴力的办法，欢迎计算几何大佬的新点子。\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int f(int n, int m) { if (n \u0026lt; m) swap(n, m); int res = 0; for (int i = 1; i \u0026lt;= n; ++i) { int t = (i - 1) * m / n * n; if ((i * m - t) + ((i - 1) * m - t) == n) res++; } return res; } int main() { cout \u0026lt;\u0026lt; f(22, 38) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; f(21, 36) \u0026lt;\u0026lt; endl; return 0; } Problem B. 让时间走走停停 这道才是真签到题，下面那道签到题学学啊😭\n记初始状态为 0，平年 +365，闰年 +366，对 7 取模，如果是 0，就是福利年。\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int i, t = 1, cur = 0; for (i = 2001; t \u0026lt; 8; ++i) { cur += 365; if (i % 100 == 0 \u0026amp;\u0026amp; i % 400 == 0 || i % 4 == 0) cur++; cur %= 7; if (cur == 0) t++; } cout \u0026lt;\u0026lt; i - 1 \u0026lt;\u0026lt; endl; return 0; } Problem C. 大力出奇迹 看题目好像就是让暴力的（孩子只会暴力），赛后我在本地跑我的 O(n²) 暴力程序只跑了 4min 19s，思考下一道题的时候挂上暴力，下一道敲完了就跑完了。答案是 809/1001.\n暴力的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } int main() { long long a = 0, b = 1; int n = 111111; for (int i = 2; i \u0026lt;= n; ++i) { int t = 0; for (int j = 2; j \u0026lt;= i; ++j) { if (gcd(i, j) != 1) t++; } if (a * i \u0026lt; t * b) a = t, b = i; printf(\u0026#34;%d tries left\\n\u0026#34;, n - i); } int g = gcd(a, b); a /= g, b /= g; printf(\u0026#34;%lld/%lld\\n\u0026#34;, a, b); return 0; } 有图有真相（第一次跑的时候忘了约分了，但是无伤大雅，运行时间大致是准的）\nProblem D. 时左时右 直接按照题目的要求模拟即可，时间复杂度是 O(nm)，完全够用。维护 ne\n\\[i\\]\\[j\\] 表示当前在第 i 个通道，在第 j 次移动时移动到的下一个点，默认为 i；然后遍历 \\[1, n\\]，分别模拟一遍并记录答案即可。\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; using namespace std; int ne[110][1010], res[110]; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { ne[i][j] = i; } } for (int i = 1; i \u0026lt;= m; ++i) { int t; cin \u0026gt;\u0026gt; t; ne[t][i] = t + 1, ne[t + 1][i] = t; } for (int i = 1; i \u0026lt;= n; ++i) { int t = i; for (int j = 1; j \u0026lt;= m; ++j) t = ne[t][j]; res[t] = i; } for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; endl; return 0; } Problem E. “合作” 从资质最弱的艾比这里考虑很困难，因为不好确定谁会和它合作，谁会攻击它。不妨从资质最强的艾比开始考虑。\n资质最强的艾比一定会活下来，并且持续攻击资质比他弱的艾比；\n考虑资质次强的艾比，为了留下来，它会选择帮助一定数量的艾比防御（这个数量尽可能小），直到这一个区间内的艾比的资质和大于或者等于资质最强的艾比。如此，一个区间内的艾比都能活下来；活下来之后他们会选择尽可能赶走其他艾比，因此会和最强的合作，攻击其他更弱的艾比；\n循环往复，直到剩下的所有艾比合作都无法抵御攻击者，至此攻击者全部留下来，剩下的艾比全部被赶走。\n接下来模拟这个过程即可。\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 500010; int s[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[i]); } sort(s + 1, s + n + 1); long long rs = s[n], ls = 0; int p = n; for (int i = n - 1; i; --i) { ls += s[i]; if (ls \u0026gt;= rs) { rs += ls; ls = 0; p = i; } } printf(\u0026#34;%d\\n\u0026#34;, n - p + 1); return 0; } Problem F. 未完待续 这道题非常的坑人，挖坑挖的非常巧妙，如果题面能加一句“通过旋转可以等价的情况视为多种”就更完善了。\n一般情况 考虑线性dp，记 f\n\\[i\\]\\[0\\] 为第 i 列不放牌的方案个数，f\n\\[i\\]\\[1\\] 为第 i 列放牌的方案个数，显然有\n\\[f_{i, 0} = f_{i - 1, 0} + f_{i - 1, 1}\\]\n\\[f_{i, 1} = 2f_{i - 1, 0}\\]\n这个递推式可以用矩阵加速，构造递推式如下\n\\[\\begin{pmatrix} f_{i - 1, 0} \u0026amp; f_{i - 1, 1} \\end{pmatrix} * \\begin{pmatrix} 1 \u0026amp; 2\\ 1 \u0026amp; 0 \\end{pmatrix} = \\begin{pmatrix} f_{i, 0} \u0026amp; f_{i, 1} \\end{pmatrix}\\]\n初始状态 \\(\\begin{pmatrix} 1 \u0026amp; 0 \\end{pmatrix}\\)，用矩阵快速幂求 \\(\\begin{pmatrix} 1 \u0026amp; 2\\ 1 \u0026amp; 0 \\end{pmatrix}^n\\)，然后相乘，就能得到 \\(\\begin{pmatrix} f_{n, 0} \u0026amp; f_{n, 1} \\end{pmatrix}\\). 这样就得到了 O(log n) 的做法。\n特殊情况 考虑 3 × 3 的情况，因为题目说平行于长度为 3 的边，此时平行于哪条边都是可以的，原来有 11 种情况，顺时针旋转 90°，还有 10 种情况，另外还有以下四种情况，共计 25 种，特判 n = 3 时输出 25 即可。\n1 2 3 **_ __* *__ _** __* __* *__ *__ __* **_ _** *__ 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MOD = 1000000007; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; mul(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; b) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(2, vector\u0026lt;int\u0026gt;(2, 0)); for (int k = 0; k \u0026lt; 2; ++k) { for (int i = 0; i \u0026lt; 2; ++i) { for (int j = 0; j \u0026lt; 2; ++j) { res[i][j] = (res[i][j] + (long long)a[i][k] * b[k][j] % MOD) % MOD; } } } return res; } int solve(unsigned long long p) { if (p == 3) return 25; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res = {{1, 0}, {0, 1}}, base = {{1, 2}, {1, 0}}; while (p) { if (p \u0026amp; 1) res = mul(res, base); base = mul(base, base); p \u0026gt;\u0026gt;= 1; } return (res[0][0] + res[0][1]) % MOD; } int main() { unsigned long long n; // 注意数据范围，别把 long long 爆了 cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; ((solve(n * 2) - solve(n)) % MOD + MOD) % MOD \u0026lt;\u0026lt; endl; return 0; } Problem G. 这里一定发生过什么 XXX，G 题有一份……不，是 26 份提交，没有通过。没错，这就是我\n拼音，不可战胜的。\n豆包写的代码（一遍秒了，我不如豆包😭）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;std::string\u0026gt; pinyinTexts = { \u0026#34;you ren shuo zhao ge ge zhu ban dan wei de yi ju jian jie zai qian mian jia shang you ren shuo zai hou mian jia shang ye you ren ren wei bu jin ru ci ni zen me kan jiu ke yi chu cheng ben ci xiao sai de qian dao ti ye you ren ren wei bu jin ru ci ni zen me kan\u0026#34;, \u0026#34;ACM ju le bu shi gao xin jiu ye ming xiao shen zao de yao lan\u0026#34;, \u0026#34;ji suan ji xue yuan shuang chuang zhong xin lang chao ju le bu zhuan zhu yu pei yang xue sheng chuang xin neng li\u0026#34;, \u0026#34;wu xian dian xie hui ju jiao yu dian zi ji shu yu chuang xin shi jian\u0026#34;, \u0026#34;shu xue jian mo xie hui duo ci bei ping wei you xiu she tuan\u0026#34;, \u0026#34;zen me kan jiu shi wei le zhe dian cu cai bao de zhe dun jiao zi\u0026#34; }; int n; std::cin \u0026gt;\u0026gt; n; if (n \u0026gt;= 1 \u0026amp;\u0026amp; n \u0026lt;= 6) { std::cout \u0026lt;\u0026lt; pinyinTexts[n - 1] \u0026lt;\u0026lt; std::endl; } return 0; } Problem H. 数对 遍历一遍字符串（字符串记为s），开一个数组 vis 记录每一种小写字母上次出现的位置，对于每一个位置 i，遍历 \\(\\text{j} \\in [\\text{\u0026lsquo;a\u0026rsquo;, \u0026lsquo;z\u0026rsquo;}]\\)，IF vis\n\\[j\\] \u0026gt; vis\n\\[i\\] THEN 答案++ 即可。\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int vis[26]; int main() { memset(vis, -1, sizeof(vis)); string s; int res = 0; cin \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt; s.length(); ++i) { for (int j = 0; j \u0026lt; 26; ++j) { if (~vis[j] \u0026amp;\u0026amp; vis[j] \u0026gt; vis[s[i] - \u0026#39;a\u0026#39;]) res++; } vis[s[i] - \u0026#39;a\u0026#39;] = i; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } Problem J. 木板放置 看着无从下手（实际上也无从下手）。\n这题可以用贪心做，具体做法是\n对于合法的情况，做法是先把长度都设成 R，枚举每一个间距优先保证左侧的板子长度为 R，对于不满足要求的间距优先缩短右侧，如果右侧缩到 L，仍然不合法，就继续缩短左侧。\n对于不合法情况，在遍历间距的时候判断间距是否小于 L 即可。\n证明（数学归纳法）：\n显然，n = 1 的时候满足；\n假设 n = k 的时候是最优的，那么在最后面再加一个长度为 R 的木板\n如果放得下，那一定还是最优；\n如果放不下，缩短最后一个木板和缩短第 k 个木板是等价的。\n所以这个做法是可行的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; int a[N], s[N]; int main() { int n, l, r; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;l, \u0026amp;r); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); s[i] = r; } a[0] = -0x3f3f3f3f, a[n + 1] = 0x3f3f3f3f; sort(a + 1, a + n + 1); for (int i = 1; i \u0026lt;= n; ++i) { if (a[i] - a[i - 1] \u0026lt; l) { printf(\u0026#34;-1\\n\u0026#34;); return 0; } else if ((s[i - 1] + l) \u0026lt;= (a[i] - a[i - 1]) * 2) s[i] = min(r, (a[i] - a[i - 1]) * 2 - s[i - 1]); else s[i] = l, s[i - 1] = (a[i] - a[i - 1]) * 2 - l; } int res = 0; for (int i = 1; i \u0026lt;= n; ++i) { res += s[i]; } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } Problem M. 删数 这道题相对正常，比 G 简单 ♾️ 倍。\n简单变换一下，剩下的总和为 m，等价于删除的一段的总和为 \\(\\sum_{i = 1}^{n}{a_i} - m\\)；只需维护一个前缀和数组 s，对于每一次查询，遍历数组，对于每一个位置 i，是否存在 \\(j \\in [0, i]\\), \\(s_i - s_j = s_n - m\\)即可；查询的方法有很多种，我给出的参考代码用的二分查找，也可以用 unordered_set，unordered_map 等 STL 容器维护。\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; long long s[1000010]; int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;s[i]); s[i] += s[i - 1]; } while (q--) { int m; scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); m = s[n] - m; bool f = false; for (int i = 1; i \u0026lt;= n; ++i) { int l = 0, r = i; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (s[mid] \u0026gt;= s[i] - m) r = mid; else l = mid + 1; } if (s[i] - s[l] == m) { f = true; break; } } if (f) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); } return 0; } 获奖感言 观前提醒：胡言乱语，请不要信以为真！！！\n我感谢 G 题的出题人，让我认识到了自己作为中国人应该有点文化素养仍有欠缺；我佩服 J 题的出题人，ta 很会坑人（我明年也一定会向 ta 学习）。小米保温杯很好用，比手环实用多了，这一定是 G 题出题人无意间给我安排好的吧。\n实话说，这次校赛基本上都没对到我的强项上，计算几何，数学题，博弈，汉语拼音正好完美包括了我的弱项。给了数学语文基础好的人很大的发挥空间，对于我这种只会基本的 DP，图论，数据结构的人简直是灾难级的😭，做不动，根本做不动，最后 7 分钟的时候调拼音调得心态彻底崩了。\n","date":"2025-03-10T11:22:06Z","permalink":"https://invalidnamee.github.io/p/upcpc2025/","title":"Upcpc2025"},{"content":"考场上只做出来了 A、C、D、F。我真的敲高精了，而且甚至加法取模都敲了，刚开始 B 有一个样例是错的，带沟里之后回不来了，考完之后被 @xx liu (qwertyuiop) 大佬一句话敲醒了😇。数学题确实有点不好想，当时也是尽力了。\nA. 字符串比对 签到题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { string a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if (a.length() != b.length()) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; else { bool f1 = true, f2 = true; for (int i = 0; i \u0026lt; a.length(); ++i) { if (a[i] != b[i]) f1 = false; if (toupper(a[i]) != toupper(b[i])) f2 = false; } if (f1) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; endl; else if (f2) cout \u0026lt;\u0026lt; 3 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 4 \u0026lt;\u0026lt; endl; } return 0; } B. 数学小店的奇妙兑换 高精度除法 n / (k - 1).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #define int long long using namespace std; vector\u0026lt;int\u0026gt; div(vector\u0026lt;int\u0026gt; a, int b) { vector\u0026lt;int\u0026gt; res(a.size(), 0); long long t = 0; for (int i = a.size() - 1; i \u0026gt;= 0; --i) { t = t * 10 + a[i]; res[i] = t / b; t %= b; } while (res.back() == 0 \u0026amp;\u0026amp; res.size() \u0026gt; 1) res.pop_back(); return res; } signed main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); vector\u0026lt;int\u0026gt; n; string s; int k; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; n.resize(s.length()); for (int i = 0; i \u0026lt; s.length(); ++i) { n[i] = s[s.length() - i - 1] - \u0026#39;0\u0026#39;; } vector\u0026lt;int\u0026gt; res = div(n, k - 1); for (int i = res.size() - 1; i \u0026gt;= 0; --i) { cout \u0026lt;\u0026lt; res[i]; } cout \u0026lt;\u0026lt; endl; return 0; } C. 染色 正向维护很困难，但是反向处理很简单，因为不用考虑这次染色的点会不会被后续的操作改变，给行和列各开一个删除标记，染色之后打上标记，每次操作完之后后续操作的行数或者列数 -1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; struct Query { int op, u, c; }; bool vis[100010][2]; long long cnt[100010]; stack\u0026lt;Query\u0026gt; st; int main() { int n, m, k, q; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k, \u0026amp;q); for (int i = 1; i \u0026lt;= q; ++i) { int op, u, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;op, \u0026amp;u, \u0026amp;c); st.push({op, u, c}); } while (!st.empty()) { auto [op, u, c] = st.top(); st.pop(); if (op == 0) { if (!vis[u][op]) { cnt[c] += n; vis[u][op] = true; m--; } } else { if (!vis[u][op]) { cnt[c] += m; vis[u][op] = true; n--; } } } for (int i = 1; i \u0026lt;= k; ++i) printf(\u0026#34;%lld \u0026#34;, cnt[i]); printf(\u0026#34;\\n\u0026#34;); return 0; } D. 魔法传送门 因为答案乘的倍数就是二进制的位数，可以把每一份答案直接分摊到每个二进制位，开一个状态数组记录当前状态之前的全部状态的每个二进制位提供的方案数总和。遍历到一个状态的时候，先枚举二进制位更新答案，再枚举二进制位用新答案更新状态数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int MOD = 998244353; int a[200010]; long long f[200010], s[30]; int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { memset(s, 0, sizeof(s)); int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); if (i == 1) f[i] = 1; else { f[i] = 0; for (int j = 0; j \u0026lt; 30; ++j) { if (a[i] \u0026gt;\u0026gt; j \u0026amp; 1) f[i] = (f[i] + s[j]) % MOD; } } for (int j = 0; j \u0026lt; 30; ++j) { if (a[i] \u0026gt;\u0026gt; j \u0026amp; 1) s[j] = (s[j] + f[i]) % MOD; } } printf(\u0026#34;%lld\\n\u0026#34;, f[n]); } return 0; } E. 同余方程 (fang) 注意到 a 是连续区间，而 b² 和 c³ 是离散的，可以把 a 捏到 b² 或者 c³ 中；又因为题目要求 a ≤ b ≤ c，把 a 捏到 b² 中更好维护。具体的，需要动态维护一个长度为 k 的数组，记录 a + b² mod k 的每种结果的方案数，在从 1 到 n 枚举 b 的过程中更新每个可能的 c 对应的答案，累加即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; long long tr[1000010]; int n, k; void add(int u, int v) { u++; for (; u \u0026lt;= k; u += u \u0026amp; -u) { tr[u] += v; } } long long query(int u) { u++; long long res = 0; for (; u; u -= u \u0026amp; -u) { res += tr[u]; } return res; } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int t = 1; t \u0026lt;= T; ++t) { memset(tr, 0, sizeof(tr)); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); long long res = 0; for (int i = 1; i \u0026lt;= n; ++i) { long long l = (long long)i * i + 1, r = (long long)i * i + i; add(0, (r - l + 1) / k); r -= (r - l + 1) / k * k; if (l \u0026lt;= r) { l %= k, r %= k; if (l \u0026lt;= r) add(l, 1), add(r + 1, -1); else add(0, 1), add(r + 1, -1), add(l, 1); } res += query((long long)i * i * i % k); } printf(\u0026#34;Case %d: %lld\\n\u0026#34;, t, res); } return 0; } F. 计算器 (monitor) 就是简单的模拟题，写一个 8 的然后复制粘贴，适当删减就可以得到别的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; trans(int n, int t) { vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; res(3 + t * 2, vector\u0026lt;char\u0026gt;(t + 2, \u0026#39; \u0026#39;)); if (n == 0) { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = res[2 + t * 2][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][0] = res[1 + i][t + 1] = res[2 + t + i][0] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else if (n == 1) { for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][t + 1] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else if (n == 2) { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = res[1 + t][i] = res[2 + t * 2][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][t + 1] = res[2 + t + i][0] = \u0026#39;|\u0026#39;; } } else if (n == 3) { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = res[1 + t][i] = res[2 + t * 2][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][t + 1] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else if (n == 4) { for (int i = 1; i \u0026lt;= t; ++i) { res[1 + t][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][0] = res[1 + i][t + 1] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else if (n == 5) { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = res[1 + t][i] = res[2 + t * 2][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][0] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else if (n == 6) { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = res[1 + t][i] = res[2 + t * 2][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][0] = res[2 + t + i][0] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else if (n == 7) { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][t + 1] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else if (n == 8) { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = res[1 + t][i] = res[2 + t * 2][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][0] = res[1 + i][t + 1] = res[2 + t + i][0] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = res[1 + t][i] = res[2 + t * 2][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][0] = res[1 + i][t + 1] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } return res; } void print(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; t) { for (auto i : t) { for (auto j : i) putchar(j); putchar(\u0026#39;\\n\u0026#39;); } } void cat(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;a, vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; b) { for (int i = 0; i \u0026lt; a.size(); ++i) { a[i].push_back(\u0026#39; \u0026#39;); a[i].insert(a[i].end(), b[i].begin(), b[i].end()); } } int main() { int n; char s[10]; while (scanf(\u0026#34;%d%s\u0026#34;, \u0026amp;n, s), n \u0026amp;\u0026amp; s[0] != 0) { auto res = trans(s[0] - 48, n); for (int i = 1; s[i]; ++i) { cat(res, trans(s[i] - 48, n)); } print(res); putchar(\u0026#39;\\n\u0026#39;); } return 0; } ","date":"2025-03-04T11:53:14Z","permalink":"https://invalidnamee.github.io/p/2025st3/","title":"2025春训第三场"},{"content":"考场上只做出来了 A、B、C，拼尽全力无法战胜数学题😭😭😭。\nD 一开始想错了方向，各种分解质因数把自己搞头疼了都，事后暴力莽出来了；E 事后打表打了 20min 以惊人的毅力拿下（别急，还有反转）。\nA. 矩形 把三个矩形的左下角坐标取 max，右上角坐标取 min，就是重叠部分的矩形。\nps：注意判断是否重叠，否则不重叠的可能会负负得正，然后 WA. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); long long x1, y1, x2, y2; long long a1, b1, a2, b2; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; cin \u0026gt;\u0026gt; a1 \u0026gt;\u0026gt; b1 \u0026gt;\u0026gt; a2 \u0026gt;\u0026gt; b2; x1 = max(x1, a1), y1 = max(y1, b1), x2 = min(x2, a2), y2 = min(y2, b2); cin \u0026gt;\u0026gt; a1 \u0026gt;\u0026gt; b1 \u0026gt;\u0026gt; a2 \u0026gt;\u0026gt; b2; x1 = max(x1, a1), y1 = max(y1, b1), x2 = min(x2, a2), y2 = min(y2, b2); if (x2 - x1 \u0026lt;= 0 || y2 - y1 \u0026lt;= 0) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; max(0ll, (x2 - x1) * (y2 - y1)) \u0026lt;\u0026lt; endl; return 0; } 这么水的题还有人用 AI 写，还被抓了😲.\nB. 全球通勤 每条边的 VIP 是相互独立的，直接差分前缀和统计每条边经过的次数，最后遍历一次算出来每条边的最优解加起来即可。\nps：注意 l 可能大于 r，可能需要 swap 一下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 5000010; int a[N], b[N], c[N]; int t[N]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt; n; ++i) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a[i], \u0026amp;b[i], \u0026amp;c[i]); } while (m--) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); if (l \u0026gt; r) swap(l, r); t[l]++, t[r]--; } long long res = 0; for (int i = 1; i \u0026lt; n; ++i) { t[i] += t[i - 1]; res += min(t[i] * a[i], t[i] * c[i] + b[i]); } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } C. 社交网络 不能继续执行操作的情况只有一种，任何一个点所在的连通块都是完全图。所以直接找连通块，统计连通块的点数和边数算出每个连通块的操作次数累加即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 200010; vector\u0026lt;int\u0026gt; ed[N]; int id[N], tot; int cnt[N], ed_cnt[N]; void dfs(int x) { if (id[x]) return; id[x] = tot; cnt[tot]++; for (int y : ed[x]) { dfs(y); } } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 0; i \u0026lt; m; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); ed[x].push_back(y); ed[y].push_back(x); } for (int i = 1; i \u0026lt;= n; ++i) { sort(ed[i].begin(), ed[i].end()); ed[i].erase(unique(ed[i].begin(), ed[i].end()), ed[i].end()); } for (int i = 1; i \u0026lt;= n; ++i) { if (!id[i]) { ++tot; dfs(i); } } for (int i = 1; i \u0026lt;= n; ++i) { ed_cnt[id[i]] += ed[i].size(); } long long res = 0; for (int i = 1; i \u0026lt;= tot; ++i) { res += (long long)cnt[i] * (cnt[i] - 1) / 2 - ed_cnt[i] / 2; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } D. 数数 我的做法有点暴力，但是时间复杂度是没有问题的。\n首先考虑暴力如何解决，直接枚举指数 i in \\[2, 60\\]，底数 j in \\[1, \\\\(n^{\\frac{1}{i}}\\\\)\\]，把所有 \\(j^i\\)去重统计个数。\n不难发现暴力的瓶颈在 \\(\\sqrt{n}\\) 上，如果 i 从 3 开始枚举，那么就不会 TLE，所以干脆直接从 3 枚举，如果 \\(j^i\\)，是平方数就直接忽略，最后一次性加进去一个 \\(\\sqrt n\\) 即可。\nn = 1e18 时时间复杂度是 1e6 级别的， 完全可行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;unordered_set\u0026gt; using namespace std; long long power(long long n, long long p) { long long res = 1, base = n; while (p) { if (p \u0026amp; 1) res = res * base; base = base * base; p \u0026gt;\u0026gt;= 1; } return res; } unordered_set\u0026lt;long long\u0026gt; s; int main() { long long n; cin \u0026gt;\u0026gt; n; for (int i = 60; i \u0026gt;= 3; --i) { for (int j = (long long)pow(n, 1.0 / i); j; --j) { long long t = power(j, i); if (power((int)sqrt(t), 2) != t) s.insert(t); } } cout \u0026lt;\u0026lt; s.size() + (int)(sqrt(n) + 1e-9) \u0026lt;\u0026lt; endl; return 0; } E. 出题 (problem) 我能力不足，找不到选择策略，只能暴搜了😭\n**迭代加深：**因为要求方案字典序最小，所以必须优先搜小的，然而优先搜小的可能会导致递归层数增长过快爆栈或者 TLE，所以用迭代加深一步步试探可行性更高。\n剪枝1: 当前序列最后一位大于 n 时，直接不用搜了。\n剪枝2: 当前序列最后一位的 2^cnt 倍小于 n 时，一定不合法，即使不断翻倍也无法在指定步数内到达 n。（其中cnt = 后续空位数）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int cur[20]; int n; bool dfs(int x, int d) { if (x \u0026gt; d) { if (cur[x - 1] == n) return true; else return false; } if (cur[x - 1] \u0026gt; n || (long long)cur[x - 1] * (1 \u0026lt;\u0026lt; (d - x + 1)) \u0026lt; n) return false; for (int i = 0; i \u0026lt; x; ++i) { for (int j = 0; j \u0026lt;= i; ++j) { if (cur[i] + cur[j] \u0026gt; cur[x - 1]) { cur[x] = cur[i] + cur[j]; if (dfs(x + 1, d)) return true; } } } return false; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int l; cur[0] = 1; for (l = 1; !dfs(1, l); ++l); for (int i = 1; i \u0026lt;= l; ++i) { printf(\u0026#34;%d \u0026#34;, cur[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } WARNINGS 不要用 vector 频繁 push_back 和 pop_back，会严重超时！！！害我打了 20min 表\n注意常数优化，能算一次就不算第二次，否则搜索规模会指数级扩大。\nF. 连续段 (row) 这道题目前 0/0，我量力而为💔\n","date":"2025-03-03T14:32:33Z","permalink":"https://invalidnamee.github.io/p/2025st2/","title":"2025春训第二场"},{"content":"考场上只做出来了 A、B、C、D，而且 C 和 D 做的很煎熬，E 是因为知识的缺失，F 那一条关键的性质不太好想。\nA. 好的序列 签到题，最长上升子序列变体，但是前置状态是固定的，直接开一个标记数组即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int f[100010], a[100010]; int main() { memset(f, -1, sizeof(f)); int n, res = 0; cin \u0026gt;\u0026gt; n; f[0] = 0; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i]; if (f[a[i] - 1] != -1) { f[a[i]] = f[a[i] - 1] + 1; res = max(res, f[a[i]]); } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } B. 一路向上 对于每个点向比他高的点建边，拓扑排序找最长的路径即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 1000010; int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, 1, -1}; int ver[N * 4], head[N], ne[N * 4], deg[N], tot; int a[N], f[N]; void add(int x, int y) { ver[++tot] = y; ne[tot] = head[x]; head[x] = tot; deg[y]++; } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[(i - 1) * m + j]); } } for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { for (int k = 0; k \u0026lt; 4; ++k) { int ti = i + dx[k], tj = j + dy[k]; if (ti \u0026gt; 0 \u0026amp;\u0026amp; ti \u0026lt;= n \u0026amp;\u0026amp; tj \u0026gt; 0 \u0026amp;\u0026amp; tj \u0026lt;= m \u0026amp;\u0026amp; a[(i - 1) * m + j] \u0026lt; a[(ti - 1) * m + tj]) { add((i - 1) * m + j, (ti - 1) * m + tj); } } } } queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n * m; ++i) { if (deg[i] == 0) { f[i] = 1; q.push(i); } } int res = 0; while (!q.empty()) { int x = q.front(); q.pop(); res = max(res, f[x]); for (int i = head[x]; i; i = ne[i]) { int y = ver[i]; f[y] = max(f[y], f[x] + 1); if (--deg[y] == 0) q.push(y); } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } C. 神使 每轮票只可能投到战力值最大的或者最小的，所以按照 \\(a_i\\) 排序，不断比较头和尾的票数进行淘汰，直到剩下最后一个。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; const int N = 1000010; pair\u0026lt;int, int\u0026gt; a[N]; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i].first; a[i].second = i; } sort(a + 1, a + n + 1); int h = 1, t = n; while (h \u0026lt; t) { int m = a[h].first + a[t].first \u0026gt;\u0026gt; 1; int l = h, r = t; while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (a[mid].first \u0026lt;= m) l = mid; else r = mid - 1; } if (l - h + 1 \u0026gt;= t - l) t--; else h++; } cout \u0026lt;\u0026lt; a[h].second \u0026lt;\u0026lt; endl; return 0; } D. 遥远的她 \\((x_1,y_1)\\)和 \\((x_2, y_2)\\) 之间互相可达，当且仅当 \\(||x_1 - x_2| - |y_1 - y_2||\\ %\\ 2 = 0\\).\n把坐标系旋转 45˚（我这里是顺时针旋转的），把单位长度设置成 \\(\\frac{\\sqrt{2}}{2}\\)，每组内按其中一个分量排序，另一个分量用数状数组维护，最后除以2即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010; pair\u0026lt;long long, long long\u0026gt; f[2][N]; int len[2]; long long tr[N]; int cnt[N], m; void add(int u, long long v) { for (; u \u0026lt;= m; u += u \u0026amp; -u) { tr[u] += v; cnt[u]++; } } int qcnt(int u) { int res = 0; for (; u; u -= u \u0026amp; -u) { res += cnt[u]; } return res; } long long query(int u) { long long res = 0; for (; u; u -= u \u0026amp; -u) { res += tr[u]; } return res; } int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; int t = (x \u0026amp; 1) ^ (y \u0026amp; 1); f[t][++len[t]] = {x, y}; } long long s = 0; for (int t = 0; t \u0026lt; 2; ++t) { m = 0; memset(tr, 0, sizeof(tr)); memset(cnt, 0, sizeof(cnt)); map\u0026lt;int, int\u0026gt; mp; for (int i = 1; i \u0026lt;= len[t]; ++i) { f[t][i] = {f[t][i].first - f[t][i].second, f[t][i].first + f[t][i].second}; mp[f[t][i].second]; } sort(f[t] + 1, f[t] + 1 + len[t]); for (auto \u0026amp;i : mp) i.second = ++m; long long ps = 0; for (int i = 1; i \u0026lt;= len[t]; ++i) { int tt = qcnt(mp[f[t][i].second]); s += f[t][i].first * (i - 1) - ps + f[t][i].second * tt - query(mp[f[t][i].second]) * 2 - f[t][i].second * (i - tt - 1) + query(m); ps += f[t][i].first; add(mp[f[t][i].second], f[t][i].second); } } cout \u0026lt;\u0026lt; s / 2 \u0026lt;\u0026lt; endl; return 0; } E. spongebob 这道题是后来补的，显然最后叠加出来的函数是单峰的，用三分求峰值即可。\n需要注意：三分的 rps 应该比题目要求的小，因为最坏的情况有 3e5 个 1e6 倍的 x 叠加。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int N = 300010; int a[N], b[N], n; double sum(double x) { double res = 0; for (int i = 1; i \u0026lt;= n; ++i) { res += fabs(x * a[i] + (double)b[i]); } return res; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[i], \u0026amp;b[i]); } double l = -1e6, r = 1e6; while (r - l \u0026gt; 1e-12) { double mid1 = (l * 2 + r) / 3, mid2 = (l + r * 2) / 3; if (sum(mid1) \u0026gt; sum(mid2)) l = mid1; else r = mid2; } printf(\u0026#34;%lf\\n\u0026#34;, sum((l + r) / 2)); return 0; } F. patrick 每个 h 对应的答案可以用数状数组或者线段树在线维护，我这里用的数状数组。\n考虑每个点和他左侧点的关系，初始化 \\(a_0 = a_{n + 1} = 0\\), 对于每个 \\(i \\in [1, n] \\) , 若 \\(a_i \u0026gt; a_{i - 1}\\)，此时会在 \\(h \\in [a_{i - 1} + 1, a_i]\\) 时额外产生一座岛，所以把区间内的答案 +1。\n需要维护的操作：区间修改，单点查询（可以通过差分数组转化成单点修改，前缀和查询）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 500010; int tr[N], a[N]; void add(int u, int v) { for (; u \u0026lt;= 500000; u += u \u0026amp; -u) { tr[u] += v; } } int query(int u) { int res = 0; for (; u; u -= u \u0026amp; -u) { res += tr[u]; } return res; } int main() { int n, q, last = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); if (a[i] \u0026gt; a[i - 1]) add(a[i - 1] + 1, 1), add(a[i] + 1, -1); } while (q--) { char op[2]; scanf(\u0026#34;%s\u0026#34;, op); if (op[0] == \u0026#39;Q\u0026#39;) { int c; scanf(\u0026#34;%d\u0026#34;, \u0026amp;c); c ^= last; printf(\u0026#34;%d\\n\u0026#34;, last = query(c)); } else { int p, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;p, \u0026amp;v); p ^= last, v ^= last; if (a[p] \u0026gt; a[p - 1]) add(a[p - 1] + 1, -1), add(a[p] + 1, 1); if (a[p + 1] \u0026gt; a[p]) add(a[p] + 1, -1), add(a[p + 1] + 1, 1); a[p] = v; if (a[p] \u0026gt; a[p - 1]) add(a[p - 1] + 1, 1), add(a[p] + 1, -1); if (a[p + 1] \u0026gt; a[p]) add(a[p] + 1, 1), add(a[p + 1] + 1, -1); } } return 0; } ","date":"2025-03-03T04:49:54Z","permalink":"https://invalidnamee.github.io/p/2025st1/","title":"2025春训第一场"},{"content":"应 🐸 的建议，不能光埋头刷题，还应该 水水博客 写写题解，所以后续会时不时更新训练赛和 CSES Problem Set 部分**我会的**题的题解。\n我个人网络预选赛打的还是挺顺利的，虽然榜一差点被抢了。 大部分题都是非常基础的签到题难度的题，主要可能是有的题比较阴间，这种难度应该也不怎么用看代码吧，绝对不是打的时候着急赶时间就没存代码。\nA. ACM 常识问答 这**”常识”**反正我是不知道，用 python 随机了七十多次答案未果。\nB. 割圆术 真正的签到题，只需要注意开 long long，或者用 python 就行。\nC. 大小 签到题，直接 if-else 就行\nD. 子序列 维护前缀和数组s，对每一个位置i，二分查找 0 ~ i - 1 中第一个 ≤ s\n\\[i\\] - k 位置，加起来就是答案，二分可以直接用 upper_bound。\nE. 神秘咒符 签到题，遍历字符串挨个比较就行，\nF. 油专串 略微有点阴间的签到题 (我绝对没有 3 tries)，注意字符串里有空格和不合法的数据，多加一步判断是否整个串都是大写字母即可。\nG. 海人的数学题1 利用差分的思想和容斥原理，设 f(x) = x - (x / div1 + x / div2 - x / 最小公倍数(div1, div2))，答案是 f(number2) - f(number1 - 1) 。\nH. 这是签到题吗 这不是 😭（超大声）\n拼尽全力没有看懂题，看榜二已经开摆了，我也不想看了。\nI. 紊乱的静脉 每次操作都会增加2，所以答案是 min(原来的通畅个数 + 2 * k, n - 1)。\nps : 这道是最后一个写的，所以有代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n, m, t = 0; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; cin \u0026gt;\u0026gt; s; s = \u0026#34; \u0026#34; + s + \u0026#34; \u0026#34;; for (int i = 1; i \u0026lt;= n; ++i) { if (s[i] == \u0026#39;L\u0026#39; \u0026amp;\u0026amp; s[i - 1] == \u0026#39;L\u0026#39;) t++; else if (s[i] == \u0026#39;R\u0026#39; \u0026amp;\u0026amp; s[i + 1] == \u0026#39;R\u0026#39;) t++; } cout \u0026lt;\u0026lt; min(n - 1, t + m * 2) \u0026lt;\u0026lt; endl; return 0; } K. 卡牌游戏 直接 n² 挨个试就行了。\nL. 魔法 如果 R - L + 1 ≥ 2025 那肯定会有一个 i 能让 i mod 2025 取到 0，所以答案是 0；\n否则一共就两千多个数，挨个试就行。\nM. 海人的数学题2 直接暴力就行，先算总和，然后遍历数组，一直 res = min(res, abs((总和 - 前缀和) - 前缀和))。\n","date":"2025-03-02T15:09:48Z","permalink":"https://invalidnamee.github.io/p/5asx6liq5lq65yj5zue5b2s/","title":"失踪人口回归"},{"content":"0.题目描述 题面: 链接\n大致意思是有 \\(B\\) 个方案和 \\(M\\) 个人，每个人可以对 \\(k(k \\le 4)\\) 个方案投票，每一票要么支持要么反对。每个人满意当且仅当他一半以上的投票被满足，问每个方案应通过 ( y ) 还是否决 ( n )，或者既可以通过也可以否决 ( ? )，才能使得每一个人对最终的结果满意。如果不存在一种使得所有人满意的结果，输出 impossible 。\n1.分析 + 代码 对于每一个方案只有通过和否决两种状态，每一个人的投票相当于是限制条件，这道题明显是一个 2-SAT 的问题。\n1.1 建边 将每个方案拆成两个点 true 和 false，分别表示通过和否决，然后考虑限制条件。\n由于 \\(k\\) 的范围很小，我们可以对 \\(k\\) 的取值进行分类讨论。\n\\( k \\le 2\\)\n\\(k = 1\\) 时需满足的票数大于 \\(0.5\\)，即 \\(1\\) ， \\(k = 2\\) 时需满足的票数大于 \\(1\\) ，即 \\(2\\) 。\n所以如果一个人的 \\(k\\) 满足 \\(k \\le 2\\) ，他投的所有票都将得到满足。\n转换到图上就是将相应的方案的相反结果向其投票的结果建一条边，这样投票就必须被满足。\n\\(3 \\le k \\le 4\\)\n\\(k = 3\\) 时需满足的票数大于 \\(1.5\\) ，即 \\(2\\) 或 \\(3\\) ， \\(k = 4\\) 时需满足的票数大于 \\(2\\) ，即 \\(3\\) 或 \\(4\\) 。\n所以如果一个人的 \\(k\\) 满足 \\(3 \\le k \\le 4\\)，他投的票至多有一个得不到满足。也就是说，如果有一票得不到满足，那么其他所有的票就必须全部满足。\n转换到图上就是将每一票的相反的结果向其余所有票的结果分别建一条边。\n为了方便处理各种状态，可以写一个函数导出相应点的下标。\n1 2 3 4 // 1~n 为 false(否决) n + 1 ~ 2n 为 true(通过) int f(bool op, int p) { return p + op * n; // op为标记，通过为true，否决为false } 建边部分代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct Query { bool op; int p; } q[4]; // 存投票情况 bool ed[N][N]; // 邻接矩阵 // ...main... if (k \u0026lt;= 2) { // 全部通过 for (int j = 0; j \u0026lt; k; ++j) { ed[f(!q[j].op, q[j].p)][f(q[j].op, q[j].p)] = true; } } else { // 如果第j个被否决，其余(k - 1)个必须通过 for (int j = 0; j \u0026lt; k; ++j) { for (int l = 0; l \u0026lt; k; ++l) { if (j == l) continue; ed[f(!q[j].op, q[j].p)][f(q[l].op, q[l].p)] = true; } } } 1.2 输出方案 如果只输出一种可行方案，那么很简单，取每个方案的 true 点和 false 点中拓扑序较大的即可。\n一种可行的方案是直接在图上跑一遍 tarjan 求出每个点所在的强连通分量的编号， 输出所在强连通分量的编号较小的即可（ tarjan 得到的编号的顺序是拓扑逆序）。\n但是这道题存在一个 ? 的情况，表示选 true 和 false 均可行，明显上面这个方法无法解决，考虑一下其他思想。\n1.2.1 枚举 可以考虑先跑一遍 tarjan 得到一组可行解然后依次验证每一个方案是否可以取反，如果可以就改成 ? ，大致流程如下：\n跑一遍 tarjan 得到一组可行解。 遍历可行解的每一个位置。 对于每一个位置，临时建一条反向的边，限制该位置必须选相反的结果。 再跑一遍 tarjan，验证是否仍然可行。 如果可行，改为 ? ， 否则不变。 删掉临时边，继续尝试下一个位置。 跑完一轮后，就可以得到答案，时间复杂度是 \\(O(n ^ 3)\\)(邻接矩阵)。\n参考代码\n1.2.2 传递闭包（Floyd求图的连通性） 进一步思考，设一个下标为 \\(p\\) 方案 true 点为 \\(p + n\\) ，false 点为 \\(p\\) 。\n若 \\(p\\) 能走到 \\(p + n\\) 且 \\(p + n\\) 不能走到 \\(p\\) ，那么这个方案只能为 true 。 若 \\(p + n\\) 能走到 \\(p\\) 且 \\(p\\) 不能走到 \\(p + n\\) ，那么这个方案只能为 false 。 若 \\(p\\) 不能走到 \\(p + n\\) 且 \\(p + n\\) 不能走到 \\(p\\) ，那么这个方案可以为 true 也可以为 false ，即题中 ? 。 若 \\(p\\) 能走到 \\(p + n\\) 且 \\(p + n\\) 能走到 \\(p\\) ，那么这个方案既不可以为 true 也不可以为 false ，即 impossible 。 所以直接对建好的图跑一遍传递闭包即可，时间复杂度也是 \\(O(n ^ 3)\\) ，但由于不能快速判断是否可行，所以整体速度比 tarjan 慢很多，但是代码短呀。\n1 2 3 4 5 6 7 8 for (int k = 1; k \u0026lt;= n * 2; ++k) { for (int i = 1; i \u0026lt;= n * 2; ++i) { for (int j = 1; j \u0026lt;= n * 2; ++j) { if (i == j) continue; else ed[i][j] |= ed[i][k] \u0026amp; ed[k][j]; // i与k连通且k与j连通则i与j连通 } } } Ac Code 传递闭包只有 82 行，很清爽。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 210; struct Query { bool op; // true为通过, false为否决 int p; // 相应方案的下标 } q[4]; // 存投票情况 bool ed[N][N]; // 邻接矩阵 char ans[N]; // 存答案 int n, m; // 1~n 为 false(否决) n + 1 ~ 2n 为 true(通过) int f(bool op, int p) { return p + op * n; // op为标记，通过为true，否决为false } int main() { int T = 0; while (scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m), n \u0026amp;\u0026amp; m) { T++; // 记得初始化 memset(ed, 0, sizeof(ed)); memset(ans, 0, sizeof(ans)); for (int i = 1; i \u0026lt;= m; ++i) { int k; scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); for (int j = 0; j \u0026lt; k; ++j) { char s[2]; scanf(\u0026#34;%d%s\u0026#34;, \u0026amp;q[j].p, s); q[j].op = (s[0] == \u0026#39;y\u0026#39;); } if (k \u0026lt;= 2) { // 全部通过 for (int j = 0; j \u0026lt; k; ++j) { ed[f(!q[j].op, q[j].p)][f(q[j].op, q[j].p)] = true; } } else { // 如果第j个被否决，其余(k - 1)个必须通过 for (int j = 0; j \u0026lt; k; ++j) { for (int l = 0; l \u0026lt; k; ++l) { if (j == l) continue; ed[f(!q[j].op, q[j].p)][f(q[l].op, q[l].p)] = true; } } } } // 传递闭包 for (int k = 1; k \u0026lt;= n * 2; ++k) { for (int i = 1; i \u0026lt;= n * 2; ++i) { for (int j = 1; j \u0026lt;= n * 2; ++j) { if (i == j) continue; else ed[i][j] |= ed[i][k] \u0026amp; ed[k][j]; } } } bool valid = true; for (int i = 1; i \u0026lt;= n; ++i) { if (ed[i][i + n] \u0026amp;\u0026amp; ed[i + n][i]) { // impossible valid = false; break; } else if (!ed[i][i + n] \u0026amp;\u0026amp; !ed[i + n][i]) ans[i] = \u0026#39;?\u0026#39;; else if (ed[i][i + n]) ans[i] = \u0026#39;y\u0026#39;; else ans[i] = \u0026#39;n\u0026#39;; } printf(\u0026#34;Case %d: \u0026#34;, T); // 某憨憨由于没输出Case调了半天 if (valid) for (int i = 1; i \u0026lt;= n; ++i) { putchar(ans[i]); } else printf(\u0026#34;impossible\u0026#34;); printf(\u0026#34;\\n\u0026#34;); } return 0; } ","date":"2022-09-19T12:05:49Z","permalink":"https://invalidnamee.github.io/p/uva1086-the-ministers-major-mess/","title":"UVA1086 The Ministers' Major Mess"},{"content":" 前排感谢脚本开发者软件小妹，给了我们白嫖的机会\nTempermonkey 先弄油猴脚本，去浏览器的扩展程序商店安装 Tempermonkey (我已经装了，所以是删除)，注意 chrome 的商店需要科学上网\n安装这个脚本 百度网盘简易下载助手（直链下载复活版） (greasyfork.org)\n脚本就解决了\nIDM 建议支持正版。\n配置 打开 IDM，打开选项\n把 UA 改成 netdisk;3.0.0.112\n使用 先把东西存到自己的网盘里，然后选择要下载的文件，点简易下载助手，这里以vmware为例\n点击获取直链地址，有时候需要验证码，关注一下公众号即可\nIDM选择新建任务，把链接粘贴进去即可\nlinux用户和mac用户可以用Aria2，linux可以用aria-ng-gui，mac可以用Aria2GUI，下载的时候按发送到Aria2即可。\n","date":"2022-08-30T09:14:00Z","permalink":"https://invalidnamee.github.io/p/55m5bqm572r55uy5lin6zmq6ycf/","title":"百度网盘不限速"},{"content":" 这个比默认的 ibus 好用很多，两个输入法可能有排斥，如果安装过程中报错，可以试试把 ibus 卸了\n1 sudo apt purge ibus 官网 : https://shurufa.sogou.com/linux\n然后可以按照官网的教程弄\n不想看的可以看我的\n先换个中国的源 (可以让下载安装的命令更快一点)\n1 sudo gedit /etc/apt/sources.list 全部删掉换成华为的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 # deb cdrom:[Ubuntu 20.04.1 LTS _Focal Fossa_ - Release amd64 (20200731)]/ focal main restricted # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal main restricted # deb-src http://us.archive.ubuntu.com/ubuntu/ focal main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal-updates main restricted # deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team. Also, please note that software in universe WILL NOT receive any ## review or updates from the Ubuntu security team. deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal universe # deb-src http://us.archive.ubuntu.com/ubuntu/ focal universe deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal-updates universe # deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates universe ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## multiverse WILL NOT receive any review or updates from the Ubuntu ## security team. deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal multiverse # deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal-updates multiverse # deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse ## N.B. software from this repository may not have been tested as ## extensively as that contained in the main release, although it includes ## newer versions of some applications which may provide useful features. ## Also, please note that software in backports WILL NOT receive any review ## or updates from the Ubuntu security team. deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal-backports main restricted universe multiverse # deb-src http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse ## Uncomment the following two lines to add software from Canonical\u0026#39;s ## \u0026#39;partner\u0026#39; repository. ## This software is not part of Ubuntu, but is offered by Canonical and the ## respective vendors as a service to Ubuntu users. # deb http://archive.canonical.com/ubuntu focal partner # deb-src http://archive.canonical.com/ubuntu focal partner deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal-security main restricted # deb-src http://security.ubuntu.com/ubuntu focal-security main restricted deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal-security universe # deb-src http://security.ubuntu.com/ubuntu focal-security universe deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal-security multiverse # deb-src http://security.ubuntu.com/ubuntu focal-security multiverse # This system was installed using small removable media # (e.g. netinst, live or single CD). The matching \u0026#34;deb cdrom\u0026#34; # entries were disabled at the end of the installation process. # For information about how to configure apt package sources, # see the sources.list(5) manual. 然后\n1 sudo apt update 装 fcitx\n1 sudo apt install fcitx 配置一下 fcitx\n找到 language support (语言支持)\n把输入法改成 fcitx\n注销一次\n安装搜狗输入法的包\n1 2 3 4 5 6 # 进入下载包的目录，默认是在~/Downloads cd ~/Downloads # 如果是英文系统 cd ~/下载 # 如果是中文系统 # 安装 sudo dpkg -i sogoupinyin_4.0.1.2800_x86_64.deb # 输入一个sogou然后tab一下就出来了，版本号可能不一样请勿复制 安装依赖\n1 2 sudo apt install libqt5qml5 libqt5quick5 libqt5quickwidgets5 qml-module-qtquick2 sudo apt install libgsettings-qt1 启用\n打开 fcitx 的设置\n如果没有 sogoupinyin 的话就点坐下角的加号搜索 sogoupinyin 加上就可以了\n如果无论如何都没有，建议注销一次再试\nFinished\n可以 Ctrl + Space 切换输入法\n","date":"2022-08-30T08:53:49Z","permalink":"https://invalidnamee.github.io/p/for-linux/","title":"搜狗输入法 for Linux"},{"content":"0.前置说明 WSL是什么，以下定义来自百度百科\nWindows Subsystem for Linux（简称WSL）是一个在Windows 10上能够运行原生Linux二进制可执行文件与Canonical公司合作开发，其目标是使纯正的Ubuntu、Debian等映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。\n1.折腾缘由 众所周知，上周有一道图论题在win上跑就RE，到linux上跑就可正常运行，导致我调了半天感觉自己没问题但是搜索数据就是爆，气急败坏，直接交了一份然后\u0026hellip; 竟然A了，我立刻重启去我的linux里跑了一遍，确实没问题，于是我又请yzy在他的电脑上跑了一遍，发现也炸了。\n后来听Laffey解释之后才知道，因为win的系统栈默认好像只有 1MB，数据太大直接把站爆了，然而linux就没事。由于诸多原因，日常的使用并离不开windows，我又没法每次都去linux跑代码，于是我就想了个办法，装个linux子系统，用子系统跑代码 (刚好VScode是微软自己家的，所以配置地很简单) 。\n2.目的 在win11(10)上安装WSL\\(Ubuntu22.04\\)并在vscode中使用linux子系统跑代码。(低于win10的可以选择自行更新或放弃)\n3.开始整活 3.1安装 打开 Microsoft Store ，搜索Ubuntu，并安装 (经常卡顿，请耐心等待) 开启相关服务 搜索windows 功能，并打开\n打开以下两项\n按要求重启一次，安装相关服务\n在开始菜单打开 Ubuntu 22.04，发现报错 (我当时忘了截图了) 解决方案： 手动安装WSL新内核：WSL2 Linux kernel update package for x64 machines\n再次打开Ubuntu 22.04 然后发现可以了 等待一段时间后输入你之后要给linux系统用的用户名和密码，就可以进去了，会看到一个这样的界面，表明成功了（怎么给我报了条错，咳咳\u0026hellip;不用管，ubuntu经常这样）。\n3.2 配置 VScode 在拓展程序搜索wsl，安装第一个\n3.2 配置 linux 用过Debian系的linux的人都知道apt(包管理器）的相关操作，不知道也没事，只需要知道这玩意能装软件和卸软件就行了\n更新源和软件，防止出事 1 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade 然后输入自己的密码，和windows一个道理，linux装软件也需要管理员权限\n注意： 你输入的密码不显示但是输进去了\n然后等待一段时间，默认的源有点慢，有能力的可以选择先去换源，然后在更新，由于系统没有图形界面，所以有点麻烦，多等会儿就好了。\n换源(可以不做)：\n1 sudo nano /etc/apt/sources.list 然后把里面的内容替换成tuna的(清华源)\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse 然后 ctrl + X退出，选择 Y，然后按 enter\n再更新一次源\n1 sudo apt update 安装gcc和g++(C语言和C++的编译器) 1 sudo apt install gcc g++ 安装 VScode 支持 1 code . 等他跑完，就会弹出一个 VScode窗口，所下角是这样的\n说明已经连上了子系统\n3.4 配置linux子系统的VScode拓展程序 需要装两个拓展程序\n如果已经装过了就选\ncode runner 配置\n前言: 不是刚需但是很方便的运行代码的工具，自我感觉比 [@Laffey](Laffey — Hashnode) 的那个好。\n使用: 装上去之后新建一个 .cpp文件打开后会发现右上角有一个运行按钮，点一下就会编译运行(快捷键 ctrl + alt + N)，缺点是不能调试，因为他是通过终端命令运行的。\n优化: 有时候我们可能会创建一个名称有空格的代码文件，用code runner编译就会报错，因为空格影响了命令的执行，我们可以通过更改运行命令来解决\n打开设置\n切换到 ubuntu 22.04 的标签下，搜 code runner，然后按图示操作，点击 Execulor Map 下的 Edit in settings.json\n把 cpp 那一行改成这个\n1 \u0026#34;cpp\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; g++ \u0026#39;$fileName\u0026#39; -o tmp \u0026amp;\u0026amp; ./tmp\u0026#34;, 之后在编译的时候就会在改目录下生成一个名为 tmp 的可执行文件\n如果有需要编译 .c 文件就把 c 哪一行改成这个\n1 \u0026#34;c\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; gcc \u0026#39;$fileName\u0026#39; -o tmp \u0026amp;\u0026amp; ./tmp\u0026#34;, 这样就解决了\n4.一些小知识 命令(应该是个OIer就会吧) 1 2 3 4 5 6 7 8 cd dir # 进入到名为dir的文件夹，也可以是绝对路径 cd .. # 返回上级目录 cd # 回到home，相当于是windows的users文件夹，储存用户文件 mkdir dir # 在当前目录下建一个名为dir的文件夹 touch abc # 在当前目录下建一个名叫abc的文件，可以加后缀名 如：abc.cpp sudo apt install xxx # 从软件源里安装xxx软件，软件源里不一定有。。。 sudo apt purge xxx # 卸载xxx软件 sudo dpkg -i xxx.deb # 从本地安装软件，ubuntu的包格式为deb 这些应该差不多够用了，其实有什么问题直接百度肯定有答案\n好像把文件拷到linux里面运行更快，linux的文件在这里 进去之后是根目录，我们的用户文件在home里\n如果出了问题就去百度，不行就去国际版的bing用英文搜，再不行就科学上网去google 5.终于写完了 如果有什么错误欢迎指正，虽然可能会特别冷没人看，我相信一定有喜欢折腾的人，比如我\n","date":"2022-08-30T08:53:39Z","permalink":"https://invalidnamee.github.io/p/wslvscode/","title":"安装WSL并在VScode调用"},{"content":"0.题目描述 题面:P3956 [NOIP2017 普及组] 棋盘\n有一个\\(m \\times m\\)的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。\n任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、 下、左、 右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 \\(1\\) 个金币。\n你可以花费 \\(2\\) 个金币将一个无色格子暂时变成指定的颜色，但是在到达一个原本就有颜色的格子前不能再次使用，离开该格子后颜色恢复。\n求最少花费的金币数。\n本来的描述就挺简洁的，所以大部分引用的原题的描述\n1. 心路历程 本来我看到这个格子，还是从左上角到右下角，直接满脑子都是 dp，然后写了一大堆只有 \\(50\\) 分，然后才发现他不一定要按拓扑序走才是最短的，所以正解是搜索(最短路)，然后搜索写了四个版本，最后发现第一个(最暴力的那个)思路是对的，毕竟数据只有 \\(100*100\\)。\n2. 解析 2.1 前言 那个 dp 的错误思想就不多说了，这个思路只能应付部分按照拓扑序走的情况。 因为正解就是暴力，暴力就是正解，所以这个题的代码量不算太小，而且需要头脑清醒 2.2 思路 把能走的路全部建一条边，边权是走过去消耗的金币数，然后对生成的图跑 Dijkstra。\n简单的一句话，但是实现起来缺不太容易\n2.3 实现 点如何编号\n如图，把每一行都接上，顺着编号。\n从坐标对应到编号的函数:\n1 2 3 int tonum(const int \u0026amp;x, const int \u0026amp;y) { return n * (x - 1) + y; } 从编号对应到坐标的函数:\n1 2 3 pair\u0026lt;int, int\u0026gt; tosite(const int \u0026amp;x) { return {ceil((double)x / n), x % n == 0 ? n : x % n}; } **建边逻辑 **(强烈建议单独写一个函数)\n以样例为例 ，看上面的图\n设入点为 \\(x\\)，出点为 \\(y\\)。\n颜色(\\(C\\)) : \\(-1\\) 为无色， \\(0\\) 为红色，\\(1\\) 为黄色。\n\\(c_x=-1\\) 且 \\(c_y=-1\\) 由于不能连续施展魔法所以不能走，不建边 \\(eg.\\) \\(3\\) 和 \\(4\\) \\(c_x \\neq -1\\) 且 \\(c_y=-1\\) 可以消耗两个金币施展魔法将 \\(c_y\\) 变成 \\(c_x\\)，建边，边权为 \\(2\\)。 \\(eg.\\) \\(2\\) 和 \\(3\\) \\(c_x=-1\\) 且 \\(c_y\\neq-1\\) 如果能走，则 \\(x\\) 已经被施展魔法，颜色取决于给 \\(x\\) 施展魔法的点，建边，边权为 \\(-1\\) ，在求最短路时特判。 \\(eg.\\) \\(8\\) 和 \\(13\\) \\(c_x\\neq-1\\) 且 \\(c_y\\neq-1\\) \\(c_x=c_y\\) 可以直接走，建边，边权为 \\(0\\)。 \\(eg.\\) \\(1\\) 和 \\(2\\) \\(c_x\\neq c_y\\) 可以消耗一个金币走，建边，边权为 \\(0\\)。 \\(eg.\\) \\(2\\) 和 \\(7\\) Dijkstra\n大部分套模板就行，需要特判一下建边的情况 3，在队列的参数里面加一项，记录父节点，当搜到一个边权为 \\(-1\\) 的边时对比它和它的隔代祖先节点的颜色，决定将\\( -1\\) 改成是 \\(0\\) 还是 \\(1\\) ，相当于是转化成了建边的情况 4。\n3.总结 这个看似简单的暴力题细节特别多，不要太小看他了，一定要保持清醒\nAc Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;int, pii\u0026gt; piii; const int N = 110; const int M = 40010; int c[N][N]; // 记录颜色 int nxt[M], ver[M], w[M], head[M]; // 存图 int tot; int n, m; void add(int x, int y, int e) { ver[++tot] = y; w[tot] = e; nxt[tot] = head[x]; head[x] = tot; } int tonum(const int \u0026amp;x, const int \u0026amp;y) { // 坐标转到序号 return n * (x - 1) + y; } pair\u0026lt;int, int\u0026gt; tosite(const int \u0026amp;x) { // 序号转到坐标 // 这里要注意，稍不留神就错了，主要是取模的问题，本来是5的会被模成0，注意特判 return {ceil((double)x / n), x % n == 0 ? n : x % n}; } int tocol(const int \u0026amp;x) { // 序号转到颜色 return c[tosite(x).first][tosite(x).second]; } bool judge(const int \u0026amp;x, const int \u0026amp;y) { // 判断是否出界 return x \u0026gt; 0 \u0026amp;\u0026amp; x \u0026lt;= n \u0026amp;\u0026amp; y \u0026gt; 0 \u0026amp;\u0026amp; y \u0026lt;= n; } void build(const int \u0026amp;a, const int \u0026amp;b, const int \u0026amp;x, const int \u0026amp;y) { // 难点:建边 if (c[a][b] == -1 \u0026amp;\u0026amp; c[x][y] == -1) return; // 两个没有颜色，只能变一个，所以不能走 else if (c[x][y] == -1) add(tonum(a, b), tonum(x, y), 2); // 有 -\u0026gt; 无 消耗2个金币 else if (c[a][b] == -1) add(tonum(a, b), tonum(x, y), -1); // 无 -\u0026gt; 有 视情况而定，先弄成-1到时候再判断 else if (c[a][b] == c[x][y]) add(tonum(a, b), tonum(x, y), 0); // 颜色相同，消耗0个金币 else add(tonum(a, b), tonum(x, y), 1); // 颜色不同，消耗1个金币 } int dijkstra(const int \u0026amp;s, const int \u0026amp;t) { priority_queue\u0026lt;piii, vector\u0026lt;piii\u0026gt;, greater\u0026lt;piii\u0026gt; \u0026gt; q; // pair\u0026lt;距离, \u0026lt;编号，父节点\u0026gt; \u0026gt; int d[M]; bool v[M]; memset(d, 0x3f, sizeof(d)); memset(v, 0, sizeof(v)); d[s] = 0; q.push({0, {s, 0}}); while (!q.empty()) { int x = q.top().second.first; int fa = q.top().second.second; q.pop(); if (v[x]) continue; v[x] = 1; for (int i = head[x]; i; i = nxt[i]) { int \u0026amp;y = ver[i]; int t = w[i]; // 之前特殊标记的，y与x的父节点(y的隔代祖先)颜色相同则消耗0个，不同则消耗1个 // 默认把没颜色的节点标记成其父节点的颜色，方便统计 if (w[i] == -1) { if (tocol(fa) != tocol(y)) { t = 1; } else t = 0; } // 正常的dijkstra的状态转移 if (d[y] \u0026gt; d[x] + t) { d[y] = d[x] + t; q.push({d[y], {y, x}}); } } } return d[t] == 0x3f3f3f3f ? -1 : d[t]; // 注意特判不能到达的情况 } int main() { memset(c, -1, sizeof(c)); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; ++i) { int x, y, z; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); c[x][y] = z; } for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { // 建边，注意判断有没出界 if (judge(i + 1, j)) build(i, j, i + 1, j); if (judge(i, j + 1)) build(i, j, i, j + 1); if (judge(i - 1, j)) build(i, j, i - 1, j); if (judge(i, j - 1)) build(i, j, i, j - 1); } } printf(\u0026#34;%d\\n\u0026#34;, dijkstra(1, tonum(n, n))); return 0; } ","date":"2022-08-30T08:37:16Z","permalink":"https://invalidnamee.github.io/p/noip-2017/","title":"[noip 2017 普及组] 棋盘"},{"content":"0.题目描述 题面:P2680 [NOIP2015 提高组] 运输计划 在一棵树中，将任意一条边的边权改为0 (以下称“删边”) ，使得所有询问中两个点之间距离的最大值最小(消耗的时间最少)\n1.心路历程 描述很简单，也很容易抽象成一棵树，但是如何实现是个大问题，而且这道题数据范围很大， 0(n^2) 的算法肯定会被卡掉，所以一下子想出正解就很难，可以先从暴力的做法出发，可以拿 50 分，然后再去想正解。\n我当时是写完暴力后想不出正解，去看了别人的题解才茅塞顿开。。。\n2.暴力做法 2.1 暴力思路 非常简单，依次把每条边的边权都改成 0 试一遍，找最小的答案即可。\n2.2 暴力障碍 快速求树上两点的距离\n这个可以通过在树上维护前缀和实现，维护每个点到根节点的距离d，x 和 y 的距离 dis[x,y]=d[x]+d[y]-2*lca[x,y] (1号点到 x 的距离加上 1 号点到 y 的距离减去多算两次的 lca[x,y] 到 1号点的距离即可)\n建立点和边的关系\n把边权下放到出点上，在一棵树上以同一个点为出点的边只有一个，可以通过穷举点来穷举边，“删除”一条边时，只需遍历到这条边的出点时不计算当前边的权值即可。\n不会背 lca\n​\t那你做个紫题干什么？\n​\n2.4 暴力代码 时间复杂度为 O(n^2) ，只能过一半的数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 300010; struct Node{ // lca，起点，终点 int fa, x, y; // 预处理好lca不然每次都重算一次时间复杂度就上去了 }query[N]; int nxt[N * 2], w[N * 2], ver[N * 2], head[N]; // 链式前向星 int d[N]; // 所有点到1号点的距离 int tot; int f[N][20], dep[N]; // 树上倍增求lca int len; void add(int x, int y, int e) { ver[++tot] = y; w[tot] = e; nxt[tot] = head[x]; head[x] = tot; } void init(int x) { for (int i = 1; i \u0026lt;= 18; ++i) { f[x][i] = f[f[x][i - 1]][i - 1]; } for (int i = head[x]; i; i = nxt[i]) { int y = ver[i], e = w[i]; if (y == f[x][0]) continue; // 防止回搜 dep[y] = dep[x] + 1; f[y][0] = x; init(y); } } int lca(int x, int y) { if (dep[x] \u0026gt; dep[y]) swap(x, y); for (int i = 18; i \u0026gt;= 0; --i) { if (dep[f[y][i]] \u0026gt;= dep[x]) y = f[y][i]; } if (x == y) return x; for (int i = 18; i \u0026gt;= 0; --i) { if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; } return f[x][0]; } void dfs(int x, int pos) { for (int i = head[x]; i; i = nxt[i]) { int y = ver[i], e = w[i]; if (y == f[x][0]) continue; if (y == pos) d[y] = d[x]; // pos点的入边的边权视为0 else d[y] = d[x] + e; dfs(y, pos); } } int main() { int n, m; int res = 0x3f3f3f3f; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt; n; ++i) { int x, y, e; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;e); add(x, y, e), add(y, x, e); } dep[1] = 1; init(1); for (int i = 1; i \u0026lt;= m; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); query[++len] = {lca(x, y), x, y}; // 提前维护好lca，否则TLE } for (int pos = 2; pos \u0026lt;= n; ++pos) { // 穷举“删掉”的边，1号点(根节点)没有入边 memset(d, 0, sizeof(d)); // 每次重算距离 dfs(1, pos); int maxn = 0; for (int i = 1; i \u0026lt;= len; ++i) { int x = query[i].x, y = query[i].y, fa = query[i].fa; int dis = d[x] + d[y] - 2 * d[fa]; // 两点的距离 maxn = max(maxn, dis); // 耗时最大的一组的时间为消耗的时间 } res = min(res, maxn); } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } 3.正解 3.1 思路 仔细观察这道题，可以发现答案是单调的：当答案过大的时候不用“删边”，当答案过小的时候删一条边不能满足条件，因此可以用二分答案的思路做这道题。\n3.2 难点 代码量挺大，做好心理准备\n判断函数的设计\n如何检验目前的 mid 是否合法是这道题的最大的难点\n做法是在“删边”前将所有询问中长度大于 mid 的路径筛出来，然后找出所有长度大于 mid 的边经过的路径中最大的一条边，检验最长的路径减去最大边后是否大于 mid。\n如果大于 mid ，表明还需要删更多的边才能满足要求或不能满足要求，mid 取小了\n如果小于或等于 mid ，表明“删边”后状态合法或不需要删边，mid 取大了(此时 mid 可能是答案)\n判断函数的实现\n遍历每组询问，统计大于 mid 的路径条数 cnt，并记录最长路径 maxn。\n判断一条边是否被所有长度大于 mid 的路径经过。 （难点）\n统计每条边被长度大于 mid 的路径经过的次数 s[i]，如果 s[i]=cnt，表明这条边被所有长度大于 mid 的路径经过。s 数组可以通过树上差分实现 ( 边权差分 )，时间复杂度为 O(m+n)。\n遍历所有的边 w[i]，判断 maxn-w[i] 与 mid 的关系。\n4.提醒 再次提醒，提前维护好 lca，否则时间复杂度会退化，导致 TLE。\n还是，看懂了就自己先写，写不动了再来看代码\nAc Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 300010; struct Node{ int fa, x, y; }query[N]; int nxt[N * 2], w[N * 2], ver[N * 2], head[N]; int d[N], s[N], w_ver[N]; /** * d[N]为到1号点的距离 * s[N]为差分数组 * w_ver[N]为每个点入边的边权 */ int tot, n, m; int f[N][21], dep[N]; void add(int x, int y, int e) { ver[++tot] = y; w[tot] = e; nxt[tot] = head[x]; head[x] = tot; } void init(int x) { for (int i = 1; i \u0026lt;= 20; ++i) { f[x][i] = f[f[x][i - 1]][i - 1]; } for (int i = head[x]; i; i = nxt[i]) { const int \u0026amp;y = ver[i], \u0026amp;e = w[i]; if (y == f[x][0]) continue; dep[y] = dep[x] + 1; f[y][0] = x; d[y] = d[x] + e; // 维护距离 w_ver[y] = e; // 维护入边的边权 init(y); } } int lca(int x, int y) { if (dep[x] \u0026gt; dep[y]) swap(x, y); for (int i = 20; i \u0026gt;= 0; --i) { if (dep[f[y][i]] \u0026gt;= dep[x]) y = f[y][i]; } if (x == y) return x; for (int i = 20; i \u0026gt;= 0; --i) { if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; } return f[x][0]; } void dfs(int x) { // 对差分数组进行前缀和运算，求出每条边被经过的次数 for (int i = head[x]; i; i = nxt[i]) { const int \u0026amp;y = ver[i]; if (y == f[x][0]) continue; dfs(y); s[x] += s[y]; } } bool judge(int mid) { memset(s, 0, sizeof(s)); // 每次初始化差分数组 int maxn = 0, cnt = 0; // maxn为最大路径长度，cnt为长度大于mid的路径条数 for (int i = 1; i \u0026lt;= m; ++i) { int x = query[i].x, y = query[i].y, fa = query[i].fa; int dis = d[x] + d[y] - 2 * d[fa]; if (dis \u0026gt; mid) { maxn = max(dis, maxn); ++s[x], ++s[y]; s[fa] -= 2; ++cnt; } } if (!maxn) return true; // 不用删边，说明mid取大了，直接往左找，如果不优化会TLE一个点 dfs(1); for (int i = 1; i \u0026lt;= n; ++i) { // 最长路径减去最长边小于mid，状态合法，此mid和更小的mid都可能是答案，向左找 if (s[i] == cnt \u0026amp;\u0026amp; maxn - w_ver[i] \u0026lt;= mid) return true; } return false; // 删了一条边还不够，说明mid取小了 } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt; n; ++i) { int x, y, e; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;e); add(x, y, e), add(y, x, e); } dep[1] = 1; init(1); for (int i = 1; i \u0026lt;= m; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;query[i].x, \u0026amp;query[i].y); query[i].fa = lca(query[i].x, query[i].y); } int l = 0, r = 300000000; // 3e5 * 1e3，答案最大是 3e8 while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (judge(mid)) r = mid; // mid自身也可能是答案，不要舍掉 else l = mid + 1; } printf(\u0026#34;%d\\n\u0026#34;, l); return 0; } ","date":"2022-08-30T08:37:12Z","permalink":"https://invalidnamee.github.io/p/noip2015/","title":"[noip2015 提高组] 运输计划"},{"content":"险些把@Laffey的题抢了\n注意审题！！因为审题出了很多问题。\n这题一眼看下去很无从下手，简单来说就是距离为2的两个点的权值之积为联合权值，让求最大联合权值和所有联合权值的总和\n仔细思考一下，一棵树中存在两个距离为2的点只有两种情况，一条线和一个角：\n数据有 60% 在 2000 以内， 这使我萌生了暴力的想法，先拿60再说\n暴搜思想(DFS) I. 一条线 这种很好想，只需在dfs的基础上记录一个前驱pre，若当前父节点为x，子节点为y，那么pre与y的距离为2，w[pre] * w[j]和w[j] * w[pre]是两个联合权值。\n代码\n1 2 3 4 5 6 7 8 9 10 11 12 void dfs(int x, int pre) { v[x] = 1; for(int i = head[x]; i; i = nxt[i]) { int \u0026amp; y = to[i]; if(!v[y]) { dfs(y, x); maxn = max(maxn, w[y] * w[pre]); sum += w[y] *w[pre] * 2; sum %= MOD; } } } 这个时候，样例过了，因为样例是单链！！\nII.一个角 这种情况难度就稍微大了一些，需统计同一层所有子节点，对其进行排列组合，每种配对的情况都是两组联合权值。 (可以对比之前做过的一道深搜 选数)\n举个栗子：\n这是一个以①为根的子树\n搜到②时，无法配对，继续搜索\n搜得到③时，可与②组合\n搜到④时，可与②和③组合\n刚好不重不漏\n我们的思路是搜到每一个子节点后向回搜索同层的子节点，分别计算，为此我们要记录当前父节点下的已搜过的子节点，直接开N * N的数组会爆too large所以我们开vector\u0026lt;int\u0026gt; son[N]\n做法是每搜到一个节点，先回搜同一层的子节点进行操作，然后将其编号存入son数组中为下一个节点使用，在原dfs加入\n1 2 3 4 5 6 for(auto i : son[x]) { maxn = max(maxn, w[y] * w[i]); sum += w[y] * w[i] * 2; sum %= MOD; } son[x].push_back(y); 这样，一个暴力的做法就完成了。\n暴力（70分）代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 4000010; const int MOD = 10007; typedef long long ll; //记得开long long不然取模之前容易爆 ll maxn; ll sum; bool v[N]; int to[N], head[N], nxt[N]; ll w[N]; vector\u0026lt;int\u0026gt; son[N]; int tot = 0; void add(int x, int y) { to[++tot] = y; nxt[tot] = head[x]; head[x] = tot; } void dfs(int x, int pre) { v[x] = 1; for(int i = head[x]; i; i = nxt[i]) { int \u0026amp; y = to[i]; if(!v[y]) { dfs(y, x); for(auto i : son[x]) { maxn = max(maxn, w[y] * w[i]); sum += w[y] * w[i] * 2; sum %= MOD; } son[x].push_back(y); maxn = max(maxn, w[y] * w[pre]); sum += w[y] * w[pre] * 2; sum %= MOD; } } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt; n; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); add(x, y); add(y, x); } for(int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;w[i]); dfs(1, 0); printf(\u0026#34;%lld %lld\u0026#34;, maxn, sum); return 0; } 优化 DFS -\u0026gt; 树形DP I.一个角 一条线的时间复杂度已经不大了，所以我们先来考虑一个角的情况\n再举个相同的栗子:\n回顾一下，以④为例\n$$ sum = sum + 2 \\times w[2] \\times w[4] + 2 \\times w[3] \\times w[4] = 2 \\times w[4] \\times (w[2] + w[3]) $$乘法分配律，明白吧\n推广到一般的父节点x,子节点y\n$$ sum = sum + 2 \\times w[y] \\times s(w[y前所有子节点]) $$同样最值也可以这么操作\n$$ maxn = max(maxn, w[y] \\times \\max(w[y前所有的子节点])) $$所以处理这种情况只需维护一个前缀和s[N]和一个最值m[N]就可以完成状态转移，无需遍历一遍。\n1 2 3 4 5 6 sum += 2 * s[x] * w[y]; sum %= MOD; maxn = max(maxn, m[x] * w[y]); //注意先处理sum和maxn再转移状态，因为反之w[y]会 * w[y]自己造成问题 s[x] += w[y]; m[x] = max(m[x], w[y]); 把之前的循环换掉就可以a掉了\nII.一条线 当dfs回溯到x时\n$$ s[y] = sum(w[y的所有孩子])\\\\ m[y] = max(w[y的所有孩子]) $$你发现了什么？\n其实在做上一次优化的时候一条线的情况也已经预处理好了，只需\n1 2 sum += 2 * s[y] * w[x]; maxn = max(maxn, m[y] * w[x]); 就ok了\n这样也不用再统计前驱了\nAc代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 400010; const int MOD = 10007; typedef long long ll; bool v[N]; int to[N], head[N], nxt[N]; //前向星 ll s[N], m[N], w[N]; /** * s[i]表示以i为顶的一层子树节点权值和 * m[i]表示以i为顶的一层子树节点权值最值 */ ll maxn = 0, sum = 0; int tot = 0; void add(int x, int y) { to[++tot] = y; nxt[tot] = head[x]; head[x] = tot; } void dp(int x) { v[x] = 1; for(int i = head[x]; i; i = nxt[i]) { int \u0026amp; y = to[i]; if(!v[y]) { dp(y); // case corner sum += 2 * s[x] * w[y]; sum %= MOD; maxn = max(maxn, m[x] * w[y]); //case line 这个放到哪里都行，与当前层的y权值无关 sum += 2 * s[y] * w[x]; sum %= MOD; maxn = max(maxn, m[y] * w[x]); //dp s[x] += w[y]; m[x] = max(m[x], w[y]); } } } int main() { int n; //read scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt; n; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); add(x, y); add(y, x); } for(int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;w[i]); //dp dp(1); printf(\u0026#34;%lld %lld\u0026#34;, maxn, sum); return 0; } ","date":"2022-08-30T08:37:07Z","permalink":"https://invalidnamee.github.io/p/noip2014/","title":"[noip2014 提高组] 联合权值"},{"content":"0.题目描述 题面:[NOI2015] 软件包管理器\n这道题是关于linux的软件依赖关系。\n依赖关系成一颗以 0 号软件为根的树。求安装或删除一个软件需要更改的软件包数\n1.做题经历 这个题我一上来半个小时左右就想到了解法，但是到今天才实现，因为他实在是太恶心，代码量太大，没办法。做题的过程中重写了两次代码，第二次疯狂调试，最后才调对。提前提醒大家不要放弃\n2.解析 2.1 思路 之前也提到了这道题可以抽象成一颗以 0 为根的树进行思考：\n安装一个软件 a ，需要安装从 a 到 0 路径上所有的软件\n卸载一个软件 b，需要卸载以 b 为根的子树中的所有软件\n由此可知这道题和树上的区间修改查询有关，可以用树链剖分来做。\n2.2 实现 下文中的数组的声明和函数原型为：\n1 2 3 4 5 6 7 int dep[N], cnt[N]; // 深度 子树节点个数 int id[N] // 树上的每个点映射到线段树上的位置 void modify(int u, int l, int r, int k); // 线段树区间修改 void modify(int x, int y, int k); // 树剖区间修改 void query(int u, int l, int r); // 线段树区间查询 void query(int x, int y); // 树剖区间查询 一个软件只有两个状态：已安装，未安装。为了方便统计，计已安装为 1, 未安装为 0 由此可知：\n安装一个软件 a，需要安装的软件数量为 dep[a] - query(0, a)，执行的操作是 modify(0,a,1)\n卸载一个软件 b，需要卸载的软件数量为 query(1, id[b], id[b] + cnt[b] - 1) ，执行的操作是 modify(1, id[b].id[b]+cnt[b]-1,0)\n实现的思路也很简单，难的是这道题有很多的坑，一不小心就进去了 awa\n2.3 坑 从 0 编号改成从 1 编号 问题：如果从 0 编号链式前向星和线段树都会出一些诡异的问题，莫名其妙得搜索直接挂了，线段树都是 0 (可能是我太弱了)\n解决：把读入的每个点的编号都加 1\n线段树直接赋值 问题：难以计算每个点需要加多少，因为有的点不用加，有的点用加 (软件已经装了不用再装一次)\n解决：安装时直接把区间赋值成区间长度，卸载时直接将区间改成 0\n到这里问题就已经解决了，思路简单也好理解，就是写代码很艰难，最后贴上我的代码，实在写不出来了或者找不出错的可以参考一下，里面也有一些调试的思路。\nAc Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; struct SegmentTree{ int l, r; int val, lazy; // 这颗树中 lazy 的有效值只能是 0 或 1, 把 lazy 的初值赋成 -1 以防更新错误(下放懒标记时, 全成 0 了) SegmentTree() {lazy = -1;} }tr[N * 4]; int nxt[N], ver[N], head[N]; int tot; int fa[N], dep[N], son[N], cnt[N]; int id[N], rnk[N], top[N]; int times; void add(int x, int y ) { ver[++tot] = y; nxt[tot] = head[x]; head[x] = tot; } void dfs(int x) { cnt[x] = 1; for (int i = head[x]; i; i = nxt[i]) { int \u0026amp;y = ver[i]; if (y == fa[x]) continue; fa[y] = x; dep[y] = dep[x] + 1; dfs(y); cnt[x] += cnt[y]; if (cnt[son[x]] \u0026lt; cnt[y]) son[x] = y; } } void dfs(int x, int tp) { top[x] = tp; id[x] = ++times; rnk[times] = x; if (!son[x]) return; dfs(son[x], tp); for (int i = head[x]; i; i = nxt[i]) { int \u0026amp;y = ver[i]; if (y == fa[x] || y == son[x]) continue; dfs(y, y); } } void push_up(int u) { tr[u].val = tr[u \u0026lt;\u0026lt; 1].val + tr[u \u0026lt;\u0026lt; 1 | 1].val; } void push_down(int u) { // 要装这个区间内的都得装, 同样, 要卸都得卸 if (tr[u].lazy == -1) return; // 没有懒标记的不算 tr[u \u0026lt;\u0026lt; 1].lazy = tr[u].lazy; tr[u \u0026lt;\u0026lt; 1 | 1].lazy = tr[u].lazy; tr[u \u0026lt;\u0026lt; 1].val = tr[u].lazy * (tr[u \u0026lt;\u0026lt; 1].r - tr[u \u0026lt;\u0026lt; 1].l + 1); tr[u \u0026lt;\u0026lt; 1 | 1].val = tr[u].lazy * (tr[u \u0026lt;\u0026lt; 1 | 1].r - tr[u \u0026lt;\u0026lt; 1 | 1].l + 1); tr[u].lazy = -1; // 清空后变成 -1, 不要改成 0, 0也是有效数字, 否则下放懒标记后都成 0 了 } void build(int u, int l, int r) { tr[u].l = l, tr[u].r = r; if (l == r) return; // 直接就是 0, 默认都没装 int mid = l + r \u0026gt;\u0026gt; 1; build (u \u0026lt;\u0026lt; 1, l, mid), build(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r); } void modify(int u, int l, int r, int k) { if (l \u0026lt;= tr[u].l \u0026amp;\u0026amp; tr[u].r \u0026lt;= r) { // 注意，直接赋值，否则还得多写一个 query 增大常数时间复杂度还容易错 tr[u].lazy = k; tr[u].val = k * (tr[u].r - tr[u].l + 1); } else { push_down(u); int mid = tr[u].l + tr[u].r \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) modify(u \u0026lt;\u0026lt; 1, l, r, k); if (r \u0026gt; mid) modify(u \u0026lt;\u0026lt; 1 | 1, l, r, k); push_up(u); } } void modify(int x, int y, int k) { while (top[x] != top[y]) { if (dep[top[x]] \u0026gt; dep[top[y]]) swap(x, y); modify(1, id[top[y]], id[y], k); y = fa[top[y]]; } if (dep[x] \u0026gt; dep[y]) swap(x, y); modify(1, id[x], id[y], k); } int query(int u, int l, int r) { if (l \u0026lt;= tr[u].l \u0026amp;\u0026amp; tr[u].r \u0026lt;= r) return tr[u].val; else { push_down(u); int mid = tr[u].l + tr[u].r \u0026gt;\u0026gt; 1; int res = 0; if (l \u0026lt;= mid) res += query(u \u0026lt;\u0026lt; 1, l, r); if (r \u0026gt; mid) res += query(u \u0026lt;\u0026lt; 1 | 1, l, r); return res; } } int query(int x, int y) { int res = 0; while (top[x] != top[y]) { if (dep[top[x]] \u0026gt; dep[top[y]]) swap(x, y); res += query(1, id[top[y]], id[y]); y = fa[top[y]]; } if (dep[x] \u0026gt; dep[y]) swap(x, y); res += query(1, id[x], id[y]); return res; } void print(int u) { // 检查线段树用的，输出每个点的值 if (tr[u].l == tr[u].r) { printf(\u0026#34;%d \u0026#34;, tr[u].val); } else { push_down(u); // 记得下放懒标记 print(u \u0026lt;\u0026lt; 1), print(u \u0026lt;\u0026lt; 1 | 1); } } int main() { int n, m; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 2; i \u0026lt;= n; ++i) { // 一定要这么写, 后果不堪设想 int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); add(t + 1, i); } dep[1] = 1; dfs(1); dfs(1, 1); build(1, 1, n); scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); while (m--) { string s; int t; cin \u0026gt;\u0026gt; s, scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); ++t; // 一定要这么写, 后果不堪设想 if (s == \u0026#34;install\u0026#34;) { printf(\u0026#34;%d\\n\u0026#34;, dep[t] - query(1, t)); modify(1, t, 1); } else { printf(\u0026#34;%d\\n\u0026#34;, query(1, id[t], id[t] + cnt[t] - 1)); modify(1, id[t], id[t] + cnt[t] - 1, 0); } } return 0; } ","date":"2022-08-30T08:36:53Z","permalink":"https://invalidnamee.github.io/p/noi2015/","title":"[noi2015] 软件包管理器"},{"content":"因为人在学校时间比较要紧就写简单一些\n题面: P5752 [NOI1999] 棋盘分割\n这道题自己没想出来，结合 zsh 的 ppt 和洛谷上的题解才搞明白\n这道题涉及到分割和最值，所以目标就锁定在区间dp，在想dp之前也有几个要处理的问题\n1.数学问题 这道题要求标准差，但是因为有根号很难搞，所以可以先用方差算\n$$ s^2 = (\\frac{1}{n} \\sum^n_{i = 1}{x_i^2}) - \\bar x^2\\\\ \\sigma = \\sqrt {s^2} $$这样只需求出 \\( \\sum_{i = 1}^{n}{x_i^2} \\)再套公式即可求出答案\n2.二维前缀和 因为这道题需要多次计算一个块内的权值的和，维护一个二维的前缀和会很方便，复习一下\n维护前缀和\n1 2 3 4 5 for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { s[i][j] = a[i][j] + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; } } 计算从 $(x_1, y_1)$ 到$(x_2, y_2)$ 的前缀和\n1 2 3 int get_sum(int x1, int y1, int x2, int y2) { return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; } 3.区间dp 思路\ndp的大致思路是维护每一个二维区间内分割 $k$ 次后每一块的总和的平方除以 $n$ 后的结果的和的最小值，目标是 f[1][1][8][8][k]，结果是 sqrt(f[1][1][8][8][n] - ave * ave。（ave 为平均值 $\\bar x$）\n状态\n表示一个二维区间至少需要 $4$ 个参数(左上角坐标和右下角坐标)，所以 $f$ 数组要开五维，即 f[9][9][9][9][15]，\nf[x1][y1][x2][y2][k]表示从 $(x_1,y_1)$ 到 $(x_2,y_2)$ 这段区间内分割 $k$ 次后每个子区间的权值和 $s$ 的 $\\frac{s^2}{n}$ 的和的最小值\n重点 ——枚举分割点\n因为只能砍成两半，所以可以分别枚举横向分割的分割点的纵坐标和纵向分割的分割点的横坐标，然后状态转移\n1 2 3 4 5 6 7 8 9 10 for (int t = x1; t \u0026lt; x2; ++t) { // 枚举纵坐标 f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k], min(f[t + 1][y1][x2][y2][k - 1] + getf(x1, y1, t, y2), // 上侧已被分割 k - 1 次 f[x1][y1][t][y2][k - 1] + getf(t + 1, y1, x2, y2))); // 下侧已被分割 k - 1 次 } for (int t = y1; t \u0026lt; y2; ++t) { // 枚举横坐标 f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k], min(f[x1][t + 1][x2][y2][k - 1] + getf(x1, y1, x2, t), // 左侧已被分割 k - 1 次 f[x1][y1][x2][t][k - 1] + getf(x1, t + 1, x2, y2))); // 右侧已被分割 k - 1 次 } 其中 getf 为\n1 2 3 4 double getf(int x1, int y1, int x2, int y2) { double tmp = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; return tmp * tmp / n; } 最后看一下代码 我就知道你写不出来 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int a[9][9]; double s[9][9], f[9][9][9][9][15]; int n; double getf(int x1, int y1, int x2, int y2) { double tmp = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; return tmp * tmp / n; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= 8; ++i) { for (int j = 1; j \u0026lt;= 8; ++j) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); s[i][j] = a[i][j] + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; // 二维前缀和 } } double ave = s[8][8] / n; for (int k = 1; k \u0026lt;= n; ++k) { for (int x2 = 1; x2 \u0026lt;= 8; ++x2) { for (int y2 = 1; y2 \u0026lt;= 8; ++y2) { for (int x1 = 1; x1 \u0026lt;= x2; ++x1) { // x1 \u0026lt;= x2 y1 \u0026lt;= y2 这样枚举会快一点 for (int y1 = 1; y1 \u0026lt;= y2; ++y1) { if (k == 1) { // 记得初始化 f[x1][y1][x2][y2][k] = getf(x1, y1, x2, y2); continue; } f[x1][y1][x2][y2][k] = 0x3f3f3f3f; // 记得初始化 // 注意区间不要重叠 for (int t = x1; t \u0026lt; x2; ++t) { // 枚举纵坐标 f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k], min(f[t + 1][y1][x2][y2][k - 1] + getf(x1, y1, t, y2), // 上侧已被分割 k - 1 次 f[x1][y1][t][y2][k - 1] + getf(t + 1, y1, x2, y2))); // 下侧已被分割 k - 1 次 } for (int t = y1; t \u0026lt; y2; ++t) { // 枚举横坐标 f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k], min(f[x1][t + 1][x2][y2][k - 1] + getf(x1, y1, x2, t), // 左侧已被分割 k - 1 次 f[x1][y1][x2][t][k - 1] + getf(x1, t + 1, x2, y2))); // 右侧已被分割 k - 1 次 } } } } } } printf(\u0026#34;%.3lf\\n\u0026#34;, sqrt(f[1][1][8][8][n] - ave * ave)); // 输出结果 } ","date":"2022-08-29T12:58:51Z","permalink":"https://invalidnamee.github.io/p/noi1999/","title":"[noi1999] 棋盘分割"},{"content":"0. 题目描述 题面:P2294 [HNOI2005]狡猾的商人\n检查一个商人的账本是否是伪造的(缩句大师)，简单来说就是对于每一组数据，每个区间内的盈利总和应该一致，否则就是伪造的\n1. 心路历程 其实看了描述就跟没看一样懵，因为这道题涉及到区间和之类的东西，所以我的第一反应是线段树维护区间和，但是后来发现这样不行，因为你只知道一个区间的总和，并不知道每个子区间的详细信息，所以当输入的一个区间横跨线段树的两个节点时就没办法处理了。所以不可以用维护区间和的思想。\n所以要想一个别的方法巧妙地解决这个问题，因刚学了差分约束系统，所以我简单地想到了图论\n2. 解析 2.1 建边 对于每个区间 \\( [l, r] \\) ，都建一条边 \\( (l - 1) \\) -\u0026gt; \\( r \\)，边权为盈利值 \\( a \\)\n2.2 思路 也很简单，如果一个区间 \\( (l, r] \\)的盈利值是 \\( a \\)，那么所有由 \\( l \\) 指向 \\( r \\) 的路径的长度应该都为 \\( a \\) ，否则就是假的。\n计起点到第 \\( i \\) 个点的距离为 \\( d[i] \\) ，那么当存在一条起点为 \\( x \\) 终点为 \\( y \\) 边权值为 \\( a \\) 的边满足 \\( d[y] \\neq d[x] + a \\) 时，这个账单是假的。\n2.3 坑点 区间\n所有的区间都要改成一开一闭（我这里是前开后闭），如果按照题目的读入直接建边就会面临一定的问题。\n例如:题目的样例第二组\n1 2 3 4 5 3 1 5 100 3 5 50 1 2 51 如果按照读入的数据建图，画成图就是这样子的:\n显然这个是错的， \\( 2 \\) 和 \\( 3 \\) 是相连的。但是如果把区间 \\( [l, r] \\) 改成一开一闭，即 \\( (l-1,r] \\) ，图就会变成这样:\n于是图就连上了，同时因为 \\( 51+50 \\neq 100 \\) ，所以答案是 \\( false \\)。\n多起点SPFA\n因为图中的每个连通块都是相互独立，互不干扰的（每个极大区间相互独立），所以对于每一个连通块都独立地跑一遍SPFA\n判断条件\n对于每一个连通块内，当 \\( d[y] = d[x] + w \\) 或 \\( d[y] = 0 \\) 时更新 \\( d[y] \\) ，并且将 \\(d[y] \\) 入队，否则直接判false，全部正常跑完为true。\n对于整张图，存在一个连通块 false，直接是 false；所有连通块都为 true，就输出 true。\n明确了思路之后就可以自己尝试写一下了，实在不会了看下面的代码。\nAc Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 1010; int nxt[N * 4], ver[N * 4], w[N * 4], head[N]; // 前向星存图 int d[N]; // 距离 bool v[N]; // 记录是否被访问过，被访问过的点已经在别的连通块中，所以下一次就不用从这个点开始搜了 int tot; int n, m; int read() { int res = 0; char c = getchar(); bool flag = 0; while (c \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) { if (c == \u0026#39;-\u0026#39;) flag = 1; // 快读记得特判负数 c = getchar(); } while (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) res = res * 10 + c - 48, c = getchar(); return flag ? -res : res; } void add(int x, int y, int e ) { ver[++tot] = y; w[tot] = e; nxt[tot] = head[x]; head[x] = tot; } void init() { memset(nxt, 0, sizeof(nxt)); memset(ver, 0, sizeof(ver)); memset(w, 0, sizeof(w)); memset(head, 0, sizeof(head)); memset(v, 0, sizeof(v)); tot = 0; // 记得初始化 tot } bool spfa(int s) { bool exist[N]; memset(exist, 0, sizeof(exist)); memset(d, 0, sizeof(d)); // 这个每次都要重置，因为每个连通块，起点不同 queue\u0026lt;int\u0026gt; q; q.push(s); v[s] = exist[s] = 1; while (!q.empty()) { int x = q.front(); q.pop(); exist[x] = 0; for (int i = head[x]; i; i = nxt[i]) { int \u0026amp;y = ver[i], \u0026amp;e = w[i]; if (d[y] == d[x] + e || d[y] == 0) { // d[y] == 0 时，这个点没被更新，需要更新一次 d[y] = d[x] + e; if (!exist[y]) { exist[y] = 1; q.push(y); } } else return false; // 不相等直接就是false } } return true; // 一个块内所有的点都没问题才是true } int main() { int T = read(); while (T--) { init(); // 记得初始化 n = read(), m = read(); for (int i = 1; i \u0026lt;= m; ++i) { int x = read(), y = read(), z = read(); add(x - 1, y, z); // 前开后闭 } bool flag = 0; for (int i = 0; i \u0026lt;= n; ++i) { if (v[i]) continue; if (!spfa(i)) { // 一个是false这组数据就直接是false printf(\u0026#34;false\\n\u0026#34;); flag = 1; break; } } if (!flag) { printf(\u0026#34;true\\n\u0026#34;); // 每一个都是true，这组数据就是true } } return 0; } ","date":"2022-08-29T12:58:44Z","permalink":"https://invalidnamee.github.io/p/hnoi2005/","title":"[hnoi2005] 狡猾的商人"}]