[{"content":"å¿ƒç†ç¬”è®°æ•´åˆ å¿ƒç†å’¨è¯¢é¢„çº¦ é¢„çº¦æ–¹å¼: ç”µè¯é¢„çº¦: 86981525(é¢„çº¦æ—¶éœ€å‘ŠçŸ¥è‡ªå·±æ‰€åœ¨æ ¡åŒº) ç½‘ä¸Šé¢„çº¦: å…³æ³¨â€œçŸ³å¤§å¿ƒç†â€å…¬ä¼—å·ï¼Œç‚¹å‡»â€œå¿ƒç†å’¨è¯¢â€é¢„çº¦ã€‚ ç°åœºé¢„çº¦: æ ¡åŒ»é™¢ä¸‰æ¥¼ 333-9 å¿ƒç†å’¨è¯¢å€¼ç­å®¤(ä»…é™å”å²›æ¹¾æ ¡åŒº) æ¥å¾…æ—¶é—´: å”å²›æ¹¾æ ¡åŒºï¼šå‘¨ä¸€è‡³å‘¨æ—¥ä¸Šåˆ8:30-11:40ï¼Œä¸‹åˆ2:30-5:40ï¼Œæ™šä¸Š19:00-20:50 å¤é•‡å£æ ¡åŒºï¼šå‘¨ä¸€è‡³å‘¨äº”åŒä¸Šï¼Œå‘¨å…­ä¸Šåˆ8:30-11:40 æ¥å¾…åœ°ç‚¹: å”å²›æ¹¾æ ¡åŒº: æ ¡åŒ»é™¢ä¸‰æ¥¼333-9 å¤é•‡å£æ ¡åŒºï¼š3å·å…¬å¯“æ¥¼144(å¤é•‡å£æ ¡åŒºä»…æ¥å—ç”µè¯å’Œç½‘ç»œé¢„çº¦) å¿ƒç†å­¦ç»ªè®º å¿ƒç†å­¦çš„æ¦‚å¿µ åˆç§°å¿ƒç†ç§‘å­¦ï¼Œç ”ç©¶å¿ƒç†ç°è±¡åŠå…¶è§„å¾‹çš„ç§‘å­¦\nå¿ƒç†ç°è±¡ æ„ŸçŸ¥è§‰ è®°å¿† æƒ³è±¡ï¼Œæ€ç»´ æƒ…æ„Ÿ æ„å¿— è¡Œä¸º å¿ƒç†å­¦è¯ç”Ÿçš„æ ‡å¿— 1879 å¹´å†¯å¾·ç‰¹åœ¨å¾·å›½è±æ¯”é”¡å»ºç«‹ç¬¬ä¸€ä¸ªå¿ƒç†å­¦å®éªŒå®¤ï¼Œæ ‡å¿—ç€å¿ƒç†å­¦è¯ç”Ÿ\nå¿ƒç†é—®é¢˜çš„æ¦‚å¿µ æ‰€æœ‰å„ç§å¿ƒç†è¡Œä¸ºå¼‚å¸¸çš„æƒ…å½¢\nå¿ƒç†é—®é¢˜çš„ç±»å‹ å¿ƒç†å›°æ‰° å¿ƒç†éšœç¢ ç²¾ç¥ç–¾ç—… å¿ƒç†å¥åº· è®¤çŸ¥ æƒ…æ„Ÿæ„å¿— è¡Œä¸º äººæ ¼åè°ƒ å¿ƒç†å¥åº·çš„æ ‡å¿— å¯¹ç”Ÿæ´»å……æ»¡çˆ±ï¼Œå……æ»¡å‘å¾€ï¼Œè§‰å¾—ç”Ÿæ´»å……æ»¡ä¹è¶£ ç¨³å®šçš„æƒ…ç»ª æœ‰è¾ƒå¼ºçš„é€‚åº”èƒ½åŠ› è§£å†³å¿ƒç†é—®é¢˜çš„å…³é”®æ˜¯è®¤çŸ¥æ€åº¦ å…·æœ‰å…è®¸å¿ƒç†é—®é¢˜å­˜åœ¨çš„æ€åº¦ è®¤è¯†åˆ°å¿ƒç†é—®é¢˜æ˜¯æ— æ³•å½»åº•æ¶ˆé™¤çš„ å…è®¸è‡ªå·±ä¸å®Œç¾çš„ä½ æ‰èƒ½æ›´å®Œç¾ã€‚\nè‡ªæˆ‘æ„è¯† æ¦‚å¿µ äººå¯¹è‡ªå·±èº«å¿ƒçŠ¶æ€åŠå¯¹è‡ªå·±åŒä¸–ç•Œå…³ç³»çš„æ„è¯†\nå†…å®¹ ç”Ÿç†è‡ªæˆ‘ å¿ƒç†è‡ªæˆ‘ ç¤¾ä¼šè‡ªæˆ‘ åå·® è‡ªæˆ‘ä¸­å¿ƒ è‡ªè´Ÿ è‡ªå‘ ä»ä¼— ç›¸å…³æ•ˆåº” ç„¦ç‚¹æ•ˆåº” é€æ˜æ•ˆåº” è‡ªæˆ‘å¦¨ç¢æ•ˆåº” ç§¯æå¿ƒç†å­¦ ä»€ä¹ˆæ˜¯å¹¸ç¦ æ„‰æ‚¦æ„Ÿ ä»·å€¼æ„Ÿ æ»¡æ„æ„Ÿ æ²¡æœ‰å¹¸ç¦æ„Ÿ æ´»åœ¨è¿‡å» æ´»åœ¨æœªæ¥ æå‡å¹¸ç¦æ„Ÿï¼Œå…¬å¼ H = S + C + V C ç”Ÿæ´»ç¯å¢ƒ(10%ï½15%) S å…ˆå¤©å†³å®šçš„å¹¸ç¦æ°´å¹³ å¹¸ç¦çš„æ„ŸçŸ¥èƒ½åŠ›(50%) V è‡ªæˆ‘å¯æ§åˆ¶çš„å› ç´  ç§¯æå¿ƒç†å­¦çš„æ ¸å¿ƒ(35ï½40%) åŸ¹å…»ä¹è§‚çš„ ABCDE æ¨¡å¼ A(adversity) ä»£è¡¨ä¸å¥½çš„äº‹ B(belief) ä»£è¡¨äº‹æƒ…å‘ç”Ÿæ—¶è‡ªåŠ¨å‡ºç°çš„å¿µå¤´ã€æƒ³æ³• C(consequence) ä»£è¡¨è¿™æƒ³æ³•äº§ç”Ÿçš„åæœ D(disputation) ä»£è¡¨åé©³ E(energization) ä»£è¡¨ä½ æˆåŠŸè¿›è¡Œåé©³åæ”¶åˆ°çš„æ¿€å‘ å¹¸ç¦æ„Ÿ æ„‰æ‚¦ï¼šæ„Ÿå®˜(å…‹æœä¹ æƒ¯åŒ–ï¼Œå“å‘³æ­£å¿µ) æ»¡æ„ï¼šè‡ªå·±ä¼˜åŠ¿çš„å‘æŒ¥(æŒ‘æˆ˜æ€§â€¦â€¦) çˆ±æƒ… äºŸå¾…è¡¥å……\nq2-é—®ä¸–é—´æƒ…ä¸ºä½•ç‰©\næ–¯æ»•ä¼¯æ ¼çˆ±æƒ…ä¸‰è§’ç†è®º\nå¦‚å›¾æ‰€ç¤º\nq3-äººä»¬ä¸ºä»€ä¹ˆè¦è°ˆæ‹çˆ±ï¼Œä¸è°ˆè¡Œä¸è¡Œï¼Ÿ\né©¬æ–¯æ´›éœ€æ±‚å±‚æ¬¡ç†è®ºï¼Œå…¶ä¸­çˆ±æƒ…ã€æ€§äº²å¯†å±äºå½’å±éœ€æ±‚\nåŸƒé‡Œå…‹æ£®å…«é˜¶æ®µäººæ ¼å‘å±•ç†è®º\né˜¶æ®µ å¤§è‡´å¹´é¾„ å¿ƒç†ç¤¾ä¼šæ€§å‘å±•é˜¶æ®µ æ­£æ€§ç»“æœ è´Ÿæ€§ç»“æœ é’å°‘å¹´æœŸ 12-18å² åŒä¸€æ€§å¯¹è§’è‰²æ··ä¹± æ„è¯†åˆ°è‡ªæˆ‘ç‹¬ç‰¹æ€§ï¼Œæ¸…æ™°è‡ªå·±çš„è§’è‰² ä¸èƒ½è¯†åˆ«ç”Ÿå‘½ä¸­é€‚å½“è§’è‰² æˆå¹´æ—©æœŸ 18Â·25å² äº²å¯†å¯¹å­¤ç‹¬ å»ºç«‹æ€§çˆ±å…³ç³»å’Œäº²å¯†çš„å‹è°Š å¯¹ä¸ä»–äººå»ºç«‹å…³ç³»æ„Ÿåˆ°ææƒ§ æˆ‘ä»¬å¤„äºæˆå¹´æ—©æœŸ\nq4-äººé™…å…³ç³»å½±å“å› ç´ \nâ€œå§‹äºé¢œå€¼ï¼Œå¿ äºäººå“â€\nå¤–è¡¨ 50% ä¸å¤–è¡¨æœ‰å…³ï¼›40% ä¸å£°éŸ³æœ‰å…³ï¼› 10% ä¸è¨€è¯­ä¸¾æ­¢æœ‰å…³ æ‰èƒ½ äººæ ¼ç‰¹è´¨(æœ€ç¨³å®šçš„ï¼Œæœ€é‡è¦çš„å› ç´ ä¹‹ä¸€) æ—¶é—´å’Œç©ºé—´ æ—¶é—´å› ç´  äº¤å¾€çš„æœºä¼šã€é¢‘ç‡ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œäº¤å¾€é¢‘ç‡è¶Šé«˜ï¼Œè¶Šå®¹æ˜“ç›¸äº’äº†è§£ ç©ºé—´å› ç´  æŒ‡äº¤å¾€åŒæ–¹è·ç¦»çš„è¿œè¿‘ã€‚â€œè¿‘æ°´æ¥¼å°å…ˆå¾—æœˆâ€œï¼Œâ€è¿œäº²ä¸å¦‚è¿‘é‚»â€œã€‚ æ€åº¦ç›¸ä¼¼æ€§(åœ¨ç†æƒ³ï¼Œä¿¡å¿µï¼Œä»·å€¼è§‚ï¼Œå…´è¶£çˆ±å¥½æ–¹é¢æœ‰ä¸åŒçš„æ€åº¦) äº’è¡¥æ€§(ç›¸ä¼¼æ€§çš„ä½œç”¨ \u0026raquo; äº’è¡¥æ€§) q5-è¦ä¸è¦è¡¨ç™½ï¼Œä»€ä¹ˆæ—¶å€™è¡¨ç™½ï¼Ÿ(è¡¨è¾¾çˆ±çš„èƒ½åŠ›)\nçº¦ç¿°Â·èŒƒÂ·åŸƒæ™®æå‡ºå…³ç³»ä¾æ‹æ¨¡å‹ R.A.M. åœ¨å»ºç«‹æ‹çˆ±å…³ç³»æ—¶åº”ä¾æ¬¡ç»å†\näº†è§£å¯¹æ–¹(Know) å®¶åº­èƒŒæ™¯ é“å¾·æ„Ÿ åŒ¹é…æ½œèƒ½ è¿‡å»è¡Œä¸ºæ¨¡å¼ å…³ç³»æŠ€èƒ½ å»ºç«‹ä¿¡ä»»(Trust) äº§ç”Ÿä¾èµ–(Rely) ç»™å‡ºæ‰¿è¯º(Commit) èº«ä½“æ¥è§¦(Touch) äº”ä¸ªé˜¶æ®µã€‚\nå­¦ä¼šè¡¨è¾¾çˆ±\nè¡¨ç™½æœ‰é£é™©(ç¡®å®šå¯¹æ–¹å¿ƒæ„) åˆ‡å¿Œé“å¾·ç»‘æ¶ï¼Œä½œç§€è¯·è°¨æ… ç…§é¡¾åˆ°å¯¹æ–¹çš„æƒ…ç»ªä¸æ„Ÿå— åŸåˆ™ï¼šçœŸè¯šã€å°Šé‡ã€é€‚åº¦ q6-æ¥å—çˆ±çš„èƒ½åŠ›\nq7-å¦‚ä½•å©‰æ‹’åˆ«äººçš„çˆ±æ„(æ‹’ç»çˆ±çš„èƒ½åŠ›)\nå§”å©‰è€Œåšå®šçš„æ‹’ç»ä¸€ä»½ä¸æƒ³è¦çš„æ„Ÿæƒ…æ˜¯ä¸€ä»¶éœ€è¦å‹‡æ°”çš„äº‹æƒ…ï¼\næ„Ÿè°¢å¯¹æ–¹çˆ±çš„è¡¨è¾¾ æ¸©å’Œè€Œåšå®šåœ°è¯´æ˜è‡ªå·±æ²¡æœ‰æ„æ„¿ ä¸è¿›è¡Œäººèº«æ”»å‡» q10-é˜¶æ®µ\nå…±å­˜(ç”œèœœæœŸ) åä¾èµ–(çŸ›ç›¾æ½œä¼æœŸ) æ€€ç–‘(çŸ›ç›¾çªå‘æœŸ) q11-å®‰å…¨æ„Ÿ\nq13-å¦‚ä½•åµæ¶è®©æˆ‘ä»¬çš„æ„Ÿæƒ…â€œè¶Šåµè¶Šå¥½â€(è§£å†³å†²çªçš„èƒ½åŠ›)\nåµæ¶ä¸éš”å¤œ æ‘†æ­£æ€åº¦ï¼Œä»¥è§£å†³é—®é¢˜ä¸ºç›®çš„åµæ¶ å¹³ç­‰ å…ˆè§£å†³æƒ…ç»ªï¼Œå†è§£å†³é—®é¢˜ï¼ï¼ï¼ å…³æ³¨æƒ…ç»ªçš„æ­£ç¡®è¡¨è¾¾ æ­£å‘è¡¨è¾¾\nçœ‹åˆ°/å¬åˆ°çš„ç°å®æ˜¯ä»€ä¹ˆ ä½ çš„æƒ³æ³•æ˜¯ä»€ä¹ˆ ä½ çš„æ„Ÿå— ä½ çš„æœŸå¾… or éœ€æ±‚ å®ˆæŠ¤çˆ±\nå…±ç”Ÿ(ç¨³å®šæœŸ) æ—¶é—´ä¹…äº†ï¼Œåµç´¯äº†ï¼Œæ–°çš„ç›¸å¤„ä¹‹é“ä¹Ÿå°±å½¢æˆäº†ï¼Œä¸¤ä¸ªäººå¼€å§‹æ„ è¯†åˆ°æ„Ÿæƒ…çš„ä¸æ˜“ï¼Œç›¸äº’çæƒœï¼Œç‰µæ‰‹èµ°å®Œä¸€ç”Ÿã€‚ q14-çˆ±æƒ…å¦‚ä½•ä¿é²œï¼Ÿâ€”â€”çˆ±çš„äº”ç§è¯­è¨€\nè‚¯å®šçš„è¨€è¯ éœ€è¦èµç¾é¼“åŠ±ã€å®‰æ…°ã€ç”œè¨€èœœè¯­ ç²¾å¿ƒçš„æ—¶åˆ» ç²¾å¿ƒçš„æ—¶åˆ»æ˜¯ç»™äºˆå¯¹æ–¹å…¨éƒ¨çš„æ³¨æ„åŠ›ï¼Œè®©å¯¹æ–¹æ„Ÿå—åˆ°ä½ ä¸“æ³¨äºä»–/å¥¹ æ¥å—çš„ç¤¼ç‰© çˆ±ï¼Œç»™äºˆï¼Œç¤¼ç‰©æ˜¯æˆ‘ä»¬è¡¨è¾¾å’Œä¼ é€’çˆ±çš„åª’ä»‹ï¼Œæ˜¯çˆ±çš„è§†è§‰è±¡å¾ æœåŠ¡çš„è¡ŒåŠ¨ çˆ±éœ€è¦è½å®çš„è¡ŒåŠ¨ èº«ä½“çš„æ¥è§¦ èº«ä½“çš„æ¥è§¦æ˜¯äº²å¯†å…³ç³»çš„è¡¨ç°ä¸å‡å q15-å¦‚ä½•é¢å¯¹å¹¶èµ°å‡ºå¤±æ‹\nä½ åŠªåŠ›äº†å—ï¼Ÿè®¤çœŸå¯¹å¾…äº†å—ï¼Ÿ æ¥çº³äº‹å®ï¼Œæ¥çº³æ„Ÿå—ï¼Œå…è®¸è‡ªå·±ç—›è‹¦ è½¬ç§»æ³¨æ„åŠ› å‘å¤–æ±‚åŠ©(æœ‹å‹ã€çˆ¶æ¯ã€çŠ€åˆ©å’¨è¯¢æœºæ„ç­‰) å¤±æ‹ä¸€å®šä¼šç—›è‹¦ï¼Œå¹¶ä¸æ„å‘³ç€ä½ ä¸å¥½ï¼Œè¿‡å»çš„ç¾å¥½æ˜¯çœŸå®çš„ï¼Œæœªæ¥çš„ç¾å¥½ä¹Ÿæ˜¯ä¼šæ¥çš„ğŸ˜­\nq16-å¦‚ä½•çœ‹å¾…æ‹çˆ±çš„å¼€å§‹å’Œç»“æŸï¼Œæ­£ç¡®çš„æ‹çˆ±è§‚ï¼Ÿ\nä½ å¥½ä¸å¥½ï¼Œta å¥½ä¸å¥½ï¼Ÿ ta å¯¹ä½ å¥½ä¸å¥½ï¼Œä½ å¯¹ ta å¥½ä¸å¥½ï¼Ÿ ta å¯¹ä½ çš„å¥½æ˜¯ä¸æ˜¯ä½ éœ€è¦çš„å¥½ï¼Ÿä½ å¯¹ ta çš„å¥½æ˜¯ä¸æ˜¯ ta éœ€è¦çš„å¥½ï¼Ÿ q17-å­˜åœ¨å®Œç¾çš„çˆ±æƒ…å—ï¼Œå­˜åœ¨å¤©é€ åœ°è®¾çš„ä¸€å¯¹å—ï¼Ÿ\nçˆ±æƒ…é™·é˜±ï¼šå®Œç¾ä¼´ä¾£\nè¿™ä¸–ä¸Šä»æ¥æ²¡æœ‰å¤©é€ åœ°è®¾çš„çˆ±æƒ…ï¼Œæœ‰çš„ä¸è¿‡æ˜¯åœ¨ç›¸äº’ç£¨åˆä¸­è¶Šæ¥è¶Šåšå®šçš„ä¸¤é¢—å¿ƒã€‚ç™½å¤´å•è€çš„ç§˜å¯†ï¼Œä¹Ÿä»æ¥ä¸æ˜¯â€œæˆ‘ä»¬ç›¸çˆ±å°±è¡Œäº†â€ï¼Œè¿˜åŒ…æ‹¬å„é€€ä¸€æ­¥ã€ç›¸äº’æœè½¯ã€è½®æµä½å¤´ï¼Œä»¥åŠå…è®¸â€œä½ æ˜¯ä½ ï¼Œæˆ‘æ˜¯æˆ‘â€ã€‚\nq18-ï¼Ÿï¼Ÿï¼Ÿ\nçˆ±äººè¦çˆ±å·±\nå¼—æ´›å§†: å…ˆè¦å…·å¤‡åˆ›é€ æ€§çš„å¥å…¨äººæ ¼ï¼Œä½¿è‡ªå·±æˆä¸ºæˆç†Ÿçš„äººï¼Œæ‰æœ‰è°ˆçˆ±çš„èƒ½åŠ›ã€‚å› ä¸ºæˆç†Ÿçš„çˆ±ï¼Œæ˜¯åœ¨ä¿ç•™è‡ªèº«å®Œæ•´æ€§å’Œç‹¬ç«‹æ€§çš„æƒ…å†µä¸‹ï¼Œä¸ä»–äººçš„ç»“åˆã€‚â€”â€”ã€Šçˆ±çš„è‰ºæœ¯ã€‹\nåˆ›é€ æ€§çš„å¥å…¨äººæ ¼ï¼Œæœ€é‡è¦çš„ä¸€ä¸ªæ ‡å‡†åœ¨äº: è‡ªçˆ± æˆ‘ä»¬è¦å…ˆå­¦ä¼šçˆ±è‡ªå·±ï¼Œè€Œåæ‰æœ‰èƒ½åŠ›å»çˆ±åˆ«äºº å¹¶ä¸”è¦è®°å¾—ï¼šçˆ±è‡ªå·±æ˜¯ä¸€ç”Ÿçš„ï¼ çˆ±æƒ…é™·é˜±: æœ‰ä½ ï¼Œæˆ‘æ‰å®Œæ•´\nå¥åº·çš„å…³ç³»åº”è¯¥æ˜¯æ— è®ºè‡ªå·±æœ‰æ²¡æœ‰ä¼´ä¾£ï¼Œä½ éƒ½æ˜¯å®Œæ•´çš„\nåšæŒè‡ªå·±çš„ç«‹åœºï¼Œä¸ä¼šå› ä¸ºå®³æ€•è¢«æ‹’ç»ï¼Œè¢«æŠ›å¼ƒè€Œé€€ç¼©\nå‹åŠ› å¤§å­¦ç”Ÿå¸¸è§çš„å‹åŠ›æ¥æº å­¦ä¹  éš¾åº¦å¤§ã€è´Ÿæ‹…é‡ ä¸“ä¸šä¸æ»¡æ„ æ•ˆèƒ½ä½ äººé™… ä¸ªäººæƒ…æ„Ÿ åŒå­¦å…³ç³» å¸ˆç”Ÿå…³ç³» å®¶åº­ çˆ¶æ¯å…³ç³» æ•™å…»æ–¹å¼ ç»æµçŠ¶å†µ äº‹ä»¶ å¤±æ‹ã€ä¸§äº² ç¾å®³ å‘å±• å®Œç¾å€¾å‘ ç›®æ ‡ä¸æ¸… ç†æƒ³å’Œç°å®çš„å·®è· ä»€ä¹ˆæ˜¯å‹åŠ› ä¹Ÿå«åº”æ¿€ï¼Œæ˜¯ä¸€ç§ååº”æ¨¡å¼ï¼Œå½“åˆºæ¿€æ—¶é—´æ‰“ç ´äº†æœ‰æœºä½“çš„å¹³è¡¡å’Œç¬¦åˆèƒ½åŠ›ï¼Œæˆ–è€…è¶…è¿‡äº†ä¸ªä½“èƒ½åŠ›æ‰€åŠï¼Œå°±ä¼šè¡¨ç°ä¸ºå‹åŠ›ã€‚\né€šä¿—çš„æ¥è®²ï¼Œå°±æ˜¯é¢å¯¹æŒ‘æˆ˜ã€å¨èƒï¼Œæ‰€æ‹¥æœ‰çš„èµ„æºä¸è¦æ±‚æœ‰æ‰€å·®è·æ—¶å†…åœ¨çš„æ„Ÿå—ã€‚\nå‹åŠ›ä¸‹çš„ååº” ç”Ÿç†ååº”(é•¿æœŸå‹åŠ›ä¸‹èº«ä½“ä¼šæŠ¥è­¦)\næ±—æµé‡å¢åŠ ï¼Œæ¶å¿ƒï¼Œèƒ¸é—·ï¼Œå¤´ç—› èº«ä½“ç–²åŠ³ï¼Œè‚Œè‚‰ç´§å¼ ï¼Œå°¤å…¶æ˜¯å¤´ã€é¢ˆã€è‚©ã€èƒŒçš„ç´§å¼  å¿ƒç‡åŠ å¿«ï¼Œè¡€å‹å¢é«˜ çš®è‚¤å¹²ç‡¥ï¼Œæœ‰æ–‘ç‚¹å’Œåˆºç—›(çš®è‚¤å¯¹å‹åŠ›ç‰¹åˆ«æ•æ„Ÿ) æ¶ˆåŒ–ç³»ç»Ÿé—®é¢˜ï¼Œå¦‚èƒƒç—›ã€æ¶ˆåŒ–ä¸è‰¯ã€è…¹æ³»ã€ä¾¿ç§˜ ç¡çœ ä¸å¥½ï¼Œç²¾ç¥èé¡ï¼Œæ³¨æ„åŠ›å¾ˆéš¾é›†ä¸­ å¿ƒç†ååº”\nç„¦è™‘\nèº«ä½“åº”å¯¹å‹åŠ›çš„ååº”ï¼›å‹åŠ›ä¼šå‘å±•æˆç„¦è™‘ã€‚ ç„¦è™‘æ˜¯ä¸€ç§è¿‡åˆ†æ‹…å¿ƒå’Œå®³æ€•çš„æƒ…ç»ªçŠ¶æ€ï¼Œé€šå¸¸æ¥è‡ªå¯¹æœªæ¥çš„æ‹…å¿ƒã€é”™è¯¯çš„è®¤çŸ¥ã€å¤–éƒ¨çªå‘äº‹ä»¶ã€èº¯ä½“ç–¾ç—…ç­‰ã€‚ çŸ­æš‚çš„ç„¦è™‘å¯¹äººä½“æ²¡æœ‰å±å®³ï¼Œå¯ä»¥ä½œä¸ºä¸€ç§è­¦ç¤ºä¿¡å·ï¼Œå¸®åŠ©äººä½“åº”å¯¹å½“å‰æˆ–å°†è¦å‡ºç°çš„å±é™©çŠ¶å†µ ç„¦è™‘ã€ç´§å¼ ã€è¿·æƒ‘ã€çƒ¦èºã€æ•æ„Ÿã€å–œæ€’æ— å¸¸ ç²¾ç¥ç–²åŠ³ï¼Œé”™è§‰å’Œæ€ç»´æ··ä¹±å¢åŠ  æ„Ÿæƒ…å‹æŠ‘ï¼Œå…´è¶£å’Œçƒ­æƒ…å‡å°‘ï¼ŒåŒå€¦å·¥ä½œ æ„å¿—æ¶ˆæ²‰ï¼Œè‡ªä¿¡å¿ƒä¸è¶³ï¼Œå‡ºç°æ‚²è§‚å¤±æœ›å’Œæ— åŠ©çš„å¿ƒç† çŸ­æœŸå’Œé•¿æœŸè®°å¿†åŠ›å‡é€€ åˆ°çš„å’Œæƒ…æ„Ÿå‡†åˆ™å‰Šå¼± è¡Œä¸ºååº”\næ‹–å»¶\nç‰¹åˆ«è¶Šå—çš„äº‹æƒ…è¶Šæƒ³æ‹–ï¼Œä¸èƒœä»»æ„Ÿï¼Œä¸çŸ¥é“å¦‚ä½•åš å®³æ€•å¤±è´¥ åæœ: è‡ªè´£ã€æ‡Šæ‚”ã€éš¾å—ã€ç—›è‹¦ï¼Œå½±å“ä»»åŠ¡å®Œæˆçš„å®é™…æ•ˆæœã€‚å¤œä¸èƒ½å¯ï¼Œé£Ÿä¹‹æ— å‘³ã€‚ å·¥ä½œæ‡ˆæ€ ã€èƒ½åŠ›é™ä½ï¼Œé”™è¯¯ç‡å¢åŠ ã€‚ æ”¾çºµè‡ªå·±ï¼Œè‡ªæš´è‡ªå¼ƒ æ²¡èƒƒå£ï¼Œåƒå¾—å°‘ï¼Œä½“é‡è¿…é€Ÿä¸‹é™ å­¤åƒ»ã€æŠ‘éƒã€è‡ªé—­ã€çƒ¦èºä¸å®‰ å†’é™©è¡Œä¸ºå¢åŠ ï¼ŒåŒ…æ‹¬ä¸é¡¾åæœçš„é©¾è½¦å’ŒèµŒåš æ”»å‡»ã€ä¾µçŠ¯ä»–äººï¼Œç ´åå…¬å…±è´¢äº§ ä¸å®¶åº­å’Œæœ‹å‹çš„å…³ç³»æ¶åŒ– è‡ªæ€æˆ–ä¼å›¾è‡ªæ€ æˆ˜æ–—\nåŠªåŠ›å­¦ä¹ ï¼Œæ‹¼ç»©ç‚¹ï¼Œå…³æ³¨ä»–äºº åŠªåŠ›èå…¥å……æ»¡æŒ‘æˆ˜çš„æ–°ç¯å¢ƒ åŠªåŠ›å’ŒåŒå­¦å»ºç«‹å…³ç³» ä¸»åŠ¨åˆ†æå‹åŠ›æº: æ˜ç¡®é—®é¢˜æ‰€åœ¨ï¼ŒæŒ‡å®šè§£å†³æ–¹æ¡ˆ å¯»æ±‚å¤–éƒ¨æ”¯æŒ: å‘ä»–äººæ±‚åŠ©æˆ–è·å–èµ„æº æƒ…ç»ªå®£æ³„: é€šè¿‡åˆç†æ–¹å¼é‡Šæ”¾å‹åŠ› å‹åŠ›æœ¬èº«ä¸æ˜¯é—®é¢˜ï¼Œå¦‚ä½•çœ‹å¾…å‹åŠ›æ‰æ˜¯é—®é¢˜ æŠŠå‹åŠ›çœ‹ä½œåŠ©åŠ›çš„è¯ï¼Œç”Ÿç†ä¼šå‘ç”Ÿå˜åŒ–\nå‹åŠ›é€‚å½“ç†è®ºï¼ŒAndersonï¼Œ1987\nä¸€ä¸ªæ¦‚å¿µï¼šä¹ å¾—æ€§æ— åŠ©\nå‹åŠ›åº”å¯¹æ¨¡å‹\næƒ…æ„Ÿæƒ…ç»ªåº”å¯¹\nå†²åŠ¨ç¬¬ä¸€æ­¥ï¼šè¯†åˆ« å†²åŠ¨ç¬¬äºŒæ­¥ï¼šçœ‹çœ‹å‘¨å›´æœ‰ä»€ä¹ˆç‰©å“å¯ä»¥è®©è‡ªå·±æŠ“ä½ å†²åŠ¨ç¬¬ä¸‰éƒ¨ï¼šåšå‡ºé€‰æ‹©(ç«‹è¶³æ­¤æ—¶æ­¤åˆ») æ­£å¿µ STOP: åœæ­¢ - å‘¼å¸ - è§‰å¯Ÿ(å¼€æ”¾/èšç„¦) - ç»§ç»­\nè®¤çŸ¥è¡Œä¸ºåº”å¯¹\nABCDEF è®¤çŸ¥ç®¡ç†æŠ€æœ¯\nA. äº‹ä»¶ B. æ—§è®¤è¯† C. ä¸è‰¯æƒ…ç»ª D. è¾©é©³ E. æ–°è®¤è¯† F. æƒ…ç»ªæ”¹å–„ ABC æ˜¯ä¸€ç§â€æƒ¯æ€§â€\nè°ƒæ•´è®¤çŸ¥è¯„ä¼°æ–¹å¼\næ”¹å˜ä½ ä¸åº”æ¿€æºè¯„ä»·çš„å…³ç³» æˆ‘ä»¬è¶Šæ˜¯è®¤åŒè¿™ä¸ªæ ‡ç­¾ï¼Œè¶Šæ˜¯æ— æ³•åŒºåˆ†å½¼æ­¤ï¼Œä¹Ÿå°±è¶Šä¸å¯èƒ½è®¤ä¸ºè‡ªå·±èƒ½å¤Ÿè¶…è¶Šè¿™ä¸ªæ ‡ç­¾ã€‚å› æ­¤æ ‡ç­¾ç»è¿‡äº†éªŒè¯æˆ‘æ˜¯å¤±è´¥çš„ï¼Œä¹Ÿæˆäº†ä¸å»è¿›è¡Œä¸€ç³»åˆ—é‡è¦è€Œæœ‰æ„ä¹‰æ´»åŠ¨çš„ç†ç”±ã€‚ æ˜ç¡®ç›®æ ‡æ˜¯ä»€ä¹ˆ å»ºç«‹å¯¹åº”æ¿€æºçš„çŸ¥è§‰æ§åˆ¶ ä½ å¯¹äºæ”¹å˜äº‹ä»¶æˆ–ç»å†çš„è¿›ç¨‹æˆ–ç»“æœçš„ä¿¡å¿µ æ‘’å¼ƒéç†æ€§ä¿¡å¿µ ä¸è¦é«˜ä¼°æˆ–è€…ä½ä¼°ç›®å·±çš„èƒ½åŠ› è®¤è¯†è‡ªå·±çš„é™åˆ¶ã€é•¿å¤„åŠå¼±ç‚¹ ä¿æŒå¼€æ”¾æ€§è¯„ä»· å¤„ç†äº‹æƒ…ä¿æŒå¼¹æ€§ å½¢æˆæ­£ç¡®çš„å½’å› æ–¹å¼ å…·ä½“æœ‰æ•ˆçš„è¡ŒåŠ¨æ‰èƒ½ç¼“è§£å‹åŠ›\næ§åˆ¶è‡ªå·±çš„è¡ŒåŠ¨ï¼Œåšé‚£äº›è®©è‡ªå·±çš„ç”Ÿæ´»å°½å¯èƒ½ç¾å¥½çš„äº‹æƒ… å»ºç«‹å¹¶æŒç»­æ”¹å–„ç¤¾ä¼šæ”¯æŒç³»ç»Ÿ\nç¤¾ä¼šèµ„æº\nç¬¬ä¸€å±‚: è¿‘äº² ç¬¬äºŒå±‚: çŸ¥å·±å¥½å‹ ç¬¬ä¸‰å±‚: ä¸€èˆ¬æœ‹å‹ã€ç¤¾ä¼šæœºæ„ ä¸»åŠ¨æ±‚åŠ©ï¼Œå–„äºæ±‚åŠ©ï¼šè‡ªåŠ©æ˜¯ä¸€ç§èƒ½åŠ› ç»´æŠ¤ç°æœ‰çš„ç¤¾ä¼šæ”¯æŒç³»ç»Ÿ åŠ æ·±æ”¯æŒæ€§äººé™…å…³ç³»ï¼šå­¦ä¹ ä»è‰¯å¥½çš„äººé™…å…³ç³»ä¸­è·å¾—æ¸©æš–ã€çˆ±ã€å½’å±ã€å®‰å…¨æ„Ÿ æ”¾æ¾è®­ç»ƒ\nèº«ä½“åº”å¯¹\nå‘¼å¸è°ƒè§£æ³• è…¹å¼å‘¼å¸ è‚Œè‚‰æ¾å¼›æ³• æ¸è¿›å¼è‚Œè‚‰æ”¾æ¾ è¿åŠ¨ 40minæœ‰æ°§è¿åŠ¨ 1wæ­¥ å¿«èµ°ã€çˆ¬æ¥¼ ç¡çœ è°ƒèŠ‚ 7ï½9h æœ‰æ¡ä»¶åˆä¼‘ 15ï½30min å°†å‹åŠ›è½¬åŒ–æˆåˆ›é€ åŠ›çš„æœ€å¥½æ–¹å¼ å¤§å­¦ç”Ÿäººé™…äº¤å¾€å’Œæ²Ÿé€š å¤§å­¦ç”Ÿäººé™…äº¤å¾€ä¸­çš„å¸¸è§é—®é¢˜ ä¸æ•¢äº¤å¾€ ä¸ä¼šäº¤å¾€ ä¸æƒ³äº¤å¾€ ä¸è‰¯äº¤å¾€ æ¦‚å¿µ äººé™…äº¤å¾€: ç¤¾ä¼šç”Ÿæ´»ã€æ´»åŠ¨è¿‡ç¨‹ä¸­ï¼Œäººä¸äººä¹‹é—´çš„ä¿¡æ¯äº¤æµã€å¿ƒç†äº¤æµåŠç›¸äº’ä½œç”¨çš„è¿‡ç¨‹ï¼Œä¸€èˆ¬è®¤ä¸ºæ˜¯åŠ¨æ€è¿‡ç¨‹ã€‚ äººé™…å…³ç³»: é€šè¿‡äººé™…äº¤å¾€è€Œå½¢æˆçš„äººä¸äººä¹‹é—´çš„ç¨³å®šçš„åœ¨å¿ƒç†æˆ–è¡Œä¸ºäº§ç”Ÿç›¸äº’å½±å“çš„è¿‡ç¨‹ï¼Œä¸€èˆ¬è®¤ä¸ºæ˜¯é™æ€è¿‡ç¨‹ã€‚ ä¸ºä»€ä¹ˆæœ‰äººé™…å…³ç³» åŸƒé‡Œå…‹æ£®äººæ ¼å…«é˜¶æ®µå‘å±•ç†è®º æˆ‘ä»¬å¤„äºæˆå¹´æ—©æœŸï¼Œä»»åŠ¡æ˜¯å»ºç«‹äº²å¯†å…³ç³»(çŸ›ç›¾æ˜¯äº²å¯†å¯¹å­¤ç‹¬) å¦‚æœä¸€ä¸ªäººä¸èƒ½ä¸ä»–äººåˆ†äº«å¿«ä¹ä¸ç—›è‹¦ï¼Œä¸èƒ½ä¸ä»–äººè¿›è¡Œæ€æƒ³æƒ…æ„Ÿçš„äº¤æµï¼Œä¸äº’ç›¸å…³å¿ƒä¸å¸®åŠ©ï¼Œå°±ä¼šé™·å…¥å­¤ç‹¬å¯‚å¯çš„è‹¦æ¼æƒ…å¢ƒä¹‹ä¸­ è‰¯å¥½äººé™…å…³ç³»çš„æ„ä¹‰ å¤§å­¦ç”Ÿæ­£å¤„åœ¨ä¸€ç§æ¸´æ±‚äº¤å¾€ï¼Œæ¸´æ±‚ç†è§£çš„å¿ƒç†å‘å±•æ—¶æœŸã€‚\nå¤§å­¦ç”Ÿèº«å¿ƒå¥åº·çš„éœ€è¦\nâ€œäººé™…å‰¥å¤ºâ€å®éªŒ æ˜¯è·å¾—å®‰å…¨æ„Ÿå’Œå¹¸ç¦çš„éœ€è¦\né©¬æ–¯æ´›éœ€æ±‚å±‚æ¬¡ç†è®º å“ˆå¤šå¤§å­¦ç ”ç©¶é™¢çš„å®éªŒ å­¤ç‹¬æœ‰å®³å¥åº·ï¼Œè‰¯å¥½çš„äººé™…å…³ç³»è®©äººæ›´é•¿å¯¿ï¼Œæ›´å¹¸ç¦ äººé™…å…³ç³»æ›´åœ¨äºè´¨é‡ï¼Œé…å¶å…³ç³»(æœ€é‡è¦) æ˜¯äººå‘å±•ä¸æˆåŠŸçš„é‡è¦ä¿è¯\näººä¸€ç”Ÿæˆé•¿ã€å‘å±•å’ŒæˆåŠŸï¼Œæ— ä¸ä¸åŒä»–äººçš„äº¤å¾€æƒ³è”ç³»ï¼Œå¹¶ä¸”é€šè¿‡ä»äººé™…å…³ç³»ä¸­å¾—åˆ°ä¿¡æ¯ã€æœºé‡ï¼Œå¸®åŠ©äººä»¬èµ°ä¸Šä¸€æ¡æˆåŠŸä¹‹è·¯ã€‚\näººé™…å…³ç³»çš„å»ºç«‹ä¸å‘å±•çš„è¿‡ç¨‹ å®šå‘é˜¶æ®µ - æƒ…æ„Ÿæ¢ç´¢é˜¶æ®µ - æƒ…æ„Ÿäº¤æµé˜¶æ®µ - ç¨³å®šäº¤æµé˜¶æ®µ\né¡ºåºä¸å¯é€† æ—¶é—´å¯èƒ½é•¿çŸ­ä¸ä¸€ èƒ½åˆ°æƒ…æ„Ÿäº¤æµé˜¶æ®µå·²ç»éå¸¸å¥½äº† äººé™…äº¤å¾€ä¸­çš„å¿ƒç†å­¦æ•ˆåº” é¦–å› æ•ˆåº”: ä¹Ÿç§°ç¬¬ä¸€å°è±¡ï¼Œæ˜¯æŒ‡åˆæ¬¡è§é¢æ—¶å¯¹äººå½¢æˆçš„é²œæ˜å°è±¡ï¼Œè¿™ç§ç”±å…ˆå‰çš„ä¿¡æ¯è€Œå½¢æˆçš„æœ€åˆçš„å°è±¡åŠå…¶å¯¹åæ¥ä¿¡æ¯çš„å½±å“å³ä¸ºé¦–å› æ•ˆåº”ã€‚æœ‰å…ˆå…¥ä¸ºä¸»çš„ä½œç”¨ã€‚ è¦æ‡‚å¾—é€šè¿‡ç°è±¡çœ‹æœ¬è´¨ï¼Œä¸è¦è¢«å¯¹æ–¹çš„ç¬¬ä¸€å°è±¡æ‰€è¿·æƒ‘ã€‚ è¿‘å› æ•ˆåº”: ä¹Ÿç§°æœ€è¿‘å°è±¡ï¼Œæ˜¯æŒ‡æœ€è¿‘è·å¾—çš„ä¿¡æ¯å¯¹äººçš„çŸ¥è§‰å’Œè®¤è¯†äº§ç”Ÿçš„å¼ºçƒˆå½±å“ï¼Œä¸»è¦å‘ç”Ÿåœ¨ä¸ç†Ÿæ‚‰çš„äººçš„äº¤å¾€ä¹‹ä¸­ã€‚æœ€åç•™ä¸‹çš„å°è±¡ï¼Œå¾€å¾€æ˜¯æœ€æ·±åˆ»çš„å°è±¡ã€‚ ä¸äººäº¤å¾€ä¸èƒ½è¿›æ ¹æ®ä¸€æ—¶ä¸€äº‹å»è¯„ä»·ä»–äººï¼Œè¢«æš‚æ—¶çš„ã€ä¸ªåˆ«çš„è¡Œä¸ºæ‰€è¿·æƒ‘ã€‚ æ™•è½®æ•ˆåº”: ä¹Ÿç§°å…‰ç¯æ•ˆåº”ï¼Œæ˜¯æŒ‡åœ¨äººé™…äº¤å¾€ä¸­ä»…ä»…ä¾æ®æŸäººèº«ä¸Šä¸€ç§æˆ–å‡ ç§ç‰¹å¾æ¥æ¦‚æ‹¬å…¶ä»–ä¸€äº›æœªæ›¾äº†è§£çš„äººæ ¼ç‰¹å¾çš„å¿ƒç†å€¾å‘ã€‚ ä¸å¯ä»¥ä»¥åæ¦‚å…¨ï¼Œä¸ä»…è¦å¬ä»å¿ƒçš„å£°éŸ³ï¼Œä¹Ÿè¦å¬ä»å¤§è„‘çš„å£°éŸ³ã€‚ åˆ»æ¿æ•ˆåº”: åˆ»æ¿æ•ˆåº”åˆç§°å®šå‹æ•ˆåº”ï¼Œæ˜¯æŒ‡äººä»¬ç”¨åˆ»å°åœ¨è‡ªå·±å¤´è„‘ä¸­çš„å…³äºæŸäººã€æŸäº‹ç‰©çš„å›ºå®šå°è±¡ï¼Œä»¥æ­¤ä½œä¸ºåˆ¤æ–­å’Œè¯„ä»·äººä¾æ®çš„å¿ƒç†ç°è±¡ã€‚åœ¨äººé™…äº¤å¾€ä¸­ï¼Œåˆ»æ¿æ•ˆåº”å¸¸ä½¿äººä»¬å¯¹ä»–äººçš„è®¤çŸ¥å›ºå®šåŒ–ã€‚ â€œäººå¿ƒä¸åŒï¼Œå„å¦‚å…¶é¢â€ï¼Œåˆ»æ¿å°è±¡æ˜¯ä¸€ç§æ¦‚æ‹¬è€Œç¬¼ç»Ÿçš„çœ‹æ³•ï¼Œå¹¶ä¸èƒ½ä»£æ›¿æ´»ç”Ÿç”Ÿçš„ä¸ªä½“ï¼Œä¸äººäº¤å¾€ä¸èƒ½â€œä»¥åæ¦‚å…¨ï¼Œä¸èƒ½æˆ´ç€â€œæœ‰è‰²çœ¼é•œâ€å»çœ‹äººã€‚ æŠ•å°„æ•ˆåº”: æ˜¯æŒ‡ä»¥å·±åº¦äººï¼Œè®¤ä¸ºè‡ªå·±å…·æœ‰æŸç§ç‰¹æ€§ï¼Œä»–äººä¹Ÿä¸€å®šä¼šæœ‰ä¸è‡ªå·²ç›¸åŒçš„ç‰¹æ€§ï¼ŒæŠŠè‡ªå·±çš„æ„Ÿæƒ…ã€æ„å¿—ã€ç‰¹æ€§æŠ•å°„åˆ°ä»–äººèº«ä¸Šå¹¶å¼ºåŠ äºäººçš„ä¸€ç§è®¤çŸ¥éšœç¢ã€‚ æ„Ÿæƒ…æŠ•å°„ï¼šå³è®¤ä¸ºåˆ«äººçš„å–œå¥½ä¸è‡ªå·±ç›¸åŒï¼Œå°†è‡ªå·±çš„æ€ç»´æ–¹å¼å¼ºåŠ ç»™å¯¹æ–¹ è®¤çŸ¥ç¼ºä¹å®¢è§‚æ€§ï¼šæŠŠè‡ªå·±çš„æ„Ÿæƒ…æŠ•å°„åˆ°ä»–äººæˆ–äº‹ç‰©ä¹‹ä¸Šï¼Œè®¤ä¸ºè‡ªå·±å–œæ¬¢çš„äººæˆ–ç‰©éƒ½æ˜¯ç¾å¥½çš„ï¼Œè‡ªå·±åŒæ¶çš„éƒ½æ˜¯ä¸‘é™‹çš„ï¼Œâ€œä»¥å°äººä¹‹å¿ƒåº¦å›å­ä¹‹è…¹â€ çš®é©é©¬åˆ©ç¿æ•ˆåº”(ç½—æ£®å¡”å°”æ•ˆåº”): äº¦ç§°â€œç½—æ£®å¡”å°”æ•ˆåº”â€æˆ–â€œæœŸå¾…æ•ˆåº”â€ï¼Œä½ æœŸæœ›ä»€ä¹ˆï¼Œä½ å°±ä¼šå¾—åˆ°ä»€ä¹ˆï¼Œä½ å¾—åˆ°çš„ä¸æ˜¯ä½ æƒ³è¦çš„ï¼Œè€Œæ˜¯ä½ æœŸå¾…çš„ã€‚æœ‰ç¾å›½è‘—åå¿ƒç†å­¦å®¶ç½—æ£®å¡”å°”æå‡ºã€‚ ç»ƒä¹ é¢˜\nç­”æ¡ˆæ˜¯: é©¬æ–¯æ´› äº²å¯†å¯¹å­¤ç‹¬ æ™•è½®æ•ˆåº” æ™•è½®æ•ˆåº” é¦–å› æ•ˆåº” è¦åˆ†æ¸…è‡ªå·±çš„æƒ³æ³•å’Œä»–äººçš„æƒ³æ³•\näººé™…äº¤å¾€çš„åŸåˆ™ çœŸè¯šå®ˆä¿¡åŸåˆ™ å°Šé‡å¹³ç­‰åŸåˆ™ ä½ å¥½æˆ‘ä¹Ÿå¥½ äº’åŠ©äº’æƒ åŸåˆ™ å°Šé‡è·ç¦»åŸåˆ™ å…¬å…±è·ç¦»åŒº \u0026gt; 4m ç¤¾äº¤è·ç¦»åŒº 1.3 ~ 4m ä¸ªä½“è·ç¦»åŒº 0.5 ~ 1.3m äº²å¯†è·ç¦»åŒº 0 ~ 0.5m äººé™…äº¤å¾€çš„æ³•åˆ™ é»„é‡‘æ³•åˆ™: ä½ æƒ³åˆ«äººæ€ä¹ˆå¯¹ä½ ï¼Œä½ å°±æ€ä¹ˆå¯¹åˆ«äºº ç™½é‡‘æ³•åˆ™: åˆ«äººå¸Œæœ›ä½ æ€ä¹ˆæ ·å¯¹å¾…ä»–ä»¬ï¼Œä½ å°±æ€ä¹ˆå¯¹å¾…ä»–ä»¬ åé»„é‡‘æ³•åˆ™: æˆ‘æ€ä¹ˆå¯¹åˆ«äººï¼Œåˆ«äººå°±åº”è¯¥æ€ä¹ˆå¯¹æˆ‘ æŠ€å·§ æŠ€å·§ä¸€ï¼šä¸æ‹¿è‡ªå·±çš„æ ‡å‡†è¦æ±‚åˆ«äºº â€œåº”è¯¥ã€å¿…é¡»ã€ä¸€å®šè¦çš„ç»å¯¹è¯è¦æ±‚â€ ä¸ç®¡è¿™äº›è§„åˆ™åœ¨å¤§å¤šæ•°æ—¶å€™æœ‰å¤šç²¾å‡†ï¼Œæˆ‘ä»¬å¿…é¡»æ„è¯†åˆ°ï¼Œå®ƒåªæ˜¯æˆ‘ä»¬å•æ–¹é¢çš„æœŸå¾…ï¼Œæœ‰æ—¶å€™ç”šè‡³æ˜¯å¹»æƒ³ã€‚ ä½ å¯ä»¥æ‰“ç ´è§„åˆ™ï¼Œä¸å¿…éµå®ˆåˆ«äººå¯¹ä½ çš„ã€Œé¢„æœŸã€ã€‚ä½ æ— éœ€è¦æ±‚è‡ªå·±æŒ‰åˆ«äººæœŸå¾…çš„ååº”æ–¹å¼åŒºååº”ã€‚ æŠ€å·§äºŒï¼šåšå¥½æ ¸å¯¹(å¤„ç†æƒ…ç»ªå†…è€—æœ€å¥½çš„æ–¹å¼) æ ¸å¯¹ä¸ä»…èƒ½å¤Ÿé¿å…è¯¯ä¼šï¼Œè¿˜èƒ½æœ‰æ•ˆä¿ƒæˆè‰¯å¥½æ²Ÿé€šã€‚ å°Šé‡è‡ªå·±æ„Ÿå—ï¼Œå‡å°‘è‡ªå·±çš„ä¸èˆ’æœ æ²Ÿé€šé—´çš„æ ¸å¯¹ï¼Œæ˜¯æ ¸å¯¹å¯¹æ–¹çš„æƒ³æ³•æ˜¯å¦å’Œä½ çŒœæµ‹çš„ä¸€è‡´ æ²Ÿé€šä¸­å°½åŠ›åšåˆ°å¼€æ”¾ã€ä¸è¯„åˆ¤ã€ä»¥åŠè¡¨è¾¾çœŸå®æ„Ÿå— äººé™…äº¤å¾€çš„æ ¸å¿ƒâ€”â€”æ²Ÿé€š æ¥çº³ æ²Ÿé€šçš„å‰æ\nå­¦ä¼šå€¾å¬\nä»¥è‡ªå·±ä¸ºä¸­å¿ƒçš„å‡å€¾å¬è€…\næ™ºè€… ä½ åº”è¯¥æŒ‰æˆ‘çš„åš ä¹è§‚è€… è¿™æ²¡æœ‰é‚£ä¹ˆæ—©ï¼Œè‡³å°‘ä½ è¿˜æ²¡å’Œä»–ç»äº¤ ä¹Œé¸¦å˜´ é‚£å¯æƒ¨äº†ï¼Œä»–ä¼šä¸ä¼šå»è¯´ä½ åè¯å•Š å…«å¦è€… å¿«å’Œæˆ‘è¯´è¯´ï¼Œä½ ä»¬æ˜¯æ€ä¹ˆåµçš„ ä¸»è§’ ä½ è¿™ä¸ç®—ä»€ä¹ˆï¼Œä»¥å‰æˆ‘å’Œäººåµæ¶â€¦â€¦ æ®µä½ï¼Ÿå±‚æ¬¡ï¼Ÿ\nç¬¬ä¸€å±‚: å¿ƒä¸åœ¨ç„‰ ç¬¬äºŒå±‚: æ¶ˆæåœ°å¬ ç¬¬ä¸‰å±‚: é€‰æ‹©æ€§å¬ ç¬¬å››å±‚: ä¸“æ³¨è†å¬ ç¬¬äº”å±‚: ç§¯æè†å¬ å…±æƒ…\nå…³æ³¨æƒ…ç»ª: æŠŠå¼ºè¿«æ€§å»ºè®®æ”¹æˆä¸å¯¹æ–¹æƒ…ç»ªåŒæ­¥çš„è¯è¯­ã€‚ å¼ºè¿«æ€§å»ºè®® ä¸å¯¹æ–¹æƒ…ç»ªåŒæ­¥çš„è¯è¯­ è¿™ç®—ä»€ä¹ˆ ä½ ç»å†äº†é‚£ä¹ˆå¤šï¼Œä½ å·²ç»å¾ˆå‹‡æ•¢äº† ä¸è¦æ¶ˆæ ç—›è‹¦æ˜¯ç”Ÿæ´»çš„ä¸€éƒ¨åˆ†ï¼Œæ˜¯ä¸ªäººéƒ½è¦ç»å† æ²¡æœ‰ä»€ä¹ˆè¿‡ä¸å»çš„ è¿™æ®µç»å†å¯¹ä½ æ¥è¯´ç¡®å®å¾ˆéš¾ ä½ å¼€å¿ƒç‚¹ï¼Œåˆ«å¤ªæ‹…å¿ƒ æˆ‘çœ‹ä½ æœ€è¿‘å‹åŠ›å¾ˆå¤§ï¼Œæœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®ä½  ä½ å¾—ä¹è§‚ç‚¹ æ— è®ºå¥½åæˆ‘éƒ½ä¼šæ”¯æŒä½  æå‡å€¾å¬æŠ€å·§çš„ 3F æ¨¡å‹\näº‹å® Fact\nåˆ†æ¸…äº‹å® å¯¹æ–¹é™ˆè¿°äº†ä»€ä¹ˆäº‹å®\næƒ…ç»ª Feel\næ„Ÿå—æƒ…ç»ª å¯¹æ–¹è¡¨è¾¾äº†ä»€ä¹ˆæƒ…ç»ª\næœŸå¾… Focus\nç†è§£æ„å›¾ å¯¹æ–¹æœŸå¾…æˆ‘åšä»€ä¹ˆè¡ŒåŠ¨\nåå‘ä½¿ç”¨ 3F\næƒ…ç»ª Feel\nå“åº”æƒ…ç»ª æ¥çº³å¯¹æ–¹çš„æƒ…ç»ª\näº‹å® Fact\nç¡®è®¤äº‹å® é€šè¿‡å¤æ•°ç¡®è®¤äº‹å®æˆ–å¾—åˆ°ä¿¡æ¯è¡¥å……\næ„å›¾ Focus\næ˜ç¡®æ„å›¾ æŠŠå¯¹æ–¹çš„æœŸå¾…ç¿»è¯‘æˆå¯å®æ–½çš„è¡ŒåŠ¨\nå¥½çš„å€¾å¬ = å¿ƒé‡Œå¬è¿›å» + æ„¿æ„å¬çš„å§¿æ€ + æ°åˆ°å¥½å¤„çš„åé¦ˆ\n60åˆ† å¤è¯»æœº 70åˆ† æƒ…æ„Ÿé•œå­ 80åˆ† æ”¯å‡ºå¸Œæœ›å’ŒæœŸå¾… 90åˆ† è¡¨è¾¾å…³å¿ƒï¼Œå…±åŒè§£å†³ å­¦ä¼šè¡¨è¾¾\næè¿°äº‹å®(è§‚å¯Ÿ)â€”â€”æˆ‘çœ‹åˆ°â€¦â€¦ è¡¨è¾¾æ„Ÿå—(æ„Ÿå—)â€”â€”æˆ‘è§‰å¾—â€¦â€¦ è¡¨è¾¾éœ€æ±‚(éœ€è¦)â€”â€”æˆ‘å¸Œæœ›å¾—åˆ°â€¦â€¦ æå‡ºè¯·æ±‚(è¯·æ±‚)â€”â€”ä½ å¯ä»¥â€¦â€¦å— è¡¨è¾¾è‡ªå·±çš„æƒ…æ„Ÿå°±æ˜¯è®©åˆ«äººâ€œçœ‹è§â€è‡ªå·±å†…å¿ƒæ´»åŠ¨çš„è¿‡ç¨‹ã€‚\nå­¦ä¹ è¯´è¯çš„è‰ºæœ¯\nç¬¬ä¸€ä»¶äº‹\næ€¥äº‹ï¼Œæ…¢æ…¢çš„è¯´\nå¤§äº‹ï¼Œæ¸…æ¥šçš„è¯´\nå°äº‹ï¼Œå¹½é»˜çš„è¯´\nç¬¬äºŒä»¶äº‹\næ²¡æŠŠæ¡çš„äº‹ï¼Œè°¨æ…çš„è¯´\næ²¡å‘ç”Ÿçš„äº‹ï¼Œä¸è¦èƒ¡è¯´\nåšä¸åˆ°çš„äº‹ï¼Œåˆ«ä¹±è¯´\nä¸Šæµ·äººçš„äº‹ï¼Œä¸èƒ½è¯´\nç¬¬ä¸‰ä»¶äº‹\nè®¨åŒçš„äº‹ï¼Œå¯¹äº‹ä¸å¯¹äººçš„è¯´\nå¼€å¿ƒçš„äº‹ï¼Œçœ‹åœºåˆè¯´\nä¼¤å¿ƒçš„äº‹ï¼Œä¸è¦è§äººå°±è¯´\nåˆ«äººçš„äº‹ï¼Œå°å¿ƒçš„è¯´\n","date":"2025-06-09T21:18:01+08:00","permalink":"https://invalidnamee.github.io/p/xinli-note/","title":"å¿ƒç†ç¬”è®°"},{"content":"A. è¯„ä¼° å…³é”®åœ¨äº \\(|a_i| \\le 1000\\)ï¼Œæ‰€ä»¥å¯ä»¥å¼€ä¸€ä¸ªé•¿åº¦ä¸º 2000 çš„æ•°ç»„ç»Ÿè®¡ä¸€ä¸‹æ¯ä¸ªå€¼çš„ä¸ªæ•°ï¼Œç„¶å \\(\\Theta(n^2)\\) å¤„ç†è¿™ä¸ª 2000 çš„æ•°ç»„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 2010; int a[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); a[t + 1000]++; } long long res = 0; for (int i = 0; i \u0026lt;= 2000; ++i) { for (int j = i + 1; j \u0026lt;= 2000; ++j) { res += (long long)a[i] * a[j] * (i - j) * (i - j); } } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } B. æ‹†åˆ†æ•°å­— è®° n åœ¨ä¸‰è¿›åˆ¶è¡¨ç¤ºä¸‹çš„å„ä½æ•°ä¹‹å’Œä¸º tï¼Œæƒ³è¦æ»¡è¶³è¦æ±‚çš„å……è¦æ¡ä»¶æ˜¯ \\(t \\le k \\le n\\ \\land\\ t \\equiv k\\ (mod\\ 2)\\).\né¦–å…ˆè€ƒè™‘è¾¹ç•Œæƒ…å†µï¼Œå¦‚æœå…¨ç”¨ 1 é‚£ä¹ˆéœ€è¦ n ä¸ªï¼›å¦‚æœé€‰æ‹©æœ€ä¼˜æ–¹æ¡ˆï¼Œå…¨éƒ¨æŒ‰ç…§ä¸‰è¿›åˆ¶çš„è¡¨ç¤ºé‚£ä¹ˆéœ€è¦ t ä¸ªï¼›\nå…¶æ¬¡è€ƒè™‘å†…éƒ¨ï¼ŒæŒ‰ç…§è¦æ±‚ï¼Œæ— è®ºæ€ä¹ˆæ‹†ï¼Œä¸€ä¸ª 3 çš„å¹‚åªèƒ½æ‹†æˆå¥‡æ•°ä¸ªæ›´å°çš„å¹‚ï¼Œæ‰€ä»¥æœ€ä¼˜æ–¹æ¡ˆæ‹†å‡ºæ¥çš„ä¸ªæ•°çš„å¥‡å¶æ€§å’Œä»»ä½•æ–¹æ¡ˆçš„å¥‡å¶æ€§ç›¸åŒã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { long long n, k; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;k); long long bit = 0; bool f = false; while (n) { f ^= (n % 3) \u0026amp; 1; bit += n % 3; n /= 3; } if (bit \u0026lt;= k \u0026amp;\u0026amp; !(f ^ (k \u0026amp; 1))) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); } return 0; } C. éœ²è¥ æ¯”è¾ƒæ°´ï¼Œç›´æ¥æšä¸¾ä¸€ä¸ªä¸­é—´ç‚¹å‘ä¸‰ä¸ªç‚¹åˆ†åˆ«è¿çº¿å°±è¡Œã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; int dis(pair\u0026lt;int, int\u0026gt; a, pair\u0026lt;int, int\u0026gt; b) { return abs(a.first - b.first) + abs(a.second - b.second); } int main() { pair\u0026lt;int, int\u0026gt; a[3]; for (int i = 0; i \u0026lt; 3; ++i) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[i].first, \u0026amp;a[i].second); int res = 0x3f3f3f3f; for (int i = 0; i \u0026lt;= 1000; ++i) { for (int j = 0; j \u0026lt;= 1000; ++j) { pair\u0026lt;int, int\u0026gt; cur = {i, j}; res = min(res, dis(cur, a[0]) + dis(cur, a[1]) + dis(cur, a[2]) + 1); } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } D. å¯»å® æ€è·¯æ¯”è¾ƒç®€å•ï¼Œå®é™…æ“ä½œæœ‰ç‚¹å¤æ‚\nèƒ½æ”¾æ³•æœ¯ä¸€å®šæ˜¯æœ€å¼€å§‹è¿ç»­æ”¾ï¼Œè®©å‰é¢éƒ½æ˜¯ aï¼Œæ‰€ä»¥å…ˆåšä¸€ä¸ªäºŒç»´ dp æ±‚å‡ºæ¥å·¦ä¸Šè§’åˆ°æ¯ä¸ªç‚¹è·¯å¾„ä¸Šæœ€å¤š a çš„ä¸ªæ•°ã€‚\néå†ä¸€é dp çš„æ•°ç»„ï¼Œæ‰¾åˆ°èƒ½è¾¾åˆ°æœ€é•¿ a çš„ä½ç½®ï¼ˆå¯ä»¥æ˜¯å¤šä¸ªï¼‰ï¼Œä»æ¯ä¸ªä½ç½®è·‘è®°æœï¼ˆåæ‹“æ‰‘åºdpï¼‰ï¼Œdp å‡ºåç»­çš„æœ€ä¼˜è·¯çº¿ã€‚\nè¿™é“é¢˜éœ€è¦æ³¨æ„çˆ†ç©ºé—´çš„é—®é¢˜ï¼Œä¸èƒ½æ¯ä¸ªç‚¹éƒ½å­˜å­—ç¬¦ä¸²ï¼Œåº”è¯¥å­˜ä¸€ä¸ªæ–¹å‘æˆ–è€…ä¸‹ä¸€ä¸ªç‚¹çš„ä½ç½®ï¼Œæ¯”è¾ƒå­—å…¸åºçš„æ—¶å€™æŒ‰ç…§è®°å½•çš„ä¿¡æ¯é€’å½’æ¯”è¾ƒã€‚\nå¦å¤–è¿˜è¦ç‰¹åˆ¤\nå¦‚æœä¸€å¼€å§‹å°±æ²¡æœ‰ aï¼Œä¹Ÿä¸èƒ½æ–½æ³•çš„æƒ…å†µã€‚\nk å¤ªå¤§çš„æƒ…å†µã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 1010; char a[N][N]; int f[N][N]; int n, k; bool vis[N][N], ne[N][N]; // 0 ä¸‹ 1 å³ bool le(int x1, int y1, int x2, int y2) { while (x1 != n || y1 != n) { if (a[x1][y1] != a[x2][y2]) return a[x1][y1] \u0026lt; a[x2][y2]; else { bool flag = ne[x1][y1]; x1 = flag ? x1 : x1 + 1, y1 = flag ? y1 + 1 : y1; flag = ne[x2][y2]; x2 = flag ? x2 : x2 + 1, y2 = flag ? y2 + 1 : y2; } } return true; // ç›¸ç­‰ï¼Œéšä¾¿äº† } void dp(int x, int y) { if (vis[x][y]) return; vis[x][y] = true; if (x == n \u0026amp;\u0026amp; y != n) { dp(x, y + 1); ne[x][y] = 1; } else if (x != n \u0026amp;\u0026amp; y == n) { dp(x + 1, y); ne[x][y] = 0; } else if (x != n \u0026amp;\u0026amp; y != n) { dp(x + 1, y), dp(x, y + 1); if (le(x + 1, y, x, y + 1)) ne[x][y] = 0; else ne[x][y] = 1; } } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%s\u0026#34;, a[i] + 1); } int mxd = 0; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { f[i][j] = max(f[i - 1][j], f[i][j - 1]) + (a[i][j] == \u0026#39;a\u0026#39;); if (f[i][j] + k \u0026gt;= i + j - 1) mxd = max(mxd, i + j - 1); } } if (mxd == n * 2 - 1) { for (int i = 1; i \u0026lt; 2 * n; ++i) { printf(\u0026#34;a\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } else if (!mxd) { dp(1, 1); int px = 1, py = 1; while (px != n || py != n) { printf(\u0026#34;%c\u0026#34;, a[px][py]); bool flag = ne[px][py]; px = flag ? px : px + 1, py = flag ? py + 1 : py; } printf(\u0026#34;%c\\n\u0026#34;, a[n][n]); } else { int px = 0, py = 0; for (int i = 1; i \u0026lt;= n; ++i) { int j = mxd + 1 - i; if (f[i][j] + k == i + j - 1) { dp(i, j); bool flag = ne[i][j]; int npx = flag ? i : i + 1, npy = flag ? j + 1 : j; if (!px || le(npx, npy, px, py)) px = npx, py = npy; } } for (int i = 0; i \u0026lt; mxd; ++i) printf(\u0026#34;a\u0026#34;); while (px != n || py != n) { printf(\u0026#34;%c\u0026#34;, a[px][py]); bool flag = ne[px][py]; px = flag ? px : px + 1, py = flag ? py + 1 : py; } printf(\u0026#34;%c\\n\u0026#34;, a[n][n]); } return 0; } E. é¥¼å¹² 1 2 n, m = map(int, input().split()) print(n // m) F. æ–¹å·® æ°´é¢˜++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; long long a[N]; int main() { int n; long long ave = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); ave += a[i]; } ave /= n; long long res = 0; for (int i = 1; i \u0026lt;= n; ++i) { res += (a[i] - ave) * (a[i] - ave); } printf(\u0026#34;%lld\\n\u0026#34;, res / n); return 0; } G. æ­£æ–¹å½¢åˆ’åˆ† äºŒç»´çš„æœ‰ç‚¹ä¹±ï¼Œæ€è·¯æ¯”è¾ƒå¥½çŒœï¼Œä½†æ˜¯ä¸å¥½æ“ä½œã€‚\nå¯¹äºæ“ä½œ 0ï¼Œ å¯ä»¥ç”¨ä¸€ç§ç±»ä¼¼äºŒåˆ†çš„æ€è·¯ï¼ˆä½†æ˜¯åœ¨äºŒç»´ç©ºé—´åº”è¯¥å«å››åˆ†\n\\[?\\]ï¼‰åˆ†åˆ«ç»™è¡Œå·å’Œåˆ—å·ä¸€ä¸ªå·¦å³ç«¯ç‚¹ï¼Œä¸æ–­æ±‚ä¸­é—´çš„ç‚¹ï¼Œè¾“å‡ºç›®æ ‡ç‚¹ç›¸å¯¹ä¸­é—´ç‚¹ä½ç½®å¯¹åº”çš„å­—æ¯ï¼Œç„¶åç¼©å°åŒºé—´ç›´åˆ°å·¦å³ç«¯ç‚¹é‡å ï¼Œå¾ªç¯ç»“æŸã€‚\nå¯¹äºæ“ä½œ 1ï¼Œå’Œä¹‹å‰ç±»ä¼¼ï¼Œè¿™æ¬¡æ˜¯é€šè¿‡ç»™å‡ºçš„åºåˆ—ç¡®å®šç›¸å¯¹ä½ç½®ï¼Œç¼©å°åŒºé—´ï¼Œç›¸å½“äºæ˜¯åç€æ¥çš„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int T; cin \u0026gt;\u0026gt; T; while (T--) { int op; cin \u0026gt;\u0026gt; op; if (!op) { int n, x, y; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; int lx = 1, ly = 1, rx = 1 \u0026lt;\u0026lt; n, ry = 1 \u0026lt;\u0026lt; n; while (lx != rx || ly != ry) { int mid_x = lx + rx \u0026gt;\u0026gt; 1, mid_y = ly + ry \u0026gt;\u0026gt; 1; if (x \u0026lt;= mid_x \u0026amp;\u0026amp; y \u0026lt;= mid_y) { cout \u0026lt;\u0026lt; \u0026#39;A\u0026#39;; rx = mid_x, ry = mid_y; } else if (x \u0026lt;= mid_x \u0026amp;\u0026amp; y \u0026gt; mid_y) { cout \u0026lt;\u0026lt; \u0026#39;B\u0026#39;; rx = mid_x, ly = mid_y + 1; } else if (x \u0026gt; mid_x \u0026amp;\u0026amp; y \u0026lt;= mid_y) { cout \u0026lt;\u0026lt; \u0026#39;C\u0026#39;; lx = mid_x + 1, ry = mid_y; } else { cout \u0026lt;\u0026lt; \u0026#39;D\u0026#39;; lx = mid_x + 1, ly = mid_y + 1; } } cout \u0026lt;\u0026lt; endl; } else { string s; cin \u0026gt;\u0026gt; s; int n = s.length(); int lx = 1, ly = 1, rx = 1 \u0026lt;\u0026lt; n, ry = 1 \u0026lt;\u0026lt; n; for (int i = 0; i \u0026lt; n; ++i) { if (s[i] == \u0026#39;A\u0026#39;) { rx = lx + rx \u0026gt;\u0026gt; 1; ry = ly + ry \u0026gt;\u0026gt; 1; } else if (s[i] == \u0026#39;B\u0026#39;) { rx = lx + rx \u0026gt;\u0026gt; 1; ly = (ly + ry \u0026gt;\u0026gt; 1) + 1; } else if (s[i] == \u0026#39;C\u0026#39;) { lx = (lx + rx \u0026gt;\u0026gt; 1) + 1; ry = ly + ry \u0026gt;\u0026gt; 1; } else { lx = (lx + rx \u0026gt;\u0026gt; 1) + 1; ly = (ly + ry \u0026gt;\u0026gt; 1) + 1; } } if (lx == rx \u0026amp;\u0026amp; ly == ry) cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; lx \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ly \u0026lt;\u0026lt; endl; else return 123; } } return 0; } ","date":"2025-06-08T09:04:41Z","permalink":"https://invalidnamee.github.io/p/2025st28/","title":"2025æ˜¥è®­ç¬¬äºŒåå…«åœº"},{"content":"A. åºåˆ— é€»è¾‘éå¸¸ç®€å•ï¼Œå…ˆè¾“å‡º k ä¸ª 0 ä¹‹å 01 äº¤æ›¿è¾“å‡ºç›´åˆ°æŠŠ 0 ç”¨å®Œï¼Œæœ€åè¾“å‡ºå‰©ä¸‹çš„ 1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n, m, k; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); for (int i = 1; i \u0026lt;= k; ++i) { printf(\u0026#34;0\u0026#34;); m--; } while (n || m) { if (n) printf(\u0026#34;1\u0026#34;), n--; if (m) printf(\u0026#34;0\u0026#34;), m--; } printf(\u0026#34;\\n\u0026#34;); return 0; } B. å¼‚æˆ–ä¹‹åŠ› ä¹Ÿæ¯”è¾ƒå®¹æ˜“ï¼Œä¸éš¾æƒ³åˆ°æœ€ä¼˜æ–¹æ¡ˆæ˜¯å– 11111â€¦0ï¼Œå› ä¸ºè¿™æ˜¯ä¸ªå¶æ•°ï¼Œå¯¹åŠåˆ†å¼‚æˆ– = 0ï¼›ä»»æ„ä»ä¸­é—´æ–­å¼€ï¼Œç„¶åå¼‚æˆ–è¿˜æ˜¯åŸæ•°ï¼Œç­”æ¡ˆæ˜¯ \\(2^{n} - 2\\).\néœ€è¦ç‰¹åˆ¤ 2ï¼Œå› ä¸º 2 åªèƒ½åˆ†å‡ºæ­£æ•´æ•° 1ï¼Œç­”æ¡ˆæ˜¯ 0.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; const int MOD = 1e9 + 7; int power(int n, int p) { long long res = 1, base = n; while (p) { if (p \u0026amp; 1) res = res * base % MOD; base = base * base % MOD; p \u0026gt;\u0026gt;= 1; } return res; } int main() { int n; cin \u0026gt;\u0026gt; n; if (n \u0026lt;= 2) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; (power(2, n) - 2 + MOD) % MOD \u0026lt;\u0026lt; endl; return 0; } C. é˜Ÿä¼é›†ç»“ çœ‹ç€å“äººï¼Œå®åˆ™ä¸æ˜¯ï¼Œç›´æ¥æš´åŠ› \\(\\Theta(n^4)\\) é¢„å¤„ç†æ‰€æœ‰åŒºé—´çš„æœ€å°ä¸æ»¡åº¦ï¼Œç„¶åå¼€ä¸€ä¸ªäºŒç»´çŠ¶æ€ \\(f_{i, j}\\) è¡¨ç¤ºä»¥ i ç»“å°¾çš„åŒºé—´åŠ äº† j ä¸ªæ±‡åˆç‚¹æ—¶ä¸æ»¡éƒ½çš„æœ€å°å€¼ï¼Œæšä¸¾æœ€åä¸€æ®µåŒºé—´ dp å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 210; long long d[N], f[N][N], s[N][N]; int main() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; ++i) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; d[a + 1] += b; } memset(f, 0x3f, sizeof(f)); memset(s, 0x3f, sizeof(s)); for (int i = 1; i \u0026lt;= 201; ++i) { for (int j = i; j \u0026lt;= 201; ++j) { for (int k = i; k \u0026lt;= j; ++k) { long long res = 0; for (int l = i; l \u0026lt;= j; ++l) { res += (long long)(l - k) * (l - k) * d[l]; } s[i][j] = min(s[i][j], res); } } } f[0][0] = 0; for (int i = 1; i \u0026lt;= 201; ++i) { for (int j = 1; j \u0026lt;= k; ++j) { // ä½¿ç”¨æ¬¡æ•° for (int l = 1; l \u0026lt;= i; ++l) { f[i][j] = min(f[i][j], f[l - 1][j - 1] + s[l][i]); } } } cout \u0026lt;\u0026lt; f[201][k] \u0026lt;\u0026lt; endl; return 0; } D. èŠ± å­æ ‘åœ¨ dfs åºä¸‹ä¸€å®šæ˜¯ä¸€æ®µè¿ç»­åŒºé—´ï¼ŒæŠŠèŠ‚ç‚¹æŒ‰ dfs åºå»ºä¸€æ£µçº¿æ®µæ ‘ç»´æŠ¤å•ç‚¹ä¿®æ”¹å’ŒåŒºé—´æŸ¥è¯¢å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010; vector\u0026lt;int\u0026gt; ed[N]; int dfn[N], cnt[N], t; int tr[N * 4]; int a[N]; void dfs(int x, int fa) { dfn[x] = ++t; cnt[x] = 1; for (int y : ed[x]) { if (y == fa) continue; dfs(y, x); cnt[x] += cnt[y]; } } void pushup(int u) { tr[u] = max(tr[u \u0026lt;\u0026lt; 1], tr[u \u0026lt;\u0026lt; 1 | 1]); } void modify(int u, int l, int r, int p, int val) { if (l == r) tr[u] = val; else { int mid = l + r \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) modify(u \u0026lt;\u0026lt; 1, l, mid, p, val); else modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, p, val); pushup(u); } } int query(int u, int l, int r, int ql, int qr) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return tr[u]; else { int mid = l + r \u0026gt;\u0026gt; 1; int res = 0; if (ql \u0026lt;= mid) res = query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr); if (qr \u0026gt; mid) res = max(res, query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr)); return res; } } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt; n; ++i) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); ed[a].push_back(b); ed[b].push_back(a); } dfs(1, 0); for (int i = 1; i \u0026lt;= n; ++i) { modify(1, 1, n, dfn[i], a[i]); } while (m--) { int op; scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); if (op == 1) { int u, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;w); modify(1, 1, n, dfn[u], w); } else { int u; scanf(\u0026#34;%d\u0026#34;, \u0026amp;u); printf(\u0026#34;%d\\n\u0026#34;, query(1, 1, n, dfn[u], dfn[u] + cnt[u] - 1)); } } return 0; } E. åˆ†ç³–æœ æ°´é¢˜\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; (b + a - 1) / a \u0026lt;\u0026lt; endl; return 0; } F. æ–°å­—å…¸ æ°´é¢˜\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; int p[26]; char check(string a, string b) { int l = min(a.length(), b.length()); for (int i = 0; i \u0026lt; l; ++i) { if (a[i] != b[i]) return p[a[i] - \u0026#39;a\u0026#39;] \u0026lt; p[b[i] - \u0026#39;a\u0026#39;] ? \u0026#39;s\u0026#39; : \u0026#39;t\u0026#39;; } return a.length() \u0026lt; b.length() ? \u0026#39;s\u0026#39; : \u0026#39;t\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; string s, t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; int T; cin \u0026gt;\u0026gt; T; while (T--) { string dic; cin \u0026gt;\u0026gt; dic; for (int i = 0; i \u0026lt; 26; ++i) p[dic[i] - \u0026#39;a\u0026#39;] = i; cout \u0026lt;\u0026lt; check(s, t) \u0026lt;\u0026lt; endl; } return 0; } G. æœºå™¨äºº äºŒåˆ†ç­”æ¡ˆï¼Œéœ€è¦æ³¨æ„äºŒåˆ†ä¸‹ç•Œæ˜¯ \\(\\max_{i=1}^na_i\\)ï¼Œåˆå§‹ä»»åŠ¡ä¹Ÿæ˜¯ä»»åŠ¡ğŸ˜­\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;climits\u0026gt; #define int long long using namespace std; const int N = 100010; int n, m, t; int a[N]; bool check(int mid) { long long cnt = 0; for (int i = 1; i \u0026lt;= m; ++i) { cnt += max(0ll, (mid - a[i]) / t); } return cnt \u0026gt;= n; } signed main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; t; int l = 0, r = 1000000000000; for (int i = 1; i \u0026lt;= m; ++i) { cin \u0026gt;\u0026gt; a[i]; l = max(l, a[i]); } while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; return 0; } H. æ¸¸æˆ åŸºç¡€çš„äºŒç»´ dpï¼Œ \\(f_{i, j}\\) è¡¨ç¤ºç¬¬ i å¤©è¿˜å‰© j èµ„æºèƒ½è·å¾—çš„æœ€å¤§å¼ºåº¦å€¼ï¼Œæ¯å¤©æšä¸¾æ‰€æœ‰çš„ j å’Œä¹°ä¸ä¹°æ›´æ–°çŠ¶æ€ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 5010; int f[N][N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); memset(f, -0x3f, sizeof(f)); f[0][0] = 0; for (int i = 1; i \u0026lt;= n; ++i) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); for (int j = 0; j \u0026lt; i; ++j) { // ä¸ä¹° f[i][j + 1] = max(f[i][j + 1], f[i - 1][j]); // ä¹° if (j + 1 \u0026gt;= a) { f[i][j + 1 - a] = max(f[i][j + 1 - a], f[i - 1][j] + b); } } } int res = 0; for (int i = 0; i \u0026lt;= n; ++i) res = max(res, f[n][i]); printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } I. ABB æ°´é¢˜\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; set\u0026lt;string\u0026gt; a; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n; cin \u0026gt;\u0026gt; n; string s; cin \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt; s.length() - 2; ++i) { if (s[i] != s[i + 1] \u0026amp;\u0026amp; s[i + 1] == s[i + 2]) a.insert(s.substr(i, 3)); } cout \u0026lt;\u0026lt; a.size() \u0026lt;\u0026lt; endl; return 0; } J. è´Ÿé‡çˆ¬æ¥¼æ¢¯ æ°´é¢˜ï¼ˆçº¿æ€§ dpï¼‰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 100010; int a[N]; long long f[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } memset(f, 0x3f, sizeof(f)); f[1] = a[1]; f[0] = 0; for (int i = 2; i \u0026lt;= n; ++i) { f[i] = min(f[i - 2] + a[i], f[i - 1] + a[i]); } printf(\u0026#34;%lld\\n\u0026#34;, min(f[n], f[n - 1])); return 0; } K. æ´’æ°´å™¨ ç›´æ¥æš´åŠ›ç»´æŠ¤ç­‰å·®æ•°åˆ—ä¸å¥½ç»´æŠ¤ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ç»´æŠ¤ç­‰å·®æ•°åˆ—çš„å·®åˆ†æ•°åˆ—ï¼Œç­‰å·®æ•°åˆ—å…¬å·®ä¸€å®šï¼Œæ‰€ä»¥è¿™ä¸ªå·®åˆ†æ•°åˆ—å¯ä»¥å†ç”¨å®ƒçš„å·®åˆ†æ•°åˆ—ç»´æŠ¤ï¼Œæœ€åå‰ç¼€å’Œä¸¤æ¬¡è¾“å‡ºç­”æ¡ˆå³å¯ã€‚\néœ€è¦ç‰¹åˆ¤å·¦è¾¹ç•Œï¼Œä¸éœ€è¦ç‰¹åˆ¤å³è¾¹ç•Œï¼Œå› ä¸ºå·²ç»å‡ºç•Œäº†æ— æ‰€è°“äº†ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; long long s[N]; int p[N]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;p[i]); } for (int i = 1; i \u0026lt;= n; ++i) { int w; scanf(\u0026#34;%d\u0026#34;, \u0026amp;w); int lp = max(p[i] - w + 1, 1), rp = min(p[i] + w - 1, m); s[lp] += w - abs(p[i] - lp); s[lp + 1] -= w - abs(p[i] - lp); s[lp + 1] += 1; s[p[i] + 1] -= 2; s[rp + 2]++; } for (int i = 1; i \u0026lt;= m; ++i) { s[i] += s[i - 1]; } for (int i = 1; i \u0026lt;= m; ++i) { s[i] += s[i - 1]; printf(\u0026#34;%lld \u0026#34;, s[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } ","date":"2025-06-07T12:58:30Z","permalink":"https://invalidnamee.github.io/p/2025st27/","title":"2025æ˜¥è®­ç¬¬äºŒåä¸ƒåœº"},{"content":"é¢˜é¢å¯ä»¥çœ‹è¿™é‡Œ.\nA. æ•°åˆ—è®¡æ•° æœ€å®³æ€•çš„æ•°å­¦é¢˜ã€‚\n\\(\\prod_{i=1}^{n}\\binom{a_i}{b_i} \\) ç­‰ä»·äºå¯¹äºæ¯ä¸€ä¸ª iï¼Œéƒ½æœ‰ \\(\\binom{a_i}{b_i}\\) ä¸ºå¥‡æ•°ã€‚\nå¯¹äº \\(\\binom{n}{k}\\)ï¼Œæ ¹æ®ï¼ˆChatGPTæŒ‡å‡ºçš„ï¼‰å¢å¡æ–¯å®šç†ï¼Œå– p = 2 æœ‰\n\\[\\binom{n}{k} \\equiv \\binom{n\\ \\text{mod}\\ 2}{k\\ \\text{mod}\\ 2} \\binom{\\lfloor\\frac{n}{2}\\rfloor}{1}\\ (\\text{mod}\\ 2)\\]\nå³è¾¹è¿™ä¸€é¡¹åŒç†å¯ä»¥ä¸æ–­å±•å¼€ï¼Œæœ€ç»ˆç­‰ä»·äº**å–å‡ºäº† n å’Œ k çš„æ‰€æœ‰äºŒè¿›åˆ¶ä½ç®—ç»„åˆæ•°å†ä¹˜ç§¯ã€‚**æ˜¾ç„¶è¦æƒ³ä¿è¯æ˜¯å¥‡æ•°ï¼Œåªèƒ½ k çš„æ¯ä¸ªäºŒè¿›åˆ¶ä½éƒ½ä¸æ¯” n å¤§ã€‚\nå¯¹äºæ¯ä¸€é¡¹åšä¸€æ¬¡æ•°ä½ dpï¼Œç»Ÿè®¡æ¯ä¸€ä½éƒ½æ¯” \\(a_i\\) å°çš„æ•°çš„ä¸ªæ•°å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ \\(\\Theta(n\\log 10^9)\\)ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; const int MOD = 998244353; int a[N]; long long f[31][2]; // ç¬¬iä½ï¼Œæ˜¯å¦é¡¶ä¸Šç•Œ int dp(int a, int l) { f[30][1] = 1; for (int i = 29; i \u0026gt;= 0; --i) { if (a \u0026gt;\u0026gt; i \u0026amp; 1) { // å¯é€‰ 1 å’Œ 0 if (l \u0026gt;\u0026gt; i \u0026amp; 1) { f[i][1] = f[i + 1][1]; f[i][0] = (f[i + 1][0] * 2 + f[i + 1][1]) % MOD; } else { f[i][1] = f[i + 1][1]; f[i][0] = f[i + 1][0] * 2 % MOD; } } else { // åªèƒ½é€‰ 0 if (l \u0026gt;\u0026gt; i \u0026amp; 1) { f[i][1] = 0; f[i][0] = (f[i + 1][0] + f[i + 1][1]) % MOD; } else { f[i][1] = f[i + 1][1]; f[i][0] = f[i + 1][0]; } } } return (f[0][0] + f[0][1]) % MOD; } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } long long res = 1; for (int i = 1; i \u0026lt;= n; ++i) { int l; scanf(\u0026#34;%d\u0026#34;, \u0026amp;l); res = (res * dp(a[i], min(l, a[i]))) % MOD; } printf(\u0026#34;%lld\\n\u0026#34;, res); } return 0; } D. å¼¯æ›²ç­·å­ è¿™é“é¢˜éœ€è¦å‘ç°ä¸€ä¸ªå°ç»“è®ºï¼Œæ˜¾ç„¶æˆ‘å½“æ—¶æ²¡å‘ç°â€¦â€¦\nå…ˆå¯¹ c æ•°ç»„æ’åºä¸€ä¸‹ï¼Œæ’åºåä¸€æ ¹ç­·å­åªå¯èƒ½å’Œä»–ç›¸é‚»çš„æˆ–è€…éš”ä¸€ä¸ªçš„ç­·å­é…å¯¹ã€‚æ‰€ä»¥é—®é¢˜å°±è½¬åŒ–æˆäº†ä¸€ä¸ªçº¿æ€§dp çš„é—®é¢˜ã€‚å¯¹äºæ¯ä¸€ä¸ª i åªç”¨è€ƒè™‘ i - 1 å’Œ i - 2. dpæ—¶ä¸»è¦éœ€è¦è€ƒè™‘å…œåº•ï¼Œå³å¦‚ä½•å¼ºåˆ¶é€‰ä¸Šå¿…é¡»é€‰çš„ï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹å¾ˆç®€å•ï¼Œå¯ä»¥å‚è€ƒä¸‹é¢çš„ä»£ç ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 300010; pair\u0026lt;int, bool\u0026gt; c[N]; long long f[N][2]; long long p2(long long a) { return a * a; } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); memset(f, 0x3f, sizeof(long long) * (n * 2 + 1)); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;c[i].first); c[i].second = false; } for (int i = 1; i \u0026lt;= m; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); c[t].second = true; } f[0][1] = 0; sort(c + 1, c + n + 1); int pre = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (c[i - 1].second) { f[i][0] = f[i - 1][1]; // ä¸€å®šè¦é…å¯¹ f[i][1] = f[i - 1][0] + p2(c[i].first - c[i - 1].first); } else { f[i][0] = min(f[i - 1][0], f[i - 1][1]); // éšæ„ if (i \u0026gt;= 2) f[i][1] = min(f[i - 1][0] + p2(c[i].first - c[i - 1].first), f[i - 2][0] + p2(c[i].first - c[i - 2].first)); } } if (c[n].second) printf(\u0026#34;%lld\\n\u0026#34;, f[n][1]); else printf(\u0026#34;%lld\\n\u0026#34;, min(f[n][0], f[n][1])); } return 0; } E. ä¿®å¤å…¬è·¯ æˆ‘æ„Ÿè§‰è¿™åº”è¯¥æ˜¯æœ€æ°´çš„ä¸€é“é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ç”¨æœ€å°çš„ä»£ä»·ä½¿ä¸è¿é€šçš„å›¾è¿é€šï¼Œæ˜¾ç„¶å°±æ˜¯æŠŠæœ¬æ¥ä¸è¿é€šçš„è¿é€šå—ä½œä¸ºèŠ‚ç‚¹å»ºä¸€æ£µæ ‘ï¼Œç­”æ¡ˆæ˜¯è¿é€šå—æ•°é‡ - 1.\néœ€è¦ä¸»æ„åˆ«æŠŠåˆå§‹åŒ–å†™æŒ‚ğŸ˜­\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 300010; vector\u0026lt;int\u0026gt; ed[N]; bool vis[N]; void dfs(int x) { if (vis[x]) return; vis[x] = true; for (int y : ed[x]) { dfs(y); } } void solve() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { vis[i] = false; ed[i].clear(); } for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); if (i - t \u0026gt; 0) ed[i].push_back(i - t), ed[i - t].push_back(i); if (i + t \u0026lt;= n) ed[i].push_back(i + t), ed[i + t].push_back(i); } int cnt = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (!vis[i]) cnt++, dfs(i); } printf(\u0026#34;%d\\n\u0026#34;, cnt - 1); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { solve(); } return 0; } G. å®çŸ³å•†åº— è¿™æ˜¯ä¸€é“çº¯æ•°æ®ç»“æ„é¢˜ï¼Œä¸éš¾å‘ç°\n\\[(a_i \\lor x) \\oplus (a_i \\land x) = a_i \\oplus x\\]\né—®é¢˜è½¬åŒ–æˆåœ¨åŒºé—´ \\[l, r\\] å†…æ‰¾ä¸€ä¸ª iï¼Œä½¿å¾— \\(a_i \\oplus x\\) æœ€å¤§ã€‚äºæ˜¯å¯æŒä¹…åŒ–å­—å…¸æ ‘æˆ–è€…ä¸»å¸­æ ‘å¥—å­—å…¸æ ‘éƒ½è¡Œã€‚å»ºè®®åˆ«å†™æ ‘å¥—æ ‘ï¼Œä¸€é”™ä¸€ä¸ªä¸å±å£°ã€‚\næˆ‘ä¸ä½œæ­»ï¼Œæˆ‘å†™çš„æ˜¯å­—å…¸æ ‘ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010; int trie[N * 60][2], rt[N], tot; void add(int x, int cur, int pre) { for (int i = 30; i \u0026gt;= 0; --i) { bool t = x \u0026gt;\u0026gt; i \u0026amp; 1; trie[cur][t] = ++tot; trie[cur][t ^ 1] = trie[pre][t ^ 1]; cur = trie[cur][t], pre = trie[pre][t]; } } int query(int x, int l, int r) { int res = 0; for (int i = 30; i \u0026gt;= 0; --i) { bool t = x \u0026gt;\u0026gt; i \u0026amp; 1; if (trie[r][t ^ 1] \u0026amp;\u0026amp; trie[r][t ^ 1] != trie[l][t ^ 1]) { res += 1 \u0026lt;\u0026lt; i; l = trie[l][t ^ 1], r = trie[r][t ^ 1]; } else { l = trie[l][t], r = trie[r][t]; } } return res; } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--){ int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { rt[i] = ++tot; int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); add(t, rt[i], rt[i - 1]); } while (m--) { int l, r, x; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;x); printf(\u0026#34;%d\\n\u0026#34;, query(x, rt[l - 1], rt[r])); } memset(trie, 0, (tot + 1) * sizeof(trie[0])); memset(rt, 0, (n + 1) * sizeof(int)); tot = 0; } return 0; } I. éƒ¨è½å†²çª æˆ‘è¿™é‡Œé­”æ”¹äº†ä¸€ä¸‹å¹¶æŸ¥é›†ï¼Œè¿™é“é¢˜ç”¨å¹¶æŸ¥é›†å¤„ç†å”¯ä¸€çš„å›°éš¾å°±æ˜¯æ“ä½œ2ï¼ˆé‡è›®äºº a ç§»åŠ¨åˆ°éƒ¨è½ b ä¸­ï¼‰ï¼Œç›´æ¥æ”¹é‡è›®äºº a çš„çˆ¶äº²å¯èƒ½ä¼šæ³¢åŠåˆ°ä»–çš„å­æ ‘ï¼Œæ‰€ä»¥éœ€è¦ä¸€ç§åŠæ³•è®©æ¯ä¸ªé‡è›®äººå§‹ç»ˆæ˜¯å¶å­ã€‚äºæ˜¯æˆ‘å¼€äº† n ä¸ªè™šæ‹ŸèŠ‚ç‚¹åˆ†åˆ«åˆå§‹åŒ–æˆæ¯ä¸ªé‡è›®äººçš„çˆ¶äº²ï¼Œç”¨æ¥åˆå¹¶å’Œäº¤æ¢ï¼Œè¿›è¡Œåˆå¹¶å’Œäº¤æ¢çš„æ—¶å€™åŠ¨çš„æ°¸è¿œéƒ½æ˜¯è™šæ‹ŸèŠ‚ç‚¹ï¼Œè¿™æ ·éšä¾¿æ”¹çˆ¶äº²å°±ä¸ä¼šå‡ºé—®é¢˜äº†ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 1000010; int rep[N], rnk[N * 2], fa[N * 2]; // å‰ n ä¸ªè¡¨ç¤ºé‡è›®äººï¼Œä¸­é—´è¡¨ç¤ºåˆå§‹è™šæ‹ŸèŠ‚ç‚¹ int getfa(int x) { return x == fa[x] ? x : fa[x] = getfa(fa[x]); } void solve() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); int tot = 2 * n; for (int i = 1; i \u0026lt;= n; ++i) { fa[i] = i + n; fa[i + n] = i + n; rep[i] = i + n; // ä»£è¡¨ç‚¹æš‚æ—¶é€‰ä¸­é—´çš„åˆå§‹èŠ‚ç‚¹ï¼Œä¸èƒ½åŠ¨å‰ n ä¸ª rnk[i + n] = i; } while (q--) { int op; scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); if (op == 4) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%d\\n\u0026#34;, rnk[getfa(a)]); } else { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); if (op == 1) { int r1 = rep[a], r2 = rep[b]; fa[r2] = r1; // åˆå¹¶ rep[b] = r1; } else if (op == 2) { fa[a] = rep[b]; // é‡è›®äººåªèƒ½æ˜¯å¶å­ } else { swap(rnk[rep[a]], rnk[rep[b]]); swap(rep[a], rep[b]); } } } } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { solve(); } return 0; } J. é€‰æ‹©é…é€ è¿™é“é¢˜åº”è¯¥æ˜¯ç¬¬äºŒæ°´çš„é¢˜ï¼Œå°è¯•åˆ†ç±»è®¨è®ºåˆ†ç¦»ä¸¤ä¸ªç‚¹çš„å‚æ•°ï¼Œå°è¯•å»ç»å¯¹å€¼\n\\[|p_1 - p_2| + |q_1 - q_2| = \\max{|(p_1 + q_1) - (q_1 + q_2|), |(p_1 - q_1) - (p_2 + q_2)|}\\]\nåªéœ€è¦è®°å½•å››ä¸ªæç«¯å€¼ \\(\\max{x_i + y_i}, \\min{x_i + y_i},\\max{x_i - y_i},\\min{x_i - y_i}\\)å°±èƒ½æ‰¾åˆ°å¯¹äºæ¯ä¸ªå€™é€‰é…é€ç«™çš„æœ€å¤§è·ç¦»ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; const int N = 1000010; int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n, m; long long mn_s = LLONG_MAX, mx_s = LLONG_MIN, mn_m = LLONG_MAX, mx_m = LLONG_MIN; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { long long x, y; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y); mx_s = max(mx_s, x + y); mn_s = min(mn_s, x + y); mx_m = max(mx_m, x - y); mn_m = min(mn_m, x - y); } long long res = LLONG_MAX; for (int i = 1; i \u0026lt;= m; ++i) { long long x, y; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y); long long su = x + y, me = x - y; res = min(res, max(max(abs(su - mx_s), abs(su - mn_s)), max(abs(me - mx_m), abs(me - mn_m)))); } printf(\u0026#34;%lld\\n\u0026#34;, res); } return 0; } ","date":"2025-06-05T13:59:39Z","permalink":"https://invalidnamee.github.io/p/2025st26/","title":"2025æ˜¥è®­ç¬¬äºŒåå…­åœº"},{"content":"æ˜¨å¤©æ ½åœ¨äºŒåˆ†äº†ï¼Œä»Šå¤©å†™äº†å››ä¸ªäºŒåˆ†ä¸€ä¸ªä¹Ÿæ²¡æŒ‚ï¼Œçˆ½ğŸ˜‹\nA. äº’è´¨åˆ’åˆ† äº‹å®ä¸Šï¼Œåªéœ€è¦ n / 2 å³å¯ï¼Œå¦‚æœæ‰€æœ‰ 2 çš„å€æ•°éƒ½èƒ½åˆ†å¼€äº†ï¼Œé‚£å…¶ä»–çš„æ›´èƒ½åˆ†å¼€ã€‚\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { long long n; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; max(1LL, n \u0026gt;\u0026gt; 1) \u0026lt;\u0026lt; endl; return 0; } B. å‡ºç§Ÿè½¦ å¯¹äºæ¯ä¸€ä¸ªå±…æ°‘äºŒåˆ†æœ€çŸ­è·ç¦»ï¼Œåœ¨æ ¹æ®æœ€çŸ­è·ç¦»äºŒåˆ†å‡ºæ¥å·¦å³è¾¹ç•Œçš„ä½ç½®ï¼Œç„¶åæ£€æŸ¥è¾¹ç•Œæ˜¯å¦åˆæ³•ï¼Œæœ€åæ›´æ–°ç­”æ¡ˆï¼› \\(\\Theta(n\\log^2 n)\\)å®Œå…¨å¤Ÿäº†ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 200010; int p[N], id[N], s[N], res[N]; int n, m; int findl(long long val) { int l = 1, r = n + m; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (p[mid] \u0026gt;= val) r = mid; else l = mid + 1; } return l; } int findr(int val) { int l = 1, r = n + m; while (l \u0026lt; r) { int mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (p[mid] \u0026lt;= val) l = mid; else r = mid - 1; } return l; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n + m; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;p[i]); } for (int i = 1; i \u0026lt;= n + m; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;id[i]); s[i] = s[i - 1] + id[i]; } for (int i = 1; i \u0026lt;= n + m; ++i) { if (!id[i]) { int l = 0, r = 1000000000; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (s[findr((long long)p[i] + mid)] - s[findl((long long)p[i] - mid) - 1]) r = mid; else l = mid + 1; } int L = findl((long long)p[i] - l), R = findr((long long)p[i] + l); // cout \u0026lt;\u0026lt; L \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; R \u0026lt;\u0026lt; endl; if (id[L] \u0026amp;\u0026amp; id[R]) if (p[i] - p[L] \u0026lt;= p[R] - p[i]) res[L]++; else res[R]++; else if (id[L]) res[L]++; else if (id[R]) res[R]++; else return 213; } } for (int i = 1; i \u0026lt;= n + m; ++i) { if (id[i]) printf(\u0026#34;%d \u0026#34;, res[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } C. æœ¨é›•ç©å…· ç»§ç»­äºŒåˆ†ï¼ŒäºŒåˆ†ç­”æ¡ˆï¼Œç„¶åéªŒè¯éœ€è¦çš„äººæ•°æ˜¯å¦ â‰¥ 3 å³å¯ã€‚ä»¥æ™®éç†æ€§è€Œè®ºï¼Œåº”è¯¥å¯ä»¥çº¿æ€§ dp è§£å†³ï¼Œä½†æ˜¯è¿™ä¸å½±å“æˆ‘ä¸€ç›´å†™æŒ‚â€¦â€¦\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010; int a[N], n; bool check(int mid) { int t = 0, cur = -0x3f3f3f3f; for (int i = 1; i \u0026lt;= n; ++i) { if (a[i] - cur \u0026gt; mid) { t++; cur = a[i] + mid; } } return t \u0026lt;= 3; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } sort(a + 1, a + n + 1); int l = 0, r = 1000000000; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } printf(\u0026#34;%d\\n\u0026#34;, l); return 0; } E. è¶³çƒè”èµ› It is a ç­¾åˆ°é¢˜ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; int res[30]; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) { int a, b, c, d; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; if (c \u0026gt; d) res[a] += 3; else if (c == d) res[a]++, res[b]++; else res[b] += 3; } for (int i = 1; i \u0026lt;= n; ++i) { cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; return 0; } F. æœæ± ç”¨è´ªå¿ƒçš„æ€æƒ³ï¼Œå°½å¯èƒ½çš„å¾€å³è¾¹å€’ï¼Œç»™åé¢æ›´å¤šçš„å¯èƒ½ï¼›åŒæ—¶è¿™ä¹ˆåšä¸å½±å“å‰é¢çš„æ”¶ç›Šï¼Œå› ä¸ºæƒ³å–åˆ°å¿…é¡»å…¨å€’æ»¡ï¼Œå¦‚æœå¯ä»¥å–åˆ°çš„è¯å…ˆå€’å‰é¢çš„å’Œå…ˆå€’åé¢çš„æ”¶ç›Šä¸€æ ·ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; const int N = 30010; int v[N]; void solve() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;v[i]); } v[m + 1] = 0x3f3f3f3f; map\u0026lt;int, int\u0026gt; mp; for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); mp[t]++; } int res = 0; for (auto [i, t] : mp) { if (v[i + 1] \u0026gt;= t) v[i + 1] -= t; else { t -= v[i + 1], v[i + 1] = 0; res += max(0, t - v[i]); } } printf(\u0026#34;%d\\n\u0026#34;, res); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { solve(); } return 0; } ","date":"2025-05-25T10:10:59Z","permalink":"https://invalidnamee.github.io/p/2025st23/","title":"2025æ˜¥è®­ç¬¬äºŒåä¸‰åœº"},{"content":"A. æŸ“è‰² æ•°æ®éå¸¸å°ï¼Œç›´æ¥æš´åŠ›å°±å¯ä»¥ï¼Œéå¸¸ä¿é™©ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int l1, r1, l2, r2; cin \u0026gt;\u0026gt; l1 \u0026gt;\u0026gt; r1 \u0026gt;\u0026gt; l2 \u0026gt;\u0026gt; r2; int res = 0; for (int i = 0; i \u0026lt;= 100; ++i) { if (l1 \u0026lt;= i \u0026amp;\u0026amp; i \u0026lt; r2 \u0026amp;\u0026amp; l2 \u0026lt;= i \u0026amp;\u0026amp; i \u0026lt; r1) { res++; } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } B. çŸ³å¤´ç§°é‡ æœ¬æ¥å¾ˆç®€å•çš„é¢˜åˆšå¼€å§‹è¢«æˆ‘æƒ³å¤æ‚äº†ï¼Œå½“ç„¶ï¼Œè¿˜æœ‰åˆ«çš„å› ç´ å½±å“ï¼Œå¯¼è‡´å¡äº†ä¸åˆ°ä¸€ä¸ªå°æ—¶â€¦â€¦\nå…¶å®å¾ˆç®€å•ï¼Œå› ä¸ºå‰é¢å…ƒç´ çš„å’Œä¸€å®šä¸å¤§äºåé¢çš„å…ƒç´ ï¼Œæ‰€ä»¥æƒ…å†µä¸€å…±æœ‰ \\(2^n\\) ç§ï¼Œè€Œä¸”é€‰åé¢çš„æ— è®ºå¦‚ä½•éƒ½æ¯”ä»»æ„é€‰å‰é¢çš„å¤§ã€‚\nè¿™è®©æˆ‘æƒ³åˆ°äº†äºŒè¿›åˆ¶ï¼Œæ¯ä¸ªæ•°å¯ä»¥çœ‹åšä¸€ä¸ªæ•°ä½ï¼Œé€‰å’Œä¸é€‰æ˜¯ 0 å’Œ 1ï¼Œå®Œå…¨æ»¡è¶³ä¸Šé¢çš„è§„å¾‹ï¼Œä¾‹å¦‚ 3(110) ä¸€å®šå°äº 4(001)ã€‚\nå› ä¸ºç¬¬ä¸€ä¸ªäºŒè¿›åˆ¶æ•°æ˜¯ 0ï¼Œæˆ‘ä»¬ä»¤ k = k - 1ï¼Œè¿™æ ·å°±å®Œå…¨å’ŒäºŒè¿›åˆ¶å¯¹ä¸Šäº†ï¼Œæ¥ä¸‹æ¥åªéœ€è¦å¯¹ k è¿›è¡ŒäºŒè¿›åˆ¶åˆ†è§£æŠŠå¯¹åº”çš„ä½ç½®åŠ ä¸Šå°±æ˜¯ç­”æ¡ˆã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int N = 60; long long w[N], s[N], k; int n; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;w[i]); s[i] = s[i - 1] + w[i]; } scanf(\u0026#34;%lld\u0026#34;, \u0026amp;k); if (k \u0026gt; (1ll \u0026lt;\u0026lt; n)) printf(\u0026#34;-1\\n\u0026#34;); else { k--; long long res = 0; for (int i = 0; i \u0026lt; n; ++i) { if (k \u0026gt;\u0026gt; i \u0026amp; 1) res += w[i + 1]; } printf(\u0026#34;%lld\\n\u0026#34;, res); } return 0; } C. å­—ç¬¦ä¸² è¿™é“é¢˜ä¹Ÿæœ‰é‚£ä¹ˆä¸€ç‚¹çº¸è€è™çš„æ ·å­ï¼Œçœ‹ç€æ— ä»ä¸‹æ‰‹ï¼Œä½†æ˜¯å¦‚æœå‘ç°äº†å°±éå¸¸ç®€å•ã€‚\nå…ˆè€ƒè™‘æé™çš„æƒ…å†µï¼Œå†è€ƒè™‘ä¸€èˆ¬æƒ…å†µ\nåŒºé—´é•¿åº¦ä¸º 2ï¼Œä¸¤ä¸ªå­—ç¬¦å¿…é¡»ä¸åŒï¼›\nåŒºé—´é•¿åº¦ä¸º 3ï¼Œä¸‰ä¸ªå­—ç¬¦å¿…é¡»äº’ä¸ç›¸åŒï¼›\nåŒºé—´é•¿åº¦ä¸º 4ï¼Œå…è®¸ä¸€ä¸ªå­—ç¬¦åœ¨ä¸¤ç«¯å„å‡ºç°ä¸€æ¬¡ï¼›\né•¿åº¦æ›´é•¿çš„åŒºé—´å¦‚æœå‡ºç°æœ€å¤šçš„å­—ç¬¦é—´éš”éƒ½ä¸å°äº 2 ä¾ç„¶æ˜¯åˆæ³•çš„ã€‚\nå¾—å‡ºç»“è®ºï¼Œåªè¦ç›¸åŒå­—ç¬¦é—´éš” â‰¥ 2 å³å¯ã€‚äºæ˜¯å°±å¥½åŠäº†ï¼Œå¼€ä¸€ä¸ªçŠ¶æ€ \\(f_{i, j, k}\\) è¡¨ç¤ºç¬¬ i ä¸ªä½ç½®é€‰äº† jï¼Œä¸Šä¸€ä¸ªä½ç½®é€‰äº† k çš„æ–¹æ¡ˆæ•°ï¼Œçº¿æ€§ dp å³å¯ã€‚\nä¸€ä¸ªä½ç½®çš„å­—ç¬¦é€‰æ‹©å—åˆ°å‰ä¸¤ä¸ªå­—ç¬¦çš„å½±å“ï¼Œæ‰€ä»¥éœ€è¦åŒæ—¶è®°å½•ä¸¤ä¸ªçŠ¶æ€ï¼Œè¿™æ ·ä» i - 1 åˆ° i çš„æ—¶å€™å°±å¯ä»¥åšåˆ°ä¸é‡ä¸æ¼ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 5010; const int MOD = 998244353; char s[N]; int cnt[N]; long long f[N][27][27]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); scanf(\u0026#34;%s\u0026#34;, s + 1); f[0][26][26] = 1; // ç”¨äº†ä¸€ç§ä¸å¯èƒ½çš„æƒ…å†µè¡¨ç¤ºè¾¹ç•Œï¼Œè¿™ç§æƒ…å†µä¼šåœ¨ i = 3 çš„æ—¶å€™æ¶ˆå¤± for (int i = 1; i \u0026lt;= n; ++i) { if (s[i] != \u0026#39;?\u0026#39;) { int t = s[i] - \u0026#39;a\u0026#39;; for (int j = 0; j \u0026lt;= 26; ++j) { for (int k = 0; k \u0026lt;= 26; ++k) { if (j == t || k == t) continue; f[i][t][j] += f[i - 1][j][k]; f[i][t][j] %= MOD; } } } else { for (int t = 0; t \u0026lt; 26; ++t) { for (int j = 0; j \u0026lt;= 26; ++j) { for (int k = 0; k \u0026lt;= 26; ++k) { if (j == t || k == t) continue; f[i][t][j] += f[i - 1][j][k]; f[i][t][j] %= MOD; } } } } } long long res = 0; for (int i = 0; i \u0026lt;= 26; ++i) { for (int j = 0; j \u0026lt;= 26; ++j) { res = (res + f[n][i][j]) % MOD; } } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } D. å–µå–µ è¿™é“é¢˜ç›¸å¯¹ç®€å•ä¸€ç‚¹ï¼ˆå› ä¸ºè™½ç„¶æµç¨‹æœ‰ç‚¹éº»çƒ¦ï¼Œä½†æ˜¯ä¸€çœ‹å®¹æ˜“çœ‹å‡ºæ¥åŠæ³•ï¼‰\næ±‚ä¸€ä¸‹æœ€çŸ­è·¯åŒæ—¶è®°å½•ç¼–å·æœ€å°çš„å‰é©±ï¼Œç»“æŸåä» 1 å·å¼€å§‹æ²¿ç€è®°å½•çš„æœ€çŸ­è·¯çš„é€†è·¯å¾„è·‘ dfsï¼Œåœ¨æœç´¢æ ‘ä¸Šæ ‘å½¢ dp ç»Ÿè®¡ç­”æ¡ˆå³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 10010; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; ed[N]; int a[N], dis[N], pre[N], t; long long res; bool vis[N]; void dijkstra() { memset(dis, 0x3f, sizeof(dis)); priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; dis[1] = 0; q.push({0, 1}); while (!q.empty()) { int x = q.top().second; q.pop(); if (vis[x]) continue; vis[x] = true; for (auto [i, y] : ed[x]) { if (dis[y] \u0026gt; dis[x] + i) { dis[y] = dis[x] + i; pre[y] = x; q.push({-dis[y], y}); } else if (dis[y] == dis[x] + i) { pre[y] = min(pre[y], x); } } } } void dfs(int x, int l) { if (vis[x]) return; vis[x] = true; for (auto [i, y] : ed[x]) { if (vis[y]) continue; if (x == pre[y]) { dfs(y, l + i); a[x] += a[y]; } } res = max(res, (long long)a[x] * (l - t)); } int main() { int n, m; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;t); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int i = 1; i \u0026lt;= m; ++i) { int x, y, z; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); ed[x].push_back({z, y}); ed[y].push_back({z, x}); } dijkstra(); memset(vis, 0, sizeof(vis)); for (int i = 1; i \u0026lt;= n; ++i) { sort(ed[i].begin(), ed[i].end(), [](pair\u0026lt;int, int\u0026gt; a, pair\u0026lt;int, int\u0026gt; b) { return a.second \u0026lt; b.second; }); } dfs(1, 0); printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } E. å˜é‡å®šä¹‰ æ¯”è¾ƒæ°´ï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼ŒæŒ‰è¦æ±‚åšå°±è¡Œã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 keys = [\u0026#34;include\u0026#34;, \u0026#34;using\u0026#34;, \u0026#34;namespace\u0026#34;, \u0026#34;return\u0026#34;, \u0026#34;main\u0026#34;, \u0026#34;int\u0026#34;, \u0026#34;float\u0026#34;, \u0026#34;double\u0026#34;, \u0026#34;string\u0026#34;, \u0026#34;char\u0026#34;] n = int(input().strip()) def check(s: str): if s in keys: return \u0026#39;No\u0026#39; if s[0] == \u0026#39;_\u0026#39; or s[0].isalpha(): for c in s: if c != \u0026#39;_\u0026#39; and not c.isalnum(): return \u0026#39;No\u0026#39; return \u0026#39;Yes\u0026#39; else: return \u0026#39;No\u0026#39; for _ in range(n): s = input() print(check(s.strip())) F. è·³è¿œæ¯”èµ› æˆ‘å› ä¸º check å‡½æ•°å†™æŒ‚\\(\\textcolor{green}{+11}\\)â€¦â€¦\nå…¸å‹çš„äºŒåˆ†ç­”æ¡ˆé¢˜ï¼ŒäºŒåˆ†æœ€å¤§å€¼ï¼Œè´ªå¿ƒéªŒè¯å³å¯ã€‚å…·ä½“çš„ï¼ŒéªŒè¯çš„æ—¶å€™åº”è¯¥è´ªå¿ƒçš„å–å°½å¯èƒ½æœ€å·¦è¾¹çš„ç‚¹ï¼Œç»™åçš„é€‰æ‹©ç•™æ›´å¤šçš„ä½™åœ°ï¼Œæ„Ÿæ€§ä¸Šè¿™æ˜¯æ­£ç¡®çš„ï¼ˆäº‹å®ä¸Šä¹Ÿæ˜¯æ­£ç¡®çš„ï¼‰ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; const long long MAXN = 1000000000000000000; typedef long long LL; pair\u0026lt;LL, LL\u0026gt; a[N]; int n, m; bool check(LL mid) { if (mid == 0) return true; LL cnt = 0, ls = -MAXN; for (int i = 1; i \u0026lt;= m; ++i) { // è¿™é‡Œçš„åˆ¤æ–­é€»è¾‘å¾ˆå®¹æ˜“æŒ‚ï¼Œåˆ«é—®æˆ‘æ€ä¹ˆçŸ¥é“çš„ if (ls + mid \u0026gt; a[i].second) continue; if (a[i].first - ls \u0026lt; mid) ls = ls + mid; else ls = a[i].first; cnt += (a[i].second - ls) / mid + 1; ls += (a[i].second - ls) / mid * mid; } return cnt \u0026gt;= n; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; ++i) { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a[i].first, \u0026amp;a[i].second); } sort(a + 1, a + m + 1); LL l = 0, r = MAXN; while (l \u0026lt; r) { LL mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } printf(\u0026#34;%lld\\n\u0026#34;, l); return 0; } G. å®è— è¿™é“é¢˜ä¹Ÿå¾ˆç®€å•ï¼Œçœ‹ç€åƒæ˜¯ä¸ªå›¾è®ºï¼Œå®é™…ä¸Šæ˜¯ä¸ªäºŒç»´ dpï¼Œå›¾éƒ½ä¸ç”¨å»ºå‡ºæ¥ã€‚è®° \\(f_{i, j} \\) è¡¨ç¤ºèµ°åˆ° i ç‚¹ç”¨äº† j ä½“åŠ›çš„æ—¶å®è—ä»·å€¼çš„æœ€å¤§å€¼ã€‚\\(f_{i, 0}\\) å…¶å®å°±æ˜¯ i å±±æ´é¢†ä¸€æ¬¡çš„å®è—ä»·å€¼ã€‚æ›´æ–°çŠ¶æ€æ—¶ä»ä½åˆ°é«˜æšä¸¾ jï¼Œå¯¹äºæ¯ä¸€ä¸ª j æšä¸¾æ‰€æœ‰è¾¹\n\\[f_{y, j} = \\max{{f_{y, j}, f_{x, j - w} + A_y}}\\]\næŠŠæ‰€æœ‰çš„ f å– max å¯ä»¥ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; using namespace std; const int M = 10010; const int N = 1010; struct ed { int x, y, z; } ed[M]; int f[N][510]; int main() { int res = 0; int n, m, t; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;t); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;f[i][0]); for (int i = 1; i \u0026lt;= m; ++i) scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;ed[i].x, \u0026amp;ed[i].y, \u0026amp;ed[i].z); for (int i = 1; i \u0026lt;= t; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { auto \u0026amp;[x, y, z] = ed[j]; if (i \u0026gt;= z) { f[y][i] = max(f[y][i], f[x][i - z] + f[y][0]); res = max(res, f[y][i]); } } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } ","date":"2025-05-24T10:01:29Z","permalink":"https://invalidnamee.github.io/p/2025st22/","title":"2025æ˜¥è®­ç¬¬äºŒåäºŒåœº"},{"content":"A. å‚»é¹¿å°–å¡” æ¯æ¬¡ä¸´æ­»å‰è´ªå¿ƒé€‰æ‹©å‰é¢èƒ½é€‰çš„æœ€å¤§çš„å³å¯ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„ä¸è¦ç›´æ¥ä¸­é€” breakï¼Œä¼šå½±å“ä¹‹åçš„è¯»å…¥ ğŸ˜­ğŸ˜­ğŸ˜­\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; int n, m, k; int a[100010]; priority_queue\u0026lt;int\u0026gt; q; int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { while (!q.empty()) q.pop(); bool fail = false; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int i = 1; i \u0026lt;= n; ++i) { m -= a[i]; q.push(a[i]); if (m \u0026lt;= 0 \u0026amp;\u0026amp; !q.empty() \u0026amp;\u0026amp; k) { k--; m += q.top(); q.pop(); } if (m \u0026lt;= 0) { fail = true; printf(\u0026#34;%d\\n\u0026#34;, i - 1); break; } } if (!fail) printf(\u0026#34;%d\\n\u0026#34;, n); } return 0; } B. æ ‘è”ç½‘ æ ‘å½¢ dp ç»Ÿè®¡å­æ ‘å¤§å°å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int head[N], ne[N * 2], ver[N * 2], w[N * 2], tot; int cnt[N], n; long long res = 0; void add(int x, int y, int z) { ver[++tot] = y; ne[tot] = head[x]; head[x] = tot; w[tot] = z; } void dp(int x, int fa) { cnt[x] = 1; for (int i = head[x]; i; i = ne[i]) { int y = ver[i]; if (y == fa) continue; dp(y, x); cnt[x] += cnt[y]; res += (long long)w[i] * abs(n - cnt[y] * 2); } } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt; n; ++i) { int x, y, z; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); add(x, y, z); add(y, x, z); } dp(1, 0); printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } å‰©ä¸‹çš„ä¸ä¼šäº†ğŸ˜‡\n","date":"2025-05-22T10:04:01Z","permalink":"https://invalidnamee.github.io/p/2025st21/","title":"2025æ˜¥è®­ç¬¬äºŒåä¸€åœº"},{"content":"ç¬¬ä¸€åœºæ‰“å®Œè§‰çš„éå¸¸æ°´ï¼Œäºæ˜¯ç¬¬äºŒåœºç«‹åˆ»å°±è¢«çœŸå®äº†ï¼Œå·²è€å®æ±‚æ”¾è¿‡ğŸ˜‡ğŸ˜‡ğŸ˜‡ã€‚\nA. èˆè¹ˆæœºå™¨äºº ç†Ÿæ‚‰çš„æƒ…å†µï¼Œç†Ÿæ‚‰çš„æ‰“è¡¨ï¼ˆ\næ‰“è¡¨\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; const int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; s; void dfs(int x, int y, int dep, int lim, bool f) { if (dep == lim) { s.insert({x, y}); return; } for (int i = f; i \u0026lt; 4; i += 2) { dfs(x + dx[i], y + dy[i], dep + 1, lim, f ^ 1); } } int main() { int n = 50; for (int i = 1; i \u0026lt;= 20; ++i) { s.clear(); dfs(0, 0, 0, i, 0); dfs(0, 0, 0, i, 1); cout \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; return 0; } /* 4 12 24 40 60 84 112 4 8 12 16 20 24 28 1 2 3 4 5 6 7 4 * n * (n - 1) / 2 */ AC ä»£ç \n1 2 3 4 5 6 7 n = int(input()) if n \u0026amp; 1: n = (n + 1) // 2 print(n * (n + 1) * 2) else: n = n // 2 + 1 print(n * n) B. ç‹—æ˜¯å•¥å‘€ è¿™é“æ¯”è¾ƒç®€å•ä¸€ç‚¹ï¼Œæ‰¾ä¸€ä¸ªå•æ¬¡ä¼¤å®³æœ€å¤§çš„ä½œä¸ºæœ€åä¸€å‡»ï¼Œå‰é¢çš„æ‰¾ä¸€ä¸ªå‡€ä¼¤å®³æœ€é«˜çš„ä¸€ç›´æ‰“å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; int main() { int n; long long x, mxd = LLONG_MIN, mxk = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; for (int i = 1; i \u0026lt;= n; ++i) { long long d, h; cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; h; mxk = max(mxk, d); mxd = max(mxd, d - h); } if (x \u0026lt;= mxk) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; else if (mxd \u0026lt;= 0) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 1 + (x - mxk + mxd - 1) / mxd \u0026lt;\u0026lt; endl; return 0; } C. æ¢çº½ çœ‹åˆ°è¿™é“é¢˜æˆ‘ç›´æ¥å°±æƒ³åˆ°äº†ç‚¹åŒè”é€šåˆ†é‡ç¼©ç‚¹ï¼Œäºæ˜¯å†™ç¼©ç‚¹å†™æŒ‚äº†ï¼ˆ-14ï¼‰â€¦â€¦\näº‹å®ä¸Šåªæœ‰ä¸€ç»„æŸ¥è¯¢ï¼Œå®Œå…¨å¯ä»¥æš´åŠ›è§£å†³ï¼Œä» a å‡ºå‘æœç´¢ï¼Œç»è¿‡ b å°±ç›´æ¥ return æŠŠæœåˆ°çš„ç‚¹æ‰“ä¸Šæ ‡è®°ï¼›åŒç†ä» b å‡ºå‘æ‰“æ ‡è®°ã€‚å¦‚æ­¤ï¼Œæ‰€æœ‰çš„ç‚¹è¢«åˆ†æˆä¸‰å¤§åŒºã€‚\nå¦‚æœä¸€ä¸ªç‚¹ä¸¤ä¸ªæ ‡è®°éƒ½å­˜åœ¨ï¼Œè¡¨æ˜ä»–å¯ä»¥åªç»è¿‡ a æˆ–è€… b åˆ°å…¶ä»–ä»»ä½•ç‚¹ï¼Œå¦åˆ™ä¸èƒ½ï¼›\nå¦‚æœåªæœ‰ a æˆ–è€… b çš„æ ‡è®°ï¼Œè¿™ä¸¤å—ç‚¹ä¹‹é—´å¿…é¡»ç»è¿‡ a å’Œ b æ‰è¡Œã€‚\næ‰€ä»¥ç­”æ¡ˆæ˜¯åªè¢« a æ ‡è®°çš„ç‚¹ä¸ªæ•° * åªè¢« b æ ‡è®°çš„ç‚¹ä¸ªæ•°ã€‚\nä¼˜é›…çš„åšæ³•\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010, M = 1000010; int head[N], ver[M], ne[M], tot = 1; bool vis[N][2]; void add(int x, int y) { ver[++tot] = y; ne[tot] = head[x]; head[x] = tot; } void dfs(int x, bool f, int t) { if (vis[x][f] || x == t) return; vis[x][f] = true; for (int i = head[x]; i; i = ne[i]) { int y = ver[i]; dfs(y, f, t); } } int main() { int n, m, a, b; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;a, \u0026amp;b); for (int i = 1; i \u0026lt;= m; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); add(x, y), add(y, x); } dfs(a, 0, b); dfs(b, 1, a); int t1 = 0, t2 = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (vis[i][0] \u0026amp;\u0026amp; !vis[i][1]) t1++; else if (vis[i][1] \u0026amp;\u0026amp; !vis[i][0]) t2++; } t1--, t2--; printf(\u0026#34;%lld\\n\u0026#34;, (long long)t1 * t2); return 0; } ä¸‘é™‹çš„åšæ³•ï¼ˆç¼©ç‚¹ï¼‰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; const int N = 200010, M = 1000010; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; s; int head[N], ver[M], ne[M], tot = 1; int dfn[N], low[N], t; int bcc_id[N], bcc_siz[N * 2], bcc_cnt; bool cut[N]; vector\u0026lt;int\u0026gt; ed[N * 2], bcc[N]; stack\u0026lt;int\u0026gt; st; int fa[N * 2], dep[N * 2]; void add(int x, int y) { ver[++tot] = y; ne[tot] = head[x]; head[x] = tot; } void tarjan(int x, int from) { dfn[x] = low[x] = ++t; st.push(x); int cnt = 0; for (int i = head[x]; i; i = ne[i]) { if (i == (from ^ 1)) continue; int y = ver[i]; if (!dfn[y]) { tarjan(y, i); low[x] = min(low[x], low[y]); if (dfn[x] \u0026lt;= low[y]) { cnt++; if (x != 1 || cnt \u0026gt; 1) cut[x] = true; bcc_cnt++; int tp; do { tp = st.top(); st.pop(); bcc_id[tp] = bcc_cnt; bcc_siz[bcc_cnt]++; bcc[bcc_cnt].push_back(tp); } while (tp != y); bcc_siz[bcc_cnt]++; bcc[bcc_cnt].push_back(x); } } else low[x] = min(low[x], dfn[y]); } } void dfs(int x) { for (int y : ed[x]) { if (y == fa[x]) continue; fa[y] = x; dep[y] = dep[x] + 1; dfs(y); bcc_siz[x] += bcc_siz[y]; } } int check(int x, int y) { while (x) { if (fa[x] == y) return x; x = fa[x]; } return 0; } int main() { int n, m, a, b; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;a, \u0026amp;b); for (int i = 1; i \u0026lt;= m; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); if (x == y) continue; if (x \u0026gt; y) swap(x, y); if (s.find({x, y}) != s.end()) continue; s.insert({x, y}); add(x, y), add(y, x); } tarjan(1, 0); for (int i = 1; i \u0026lt;= n; ++i) { if (cut[i]) { bcc_id[i] = ++bcc_cnt; bcc_siz[bcc_cnt] = 1; } } for (int i = 1; i \u0026lt;= bcc_cnt; ++i) { if (!bcc[i].empty()) { for (int x : bcc[i]) { if (cut[x]) { bcc_siz[i]--; ed[bcc_id[x]].push_back(i); ed[i].push_back(bcc_id[x]); } } } else break; } if (!cut[a] || !cut[b]) { printf(\u0026#34;0\\n\u0026#34;); } else { dfs(1); int x = bcc_id[a], y = bcc_id[b]; if (dep[x] \u0026gt; dep[y]) swap(x, y); int f = check(y, x); if (f) { // x æ˜¯ y çš„ç¥–å…ˆ printf(\u0026#34;%lld\\n\u0026#34;, (long long)(n - bcc_siz[f] - 1) * (bcc_siz[y] - 1)); } else { printf(\u0026#34;%lld\\n\u0026#34;, (long long)(bcc_siz[x] - 1) * (bcc_siz[y] - 1)); } } return 0; } D. é­”æ³•è¯æ°´ è¿™æ˜¯ä¸€é“ dp é¢˜ã€‚\nn â‰¤ 100ï¼Œæ„å‘³ç€æ¯ç§’é€’å¢çš„é­”åŠ›å€¼åªä¼šæ˜¯ 1 ~ 100 ä¹‹é—´çš„æ•´æ•°ã€‚æšä¸¾é€‰æ‹©çš„ç“¶æ•° tï¼Œç»´æŠ¤ä¸€ä¸ªçŠ¶æ€ \\(f_{i, j, k}\\) è¡¨ç¤ºå‰ i ç“¶è¯æ°´é€‰äº† j ç“¶ï¼Œé­”åŠ›å€¼ä¹‹å’Œå¯¹ t çš„ä½™æ•°ä¸º k æ—¶é­”åŠ›å€¼çš„æœ€å¤§å€¼ã€‚å¯¹äºæ¯ä¸€ä¸ª tï¼Œå¦‚æœå­˜åœ¨çŠ¶æ€ \\(f_{n, t, m % t}\\)ï¼Œå°±å°è¯•ç”¨è¿™ä¸ªçŠ¶æ€æ›´æ–°ç­”æ¡ˆã€‚\néœ€è¦ç‰¹åˆ«æ³¨æ„å¯¹æ¯ä¸€ä¸ª t æ˜¯å¦å­˜åœ¨åˆæ³•çš„æœ€ç»ˆçŠ¶æ€ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; long long f[110][110][110], a[110]; int main() { int n; long long m, res; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; res = m; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i]; } for (int t = 1; t \u0026lt;= n; ++t) { memset(f, -1, sizeof(f)); f[0][0][0] = 0; for (int i = 1; i \u0026lt;= n; ++i) { f[i][0][0] = 0; // i ä¸ª è¯æ°´ for (int j = 1; j \u0026lt;= t; ++j) { // é€‰äº† j ä¸ª for (int k = 0; k \u0026lt; t; ++k) { // ä½™æ•°æ˜¯ k f[i][j][k] = f[i - 1][j][k]; if (~f[i - 1][j - 1][((k - a[i]) % t + t) % t]) f[i][j][k] = max(f[i][j][k], f[i - 1][j - 1][((k - a[i]) % t + t) % t] + a[i]); } } } if (~f[n][t][m % t]) res = min(res, (m - f[n][t][m % t]) / t); } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-05-22T09:50:28Z","permalink":"https://invalidnamee.github.io/p/2025st20/","title":"2025æ˜¥è®­ç¬¬äºŒååœº"},{"content":"A. ç†Šå­©å­æ‰“å¡ ä¸€é“æ¯”è¾ƒæ°´çš„ç­¾åˆ°é¢˜ï¼Œå› ä¸ºæ•°æ®ä¸ç®—å¤ªå¤§ï¼Œç›´æ¥å¼€ map ç»Ÿè®¡å°±å¯ä»¥ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; map\u0026lt;int, int\u0026gt; mp; int main() { int n, res = 0, ls = __INT_MAX__; // æ•°æ®è‚¯å®šåˆ°ä¸äº† __INT_MAX__ scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); if (ls == t) continue; else { mp[t]++; ls = t; res++; } } for (auto [a, b]: mp) { printf(\u0026#34;%d %d\\n\u0026#34;, a, b); } return 0; } B. æœ€çœåŠ›æ•´ç†æ³• ä¸ç®¡æ€ä¹ˆæ¢æœ€åä½“åŠ›åº”è¯¥æ˜¯ä¸€æ ·çš„ï¼Œå› ä¸ºæ•°æ®æ¯”è¾ƒå°ï¼Œæ‰€ä»¥ç›´æ¥å†’æ³¡æ’åºå°±å¯ä»¥ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 5010; int a[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } long long res = 0; for (int i = 1; i \u0026lt; n; ++i) { for (int j = 1; j \u0026lt;= n - i; ++j) { if (a[j] \u0026gt; a[j + 1]) { res += max(a[j], a[j + 1]); swap(a[j], a[j + 1]); } } } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } C. ç©¿å¿ƒå’’ è¿™æ˜¯é«˜ä¸­é¢˜ï¼Œä¸¤åœ†çš„ä½ç½®å…³ç³»æœ‰ å†…å«ã€å†…åˆ‡ã€ç›¸äº¤ã€å¤–åˆ‡ã€å¤–ç¦»ï¼Œåˆ†åˆ«å¯¹åº” 0ã€1ã€2ã€1ã€0ï¼Œæ ¹æ®åœ†å¿ƒçš„è·ç¦»å’ŒåŠå¾„çš„å…³ç³»åˆ¤æ–­å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; int p(int x) { return x * x; } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int x1, y1, r1, x2, y2, r2; scanf(\u0026#34;%d%d%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;r1, \u0026amp;x2, \u0026amp;y2, \u0026amp;r2); if (x1 == x2 \u0026amp;\u0026amp; y1 == y2 \u0026amp;\u0026amp; r1 == r2) printf(\u0026#34;-1\\n\u0026#34;); else if (p(x1 - x2) + p(y1 - y2) \u0026gt; p(r1 + r2) || p(x1 - x2) + p(y1 - y2) \u0026lt; p(r1 - r2)) printf(\u0026#34;0\\n\u0026#34;); else if (p(x1 - x2) + p(y1 - y2) == p(r1 + r2) || p(x1 - x2) + p(y1 - y2) == p(r1 - r2)) printf(\u0026#34;1\\n\u0026#34;); else printf(\u0026#34;2\\n\u0026#34;); } return 0; } D. åƒç«é”… ä¹‹å‰æŸæ¬¡è®­ç»ƒèµ›çš„ A é¢˜ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 510; const int M = 250010; const int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; int a[N][N], n; vector\u0026lt;int\u0026gt; ed[M]; int deg[M], f[M]; int calc(int x, int y) { return (x - 1) * n + y; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); } } for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { for (int k = 0; k \u0026lt; 4; ++k) { int x = i + dx[k], y = j + dy[k]; if (x \u0026gt; 0 \u0026amp;\u0026amp; x \u0026lt;= n \u0026amp;\u0026amp; y \u0026gt; 0 \u0026amp;\u0026amp; y \u0026lt;= n \u0026amp;\u0026amp; a[i][j] \u0026lt; a[x][y]) { ed[calc(i, j)].push_back(calc(x, y)); deg[calc(x, y)]++; } } } } queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n * n; ++i) { if (deg[i] == 0) q.push(i), f[i] = 1; } while (!q.empty()) { int x = q.front(); q.pop(); for (int y : ed[x]) { f[y] = max(f[y], f[x] + 1); if (--deg[y] == 0) q.push(y); } } int res = 0; for (int i = 1; i \u0026lt;= n * n; ++i) { res = max(res, f[i]); } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } E. å¥—è·¯æ¯”èµ› å¯ä»¥ç”¨åˆ†å—æ¥åšï¼ŒæŠŠ \\(n\\)ä¸ªæ•°æŒ‰ç…§é™¤ä»¥ \\(\\lfloor \\sqrt n \\rfloor\\) çš„ä½™æ•°åˆ†æˆ \\(\\lceil \\sqrt n \\rceil\\)å—ã€‚\nç¬¬ i è½®æ·˜æ±°ï¼Œéœ€è¦æ‰¾ \\(m\\ \\text{mod}\\ (n - i)\\) ä¸ªäººï¼Œå¦‚æœä¸ºé›¶ï¼Œå°±èµ‹å€¼æˆ n - iï¼Œæˆ‘ä»¬æŠŠè¿™ä¸ªäººæ•°è®°ä¸º tï¼›\næ¯æ¬¡æ·˜æ±°å…ˆä»å½“å‰çš„äººæ‰€åœ¨çš„å—å†…å¼€å§‹æš´åŠ›éå†ï¼Œé‡åˆ°æœªè¢«æ·˜æ±°çš„å°± t -= 1ï¼›\nå¦‚æœæˆåŠŸåœ¨å—å†…æ‰¾åˆ°äº†ä¸‹ä¸€ä¸ªè¢«æ·˜æ±°çš„ï¼ˆt == 0ï¼‰ï¼Œæ ‡è®°ä¸Šï¼Œå¹¶æŠŠå½“å‰å—çš„è®¡æ•° - 1ï¼Œè¿›è¡Œä¸‹ä¸€è½®æ·˜æ±°ï¼›\nå¦åˆ™æŒ‰å—éå†ï¼Œt -= å—å†…å‰©ä½™çš„äººæ•°ï¼ˆè¿™ä¸ªå€¼å¯ä»¥é¢„å…ˆç»´æŠ¤å¥½ï¼‰ï¼Œç›´åˆ°æŸä¸ªå—å†…å‰©ä½™çš„äººæ•°æ¯” t å¤šï¼Œæš´åŠ›éå†è¯¥å—ï¼Œç›´åˆ° t == 0ï¼Œæ·˜æ±°æ‰è¿™ä¸ªäººã€‚\nä»¥æ­¤ç±»æ¨ï¼Œæ‰§è¡Œ n - 1 æ¬¡ï¼Œå‰©ä¸‹çš„äººå°±æ˜¯ç­”æ¡ˆã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 /* æˆ‘è¿™é‡ŒæŠŠä¸‹æ ‡ç»Ÿä¸€å¾€å‰ç§»äº†ä¸€ä½ï¼Œä¸ºäº†æ–¹ä¾¿å–æ¨¡ */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; bool f[100010]; int siz[333]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int L = sqrt(n), cnt = n / L; for (int i = 0; i \u0026lt; n; ++i) { f[i] = true; siz[i / L]++; } int cur = 0; for (int i = 1; i \u0026lt; n; ++i) { int t = m % (n - i + 1), cur_bk = cur / L; if (!t) t = n - i + 1; while (cur / L == cur_bk \u0026amp;\u0026amp; t) { t -= f[cur]; cur++; cur %= n; } if (!t) { int tt = (cur - 1 + n) % n; f[tt] = false; siz[tt / L]--; } else { cur_bk = cur / L; while (siz[cur_bk] \u0026lt; t) { t -= siz[cur_bk]; cur_bk++; cur_bk %= cnt + 1; } cur = cur_bk * L; while (t) { t -= f[cur]; cur++; cur %= n; } int tt = (cur - 1 + n) % n; f[tt] = false; siz[tt / L]--; } } for (int i = 0; i \u0026lt; n; ++i) { if (f[i]) { printf(\u0026#34;%d\\n\u0026#34;, i + 1); return 0; } } return 0; } /* 0 1 2 3 4 5 6 7 8 9 0 1 _ 3 4 5 6 7 8 9 0 1 _ 3 4 _ 6 7 8 9 0 1 _ 3 4 _ 6 7 _ 9 0 _ _ 3 4 _ 6 7 _ 9 0 _ _ 3 4 _ _ 7 _ 9 _ _ _ 3 4 _ _ 7 _ 9 _ _ _ 3 4 _ _ _ _ 9 _ _ _ 3 _ _ _ _ _ 9 _ _ _ 3 _ _ _ _ _ _ */ F. çŸ³å­åˆå¹¶ å¦‚æœæ•°æ®å°çš„è¯ï¼Œç›´æ¥ç”¨ STL çš„å †å°±å¯ä»¥åšï¼Œä½†æ˜¯ä»–æ²¡ç»™æ•°æ®èŒƒå›´ï¼Œæ‰€ä»¥æˆ‘é‡‡å–äº†æ‰“è¡¨ + æ‰¾è§„å¾‹çš„åšæ³•ã€‚\nç­”æ¡ˆ = \\(1 Â· 0 + 2^0 Â· 2 + 2^1 Â· 3 + 2^2 Â· 4 + \\dots + (n - 1 - 2^0 - 2^1 - 2^2 - \\dots) Â· k\\).\nä»£ç ä¸­æ³¨é‡Šæ‰çš„æ˜¯æ‰“è¡¨çš„è¿‡ç¨‹ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; // priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; // long long res[101], t[101]; int main() { unsigned long long n, res = 0; cin \u0026gt;\u0026gt; n; int i = 0; n--; while (n) { if (n \u0026gt;= (1ull \u0026lt;\u0026lt; i)) res += (1ull \u0026lt;\u0026lt; i) * (i + 2), n -= (1ull \u0026lt;\u0026lt; i); else res += n * (i + 2), n = 0; i++; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; // for (int t = 1; t \u0026lt;= 100; ++t) { // int i = 0; // n = t - 1; // while (n) { // if (n \u0026gt;= (1ull \u0026lt;\u0026lt; i)) res += (1ull \u0026lt;\u0026lt; i) * (i + 2), n -= (1ull \u0026lt;\u0026lt; i); // else res += n * (i + 2), n = 0; // i++; // } // cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // res = 0; // // for (int i = 1; i \u0026lt;= n; ++i) q.push(1); // // while (q.size() \u0026gt; 1) { // // int x = q.top(); q.pop(); // // int y = q.top(); q.pop(); // // q.push(x + y); // // res[n] += x + y; // // } // // q.pop(); // } // for (int i = 1; i \u0026lt;= 100; ++i) t[i] = res[i] - res[i - 1]; // for (int i = 1; i \u0026lt;= 100; ++i) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // cout \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-05-18T14:28:05Z","permalink":"https://invalidnamee.github.io/p/2025st19/","title":"2025æ˜¥è®­ç¬¬åä¹åœº"},{"content":"åºŸæ‰äº†ï¼Œæ‹¼å°½å…¨åŠ›æ— æ³•æˆ˜èƒœï¼Œåšçš„æ—¶å€™æ„Ÿè§‰è‡ªå·±å·®ç‚¹çˆ†é›¶ï¼Œä»¥ 3 / 8 çš„ä¼˜å¼‚æˆç»©æ‹¿ä¸‹æ¦œä¸€ã€‚è¿™å¥—é¢˜å‰é¢çš„é¢˜éƒ½æ˜¯ä¸»æ‰“ä¸€ä¸ªç›´è§‰ä¸Šçš„æ¬ºéª—ï¼Œåé¢éš¾çš„ä¸ä¼šåšã€‚\nA. åºåˆ—é‡æ’ é¦–å…ˆï¼Œç»“è®ºæ˜¯ç­”æ¡ˆåªå¯èƒ½æ˜¯ 0, 1, 2ã€‚\nåºåˆ—ä¸­ 0 çš„ä¸ªæ•°ä¸è¶…è¿‡ \\(\\lfloor \\frac{n + 1}{2} \\rfloor\\)ï¼ŒæŠŠ 0 ç©¿æ’åˆ°å…¶ä»–æ•°ä¸­é—´è‚¯å®šæ˜¯å¯ä»¥æ”¾å¾—ä¸‹çš„ï¼Œæ‰€ä»¥ç­”æ¡ˆæ˜¯ 0ï¼›\nå¦‚æœä¸æ»¡è¶³ä¸Šè¿°æ¡ä»¶ï¼Œ0 ä¸èƒ½éƒ½ç©¿æ’åˆ°å…¶ä»–æ•°ä¸­é—´ï¼Œé‚£ä¹ˆä¸€å®šæœ‰ç›¸é‚»çš„æ•°åŠ èµ·æ¥æ˜¯ 0ï¼Œåªèƒ½è€ƒè™‘å‰©ä½™çš„æ•°ï¼Œæˆ‘ä»¬è¦å°½å¯èƒ½ç©ºå‡ºæ¥æœ€å°çš„æ•°ã€‚é¦–å…ˆè€ƒè™‘ç©ºå‡ºæ¥ 1ï¼Œé™¤éé™¤äº† 0 éƒ½æ˜¯ 1ï¼Œå¦åˆ™è®©ä»»æ„ä¸€ä¸ª ä¸æ˜¯ 1 çš„æ•°å’Œä¸€å¤§å † 0 ç›¸é‚»ï¼Œå‰©ä¸‹çš„ 1 éƒ½æ”¾ä¸€å—ï¼Œè¿™æ · 1 å°±èƒ½ç©ºå‡ºæ¥äº†ï¼Œæ‰€ä»¥å¦‚æœè‡³å°‘æœ‰ä¸€ä¸ªæ•°ä¸æ˜¯ 1ï¼Œé‚£ä¹ˆç­”æ¡ˆæ˜¯ 1ï¼›å¦‚æœå…¨æ˜¯ 1ï¼Œé‚£æ²¡åŠæ³•ç©ºå‡º 1 äº†ï¼Œå°±å°½å¯èƒ½ç©ºå‡º 2ï¼Œæ˜¾ç„¶æ˜¯å¯è¡Œçš„ï¼ŒæŠŠ 0 å’Œ 1 äº¤å‰æ”¾ï¼Œæ‰€æœ‰çš„å’Œéƒ½æ˜¯ 0 æˆ–è€… 1ï¼Œå°±ç©ºå‡ºäº† 2ï¼Œæ‰€ä»¥ç­”æ¡ˆæ˜¯ 2ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int a[1000010]; int main() { int n, zcnt = 0, m = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[++m]); if (!a[m]) zcnt++; } sort(a + 1, a + m + 1); if (zcnt \u0026lt;= (n + 1) / 2) printf(\u0026#34;0\\n\u0026#34;); else if (a[m] == 1) printf(\u0026#34;2\\n\u0026#34;); else printf(\u0026#34;1\\n\u0026#34;); return 0; } B. åˆ’åˆ† è¿™é“é¢˜ä¹Ÿæ˜¯ï¼Œåªæ˜¯çœ‹èµ·æ¥éš¾ï¼Œä½†æ˜¯å®é™…ä¸Šåªéœ€è¦é¢„å¤„ç†å‰ç¼€å’Œï¼Œåªè€ƒè™‘åˆ†æˆä¸¤æ®µçš„æƒ…å†µå³å¯ã€‚\nWhyï¼Ÿå› ä¸ºå‡è®¾æœ€å¤§çš„ç»“æœæ˜¯åˆ†æˆå¤šå—å¾—åˆ°çš„ï¼Œé‚£ä¹ˆéšæ„æ‰¾ä¸€ä¸ªåˆ†å—çš„è¾¹ç•Œä¸ºå‚è€ƒç‚¹å·¦ä¾§åˆ†ä¸€å—å³ä¾§åˆ†ä¸€å—ï¼Œæœ€å¤§å…¬çº¦æ•°æ˜¾ç„¶ä¸å˜ï¼Œæ‰€ä»¥åˆ†ä¸¤æ®µä¸€å®šä¼šåŒ…å«æ‰€æœ‰åˆ†å¤šå—çš„æƒ…å†µã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; long long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; } const int N = 100010; long long s[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;s[i]); s[i] += s[i - 1]; } long long res = 0; for (int i = 1; i \u0026lt; n; ++i) { res = max(res, gcd(s[n] - s[i], s[i])); } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } C. è›‹ç³• å¯ä»¥ç”¨è´ªå¿ƒçš„æ€æƒ³ï¼Œèƒ½ä¸åˆ‡å°±ä¸åˆ‡ï¼Œå®åœ¨æ˜¯è¿«ä¸å¾—å·²äº†å†åˆ‡ã€‚\né¦–å…ˆæŠŠ n äºŒè¿›åˆ¶æ‹†åˆ†ï¼Œä»ä½åˆ°é«˜éå†äºŒè¿›åˆ¶ä½ï¼Œå¦‚æœè¿™ä¸€ä½æ˜¯ 1 è€Œä¸”æ­£å¥½æœ‰ç°æˆçš„é‚£å°±ç›´æ¥ç”¨ä¸€ä¸ªç°æˆçš„ï¼Œç„¶åæŠŠå‰©ä¸‹çš„è›‹ç³•ä¸¤ä¸¤é…å¯¹ç»„æˆå¤§çš„ç»™åé¢å¤‡ç”¨ï¼›å¦‚æœæ²¡æœ‰ï¼Œå°±ä»å³è¾¹æ‰¾æœ€è¿‘çš„æœ‰è›‹ç³•çš„ä½ç½®ï¼Œä¸€ç›´åˆ‡ç›´åˆ°æœ‰ï¼Œç„¶åç”¨æ‰ä¸€ä¸ªåˆ‡å‡ºæ¥çš„ï¼›å¦‚æœæ˜¯ 0 ä¸ç”¨å¤„ç†ï¼Œç›´æ¥æŠŠæ‰‹ä¸Šçš„éƒ½ç»„æˆå¤§çš„ç»™åé¢å¤‡ç”¨ã€‚\nä¸€è½®æµç¨‹è·‘ä¸‹æ¥ä¹‹åå°±èƒ½å‡‘å‡ºæ¥ n äº†ã€‚\næ­£ç¡®æ€§ï¼šå¦‚æœèƒ½å‡‘å‡ºæ¥ï¼Œé‚£ä¹ˆæ‰‹ä¸Šçš„è›‹ç³•æ€»å’Œä¸€å®šä¸å°äº nï¼Œå¯¹äºä½ä½å‰©ä¸‹çš„é›¶å¤´ä»–æ— æ³•å¯¹ä»»ä½•é«˜ä½åšå‡ºè´¡çŒ®ï¼Œå³ä½¿åˆ‡å‰²å¤§çš„æ¥ç»™ä»–è¡¥ä¸€ä¸‹ä¹Ÿæ˜¯æ— æ•ˆæ“ä½œï¼Œå› ä¸ºä¸€æ¥å°±æ˜¯ 2 ä¸ªï¼Œå‰©ä¸‹çš„é›¶å¤´è¿˜æ˜¯å‡‘ä¸å›å»ï¼Œä»–æ³¨å®šåªèƒ½å‰©ç€ï¼ŒæŠŠå¤šä½™çš„å¾€é«˜ä½å‡‘å·²ç»æœ€å¤§ç¨‹åº¦çš„åˆ©ç”¨äº†æ‰€æœ‰äºŒè¿›åˆ¶ä½ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int cnt[64]; int main() { long long n, tot = 0; int m; scanf(\u0026#34;%lld%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; ++i) { long long t; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;t); cnt[(int)(log2(t) + 0.3)]++; tot += t; } if (tot \u0026lt; n) { printf(\u0026#34;-1\\n\u0026#34;); return 0; } int res = 0; for (int i = 0; i \u0026lt; 64; ++i) { if (i \u0026gt; 0) cnt[i] += cnt[i - 1] / 2, cnt[i - 1] %= 2; if (n \u0026gt;\u0026gt; i \u0026amp; 1) { if (cnt[i]) cnt[i]--; else { int p = -1; for (int j = i; j \u0026lt; 64; ++j) { if (cnt[j]) { p = j; break; } } for (int j = p; j \u0026gt; i; --j) { cnt[j]--; cnt[j - 1] += 2; res++; } if (!cnt[i]) return 123; cnt[i]--; } } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } ","date":"2025-04-14T08:07:18Z","permalink":"https://invalidnamee.github.io/p/2025st18/","title":"2025æ˜¥è®­ç¬¬åå…«åœº"},{"content":"A. æœ€å¤§å…¬çº¦æ•° ç›´æ¥æšä¸¾ 1 ~ n å¯¹äºæ¯ä¸€ä¸ªæ•°ä»ä»–ä¸ç­‰äºè‡ªå·±çš„çº¦æ•°é‡Œé¢æ‰¾ä¸ªæœ€å¤§çš„ï¼Œç„¶åå…¨éƒ¨å–ä¸ª maxã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { int n, res = 1; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { int l = sqrt(i); for (int j = 2; j \u0026lt;= l; ++j) { if (i % j == 0) { res = max(res, i / j); break; } } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } B. æ•°çš„å˜æ¢ éå¸¸çš„æ°´ã€‚\nçº¦æ•°ä¸­æ¯æœ‰ä¸€ä¸ªçº¦æ•° 2ï¼Œæ¬¡æ•° + 1ï¼›\næ¯æœ‰ä¸€ä¸ªçº¦æ•° 3ï¼Œæ¬¡æ•° + 2ï¼ˆå› ä¸ºç®—å®Œä¹‹åè¿˜éœ€è¦å¤„ç†é€ å‡ºæ¥çš„ä¸€ä¸ª 2ï¼›\næ¯æœ‰ä¸€ä¸ªçº¦æ•° 5ï¼Œæ¬¡æ•° + 3ï¼ˆå› ä¸ºç®—å®Œä¹‹åè¿˜éœ€è¦å¤„ç†é€ å‡ºæ¥çš„ä¸¤ä¸ª 2ï¼‰ï¼›\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { long long n, t = 0; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); while (n % 5 == 0) n /= 5, t += 3; while (n % 3 == 0) n /= 3, t += 2; while (n % 2 == 0) n /= 2, t ++; if (n == 1) printf(\u0026#34;%lld\\n\u0026#34;, t); else printf(\u0026#34;-1\\n\u0026#34;); } return 0; } C. å›æ–‡ è¿™é“é¢˜å…¶å®å¯ä»¥ç›´æ¥æš´åŠ›ï¼Œå› ä¸ºä¸€å…±åªå¯èƒ½æœ‰ \\(\\binom{2}{26}\\)ç§å¯èƒ½çš„ä¸èƒ½é…å¯¹çš„æ–¹å¼ï¼Œäºæ˜¯å°±æœ‰ä¸å¤šäº \\(\\binom{2}{26}^2\\)ç§å¯èƒ½çš„äº¤æ¢æƒ…å†µï¼Œäºæ˜¯ç›´æ¥æšä¸¾æ‰€æœ‰æƒ…å†µäº¤æ¢å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; int a[26]; map\u0026lt;pair\u0026lt;int, int\u0026gt;, int\u0026gt; mp; int mn = 0x3f3f3f3f; int ord(char c) { return c - \u0026#39;a\u0026#39;; } long long getmin(int x, int y) { return min(min(a[x], a[y]), mn * 2); } int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; 26; ++i) { cin \u0026gt;\u0026gt; a[i]; mn = min(mn, a[i]); } string s; cin \u0026gt;\u0026gt; s; s = \u0026#39; \u0026#39; + s; long long res = 0; for (int i = 1; i \u0026lt;= (n / 2); ++i) { if (s[i] != s[n - i + 1]) { res += min(min(a[ord(s[i])], a[ord(s[n - i + 1])]), mn * 2); int lv = ord(s[i]), rv = ord(s[n - i + 1]); if (lv \u0026gt; rv) swap(lv, rv); mp[{lv, rv}]++; } } long long ss = 0; for (auto [p, t] : mp) { if (t \u0026gt; 1) { ss = min(ss, -2ll * min(min(a[p.first], a[p.second]), mn * 2)); } for (auto [pp, _] : mp) { if (pp == p) continue; ss = min(ss, min( getmin(p.first, pp.first) + getmin(p.first, pp.second), getmin(p.first, pp.second) + getmin(p.second, pp.first) ) - getmin(p.first, p.second) - getmin(pp.first, pp.second) ); } } res = min(res, res + ss); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } E. èˆ¹é•¿çš„è‡ªåŠ©é¤ ä¸€é“æ•°æ®æ¯”è¾ƒå‹å¥½çš„ dp é¢˜ï¼Œè‡³äºæˆ‘ä¸ºä»€ä¹ˆåœ¨çº¢æ¸©ï¼Œå½“ç„¶æ˜¯æ²¡å¥½å¥½è¯»é¢˜å°±å»åšäº† ğŸ˜‡ğŸ˜‡ğŸ˜‡\nè¿ç€åƒ \\(\\lceil \\log_{\\frac{2}{3}}{M} \\rceil\\)æ¬¡èƒƒå®¹é‡å°±å˜æˆ 0 äº†ï¼Œå½“ç„¶å¦‚æœä½ æ²¡å‘ç°è¿™ä¸ªï¼Œç›´æ¥æŠŠèƒƒå®¹é‡æ•´ä¸ªå½“ä¸€ä¸ªçŠ¶æ€å¡è¿›å»åº”è¯¥ä¹Ÿæ˜¯ä¸ä¼š TLE çš„ï¼Œå¦‚æœèƒ½ç¦»æ•£åŒ–ä¸€ä¸‹ä¼šæ›´å¿«ã€‚\nè®° \\(f_{i, j, 1}\\) ä¸ºåƒåˆ°ç¬¬ i å¤©ï¼Œå·²ç»è¿ç»­åƒäº† j æ¬¡ï¼Œå¹¶ä¸”ç¬¬ i å¤©åƒäº†çš„æƒ…å†µä¸‹èƒ½åƒçš„æœ€å¤§å€¼ï¼› \\(f_{i, j, 0}\\) ä¸ºç¬¬ i å¤©æ²¡åƒçš„æƒ…å†µä¸‹çš„æœ€å¤§å€¼ã€‚\n\\[f_{i, 1, 0} = \\max { f_{i - 1, j, 0} }\\]\n\\[f_{i, j, 0} = \\max {f_{i - 1, j, 0}, f_{i - 1, j, 1} } \\ (j \\neq 1)\\]\n\\[f_{i, j, 1} = \\max{f_{i - 1, j, 0} + \\min {m_j, A_i}, f_{i - 1, j - 1, 1} + \\min {m_j, a_i } } \\ (m_j = è¿ç»­åƒäº† j æ¬¡åèƒƒå®¹é‡)\\]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #define int long long using namespace std; const int N = 1010; int n, m[70], a[N]; long long f[N][70][2]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m[1]); int l; for (l = 2; m[l - 1]; ++l) m[l] = m[l - 1] * 2 / 3; l--; for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= l; ++j) { f[i][1][0] = max(f[i][1][0], f[i - 1][j][0]); } for (int j = 1; j \u0026lt;= l; ++j) { f[i][j][0] = max(f[i][j][0], max(f[i - 1][j][0], f[i - 1][j][1])); } f[i][1][1] = f[i - 1][1][0] + min(m[1], a[i]); for (int j = 2; j \u0026lt;= l; ++j) { f[i][j][1] = max(f[i - 1][j][0] + min(m[j], a[i]), f[i - 1][j - 1][1] + min(m[j], a[i])); } } long long res = 0; for (int i = 1; i \u0026lt;= l; ++i) { res = max(res, max(f[n][i][0], f[n][i][1])); } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } ","date":"2025-04-14T07:40:29Z","permalink":"https://invalidnamee.github.io/p/2025st17/","title":"2025æ˜¥è®­ç¬¬åä¸ƒåœº"},{"content":"å·®ç‚¹å°± ak äº†ï¼Œæœ‰ç‚¹å¯æƒœï¼Œæ„Ÿè°¢å­¦å§æ‰‹ä¸‹ç•™æƒ…ğŸ˜­ã€‚\nA. Number Maximization ç­¾åˆ°é¢˜ * 1\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { string s; cin \u0026gt;\u0026gt; s; sort(s.begin(), s.end(), greater\u0026lt;char\u0026gt;()); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } B. Simplified Calendar System ç­¾åˆ°é¢˜ * 2\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b, c, d, e, f, g; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d \u0026gt;\u0026gt; e \u0026gt;\u0026gt; f \u0026gt;\u0026gt; g; cout \u0026lt;\u0026lt; (d - 1 + (e - a) + (f - b) * 30 + (g - c) * 360) % 7 + 1 \u0026lt;\u0026lt; endl; return 0; } C. Letter Frequency ç­¾åˆ°é¢˜ * 3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; string s[30]; int main() { int n, len = 0; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; s[i]; len = max(len, (int)s[i].length()); } for (int i = 1; i \u0026lt;= len; ++i) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34;; map\u0026lt;char, int\u0026gt; mp; for (int j = 1; j \u0026lt;= n; ++j) { if (s[j].length() \u0026gt;= i) mp[s[j][i - 1]]++; } int mx = 0; for (auto [a, b] : mp) mx = max(mx, b); for (auto [a, b] : mp) if (b == mx) cout \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; a; cout \u0026lt;\u0026lt; endl; } return 0; } D. Pseudo Pseudo Random Numbers æ•°æ®éå¸¸çš„å°ï¼Œæ‰€ä»¥ç›´æ¥æš´åŠ›æšä¸¾æ£€æŸ¥å°±è¡Œï¼Œç­¾åˆ°é¢˜ * 4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; int n, k; bool check(int mask) { int ls = -1, len = 0; for (int i = 0; i \u0026lt; n; ++i) { if ((mask \u0026gt;\u0026gt; i \u0026amp; 1) != ls) len = 1; else len++; ls = mask \u0026gt;\u0026gt; i \u0026amp; 1; if (len \u0026gt; k) return false; } return true; } int main() { int t = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) { if (check(i)) t++; } cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; return 0; } E. Word Tree æ²¡ä»€ä¹ˆç‰¹åˆ«çš„ï¼Œå°±æ˜¯æœ€å°ç”Ÿæˆæ ‘ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; string s[1010]; int fa[1010]; vector\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; ed; int dis(string a, string b) { int n = a.length(); int d = 0; for (int i = 0; i \u0026lt; n; ++i) { d += abs(a[i] - b[i]); } return d; } int getfa(int x) { return x == fa[x] ? x : fa[x] = getfa(fa[x]); } int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n, l; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; l; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; s[i]; fa[i] = i; for (int j = 1; j \u0026lt; i; ++j) { ed.push_back({dis(s[i], s[j]), {i, j}}); } } int res = 0; sort(ed.begin(), ed.end()); for (auto [w, p] : ed) { int x = getfa(p.first), y = getfa(p.second); if (x == y) continue; else { fa[y] = x; res = max(res, w); } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } F. House Prices Going Up æ ‘çŠ¶æ•°ç»„ï¼ˆçº¿æ®µæ ‘ï¼‰æ¨¡æ¿é¢˜ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 500010; long long tr[N]; int n; void add(int u, int v) { for (; u \u0026lt;= n; u += u \u0026amp; -u) { tr[u] += v; } } long long query(int u) { long long res = 0; for (; u; u -= u \u0026amp; -u) { res += tr[u]; } return res; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); add(i, t); } int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while (q--) { char s[2]; int x, y; scanf(\u0026#34;%s%d%d\u0026#34;, s, \u0026amp;x, \u0026amp;y); if (s[0] == \u0026#39;U\u0026#39;) add(x, y); else printf(\u0026#34;%lld\\n\u0026#34;, query(y) - query(x - 1)); } return 0; } G. Which Number åˆ°è¿™é‡Œéš¾åº¦å¼€å§‹æ­£å¸¸äº†ï¼Œè¿™é“é¢˜æ˜¯äºŒåˆ†ç­”æ¡ˆ+å®¹æ–¥åŸç†ï¼Œå…ˆäºŒåˆ†ç­”æ¡ˆï¼Œç„¶åç”¨å®¹æ–¥åŸç†æ£€æŸ¥å‰é¢åˆæ³•çš„æ•°çš„ä¸ªæ•°ã€‚\næˆ‘ä¸æ… WA äº†ä¸€æ¬¡å¥½åƒæ˜¯çˆ† long long äº†ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; using namespace std; long long a[20], k; long long n; bool check(long long mid) { __int128_t cnt = 0; for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; k); ++mask) { __int128_t t = 1; int op = 0; for (int j = 0; j \u0026lt; k; ++j) { if (mask \u0026gt;\u0026gt; j \u0026amp; 1) { op++; t *= a[j]; } } op = (op \u0026amp; 1) ? -1 : 1; cnt += (mid / t) * op; } return cnt \u0026gt;= n; } int main() { scanf(\u0026#34;%lld%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 0; i \u0026lt; k; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); } __int128_t l = 1, r = __LONG_LONG_MAX__; while (l \u0026lt; r) { long long mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } printf(\u0026#34;%lld\\n\u0026#34;, (long long)l); return 0; } I. Share Auction åˆæ˜¯ä¸€é“äºŒåˆ†é¢˜ï¼Œè€ƒè™‘è¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼Œå¯¹äºä¸€ä¸ª lot å¦‚æœä¸€å—ä¸€å—çš„ bid æ¯ä¸€å—çš„æ”¶ç›Šéƒ½ä¼šé€æ¸å‡å°ï¼Œç›®æ ‡çŠ¶æ€æ˜¯ä½¿å¾—æœ€å bid äº† v ä¹‹åç›®æ ‡çŠ¶æ€æ˜¯ä¸€ä¸ªç›¸å¯¹å‡åŒ€çš„çŠ¶æ€ã€‚å…·ä½“æ¥è¯´æ˜¯è®©å…¶ä¸­çš„ä¸€éƒ¨åˆ†ï¼ˆæœ‰å¯èƒ½æ˜¯å…¨éƒ¨ï¼‰åœ¨æŠ•äº† v ä¹‹åå†æŠ• 1 æ—¶æˆ–è€…çš„æ”¶ç›Šåœ¨è¯¯å·®å…è®¸çš„èŒƒå›´å†…å°½å¯èƒ½ç›¸ç­‰ï¼Œè¿™æ ·å°±èƒ½æœ€å¤§ç¨‹åº¦ä¿è¯æ¯æ¬¡æŠ•çš„éƒ½æ˜¯æœ€ä¼˜è§£ã€‚\näºæ˜¯å¯ä»¥äºŒåˆ†æœ€ç»ˆæŠ•ä¸€å—é’±çš„æ”¶ç›Šï¼Œç„¶åè®¡ç®—æƒ³æŠŠæ”¶ç›Šå‹åˆ° â‰¤ mid çš„æ—¶å€™éœ€è¦ bid å¤šå°‘ï¼Œå’Œ v æ¯”è¾ƒï¼Œæ‰¾åˆ°ä¸€ä¸ªå°½å¯èƒ½æ¥è¿‘ v çš„ï¼ˆå¯ä»¥ç¨å¾®å¤§ä¸€ç‚¹ï¼Œå› ä¸ºæœ‰çš„æƒ…å†µæœ€åå¥½å‡ ä¸ªéƒ½ç›¸ç­‰ï¼Œä¸€é™ä½æ¯ä¸ªéƒ½å¾— bid 1ï¼Œæ— æ³•åˆ° vï¼Œä½†æ˜¯ä¸å½±å“æœ€åè®¡ç®—ï¼Œå› ä¸ºéƒ½ä¸€æ ·ï¼Œæœ€åæŠ•å“ªä¸ªéƒ½è¡Œï¼‰ã€‚æ‰¾åˆ°ä¹‹åæŒ‰äºŒåˆ†çš„ check å‡½æ•°çš„é€»è¾‘å†è·‘ä¸€æ¬¡ï¼Œè¿™ä¸€æ¬¡è¦åŠ ä¸Šæœ€å¤§é™åˆ¶ vï¼Œè·‘çš„è¿‡ç¨‹ä¸­è®°å½•æ”¶ç›Šç´¯åŠ å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 100010; struct Node { double rate; int tot_val; int voted = 0, other_vote; bool operator \u0026lt;(const Node \u0026amp;_) const { return rate \u0026lt; _.rate; } double vote(int t) { double r = (double)voted / (voted + other_vote) * tot_val; voted += t; rate = (double)(voted + 1) / (voted + other_vote + 1) * tot_val - (double)voted / (voted + other_vote) * tot_val; return (double)voted / (voted + other_vote) * tot_val - r; } } a[N]; int n, v; long long check(double val) { long long res = 0; for (int i = 1; i \u0026lt;= n; ++i) { int l = 0, r = 100000000; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; auto bk = a[i]; bk.vote(mid); if (bk.rate \u0026lt; val) r = mid; else l = mid + 1; } res += l; } return res; } int main() { double L = 0, R = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;v); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[i].tot_val, \u0026amp;a[i].other_vote); a[i].vote(0); R = max(R, a[i].rate); } while (R - L \u0026gt; 1e-9) { double mid = (L + R) / 2; if (check(mid) \u0026gt;= v) L = mid; else R = mid; } double res = 0; for (int i = 1; i \u0026lt;= n; ++i) { int l = 0, r = v; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; auto bk = a[i]; bk.vote(mid); if (bk.rate \u0026lt; L) r = mid; else l = mid + 1; } res += a[i].vote(l); v -= l; } if (v) return 123; else printf(\u0026#34;%f\\n\u0026#34;, res); return 0; } J. Desert Travel åŸºæœ¬åŠŸå¤§è€ƒæ ¸ï¼Œæœ€å°ç”Ÿæˆæ ‘ + æ ‘ä¸Šå€å¢ï¼Œæ€ç»´éš¾åº¦ä¸æ˜¯å¾ˆå¤§ï¼Œä½†æ˜¯æ¯”è¾ƒæœ‰æ“ä½œéš¾åº¦ï¼Œè¿™ä¸­é—´ç‚¸äº†æ­»å“ªéƒ½ä¸çŸ¥é“ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 5010; struct Edge { int x, y; double w; } a[N * (N - 1) / 2]; int x[N], y[N]; int fa[N]; int f[N][15], dep[N]; double g[N][15]; vector\u0026lt;pair\u0026lt;double, int\u0026gt;\u0026gt; ed[N]; int getfa(int x) { return x == fa[x] ? x : fa[x] = getfa(fa[x]); } void dfs(int x) { for (int i = 1; i \u0026lt; 15; ++i) { f[x][i] = f[f[x][i - 1]][i - 1]; g[x][i] = max(g[x][i - 1], g[f[x][i - 1]][i - 1]); } for (auto [w, y] : ed[x]) { if (y == f[x][0]) continue; g[y][0] = w; f[y][0] = x; dep[y] = dep[x] + 1; dfs(y); } } int main() { int n, m = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { fa[i] = i; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x[i], \u0026amp;y[i]); for (int j = 1; j \u0026lt; i; ++j) { a[++m] = {j, i, sqrt(pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2))}; } } sort(a + 1, a + m + 1, [](Edge a, Edge b) { return a.w \u0026lt; b.w; }); for (int i = 1; i \u0026lt;= m; ++i) { int x = getfa(a[i].x), y = getfa(a[i].y); if (x == y) continue; fa[y] = x; ed[a[i].x].push_back({a[i].w, a[i].y}); ed[a[i].y].push_back({a[i].w, a[i].x}); } dep[1] = 1; dfs(1); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while (q--) { int x, y; double res = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); if (dep[x] \u0026lt; dep[y]) swap(x, y); for (int i = 14; i \u0026gt;= 0; --i) { if (dep[f[x][i]] \u0026gt;= dep[y]) { res = max(res, g[x][i]); x = f[x][i]; } } if (x != y) { for (int i = 14; i \u0026gt;= 0; --i) { if (f[x][i] != f[y][i]) { res = max(res, max(g[x][i], g[y][i])); x = f[x][i], y = f[y][i]; } } res = max(res, max(g[x][0], g[y][0])); } printf(\u0026#34;%f\\n\u0026#34;, res); } return 0; } ","date":"2025-04-08T05:25:12Z","permalink":"https://invalidnamee.github.io/p/2025st16/","title":"2025æ˜¥è®­ç¬¬åå…­åœº"},{"content":"A. Lucky 7 ä¸€é“ç­¾åˆ°é¢˜ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; bool cont(int n) { for (char c : to_string(n)) { if (c == \u0026#39;7\u0026#39;) return true; } return false; } int main() { int n; cin \u0026gt;\u0026gt; n; bool c1 = cont(n), c2 = n % 7 == 0; if (!c1 \u0026amp;\u0026amp; !c2) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else if (!c1 \u0026amp;\u0026amp; c2) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; else if (c1 \u0026amp;\u0026amp; !c2) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 3 \u0026lt;\u0026lt; endl; return 0; } B. We Want You Happy! ä¸¤é“ç­¾åˆ°é¢˜ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; struct Customer { int id, s, d, t; } a[1010]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i].id \u0026gt;\u0026gt; a[i].s \u0026gt;\u0026gt; a[i].d \u0026gt;\u0026gt; a[i].t; } sort(a + 1, a + n + 1, [](Customer a, Customer b) { return a.s \u0026lt; b.s; }); int curt = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (curt \u0026gt; a[i].s + a[i].t) continue; if (curt \u0026lt; a[i].s) curt = a[i].s; curt += a[i].d; cout \u0026lt;\u0026lt; a[i].id \u0026lt;\u0026lt; endl; } return 0; } C. Snailography ç”Ÿæˆä¸€ä¸ªä¸‹æ ‡çŸ©é˜µç„¶åå¯¹ç€çŸ©é˜µè¾“å‡ºã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; int t[30][30]; int main() { int n; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; int x = 0, y = 1; int cur = n * n; while (cur \u0026gt; 0) { while (x + 1 \u0026lt;= n \u0026amp;\u0026amp; t[x + 1][y] == 0) t[++x][y] = cur--; while (y + 1 \u0026lt;= n \u0026amp;\u0026amp; t[x][y + 1] == 0) t[x][++y] = cur--; while (x - 1 \u0026gt; 0 \u0026amp;\u0026amp; t[x - 1][y] == 0) t[--x][y] = cur--; while (y - 1 \u0026gt; 0 \u0026amp;\u0026amp; t[x][y - 1] == 0) t[x][--y] = cur--; } for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { if (t[i][j] \u0026lt;= s.length()) cout \u0026lt;\u0026lt; s[t[i][j] - 1]; } } cout \u0026lt;\u0026lt; endl; return 0; } D. Good Goalie è‚¯å®šä¸è¡Œçš„æƒ…å†µï¼ŒåŸç‚¹åˆ°ç›´çº¿çš„è·ç¦»å¤§äº rï¼›\nè‚¯å®šæ˜¯ 0 çš„æƒ…å†µ \\(|x|\\) â‰¤ rï¼›\nå…¶ä½™æƒ…å†µï¼Œå…ˆæŠŠ x, y å–ä¸€ä¸‹ç»å¯¹å€¼ï¼Œå¯¹ç§°å˜æ¢ä¸ä¼šå½±å“ç­”æ¡ˆ\nç­”æ¡ˆæ˜¯è“è‰²çš„è§’ \\(\\arctan \\frac{x}{y} - \\arccos \\frac{d}{r}\\)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { double y, x, r; while (cin \u0026gt;\u0026gt; y \u0026gt;\u0026gt; x \u0026gt;\u0026gt; r) { double d = fabs(x * y) / sqrt(x * x + y * y); if (d \u0026lt;= r) { if (fabs(r) \u0026gt;= fabs(x)) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else { x = fabs(x), y = fabs(y); double theta = atan(x / y) - acos(d / r); cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(6) \u0026lt;\u0026lt; theta * 180 / acos(-1) \u0026lt;\u0026lt; endl; } } else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } return 0; } E. Most Valuable Pez åˆ†ç»„èƒŒåŒ…ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; int f[12010], s[13]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= 12; ++j) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[j]); s[j] += s[j - 1]; } for (int j = m; j; --j) { for (int k = 1; k \u0026lt;= 12 \u0026amp;\u0026amp; k \u0026lt;= j; ++k) { f[j] = max(f[j], f[j - k] + s[k]); } } } printf(\u0026#34;%d\\n\u0026#34;, f[m]); return 0; } G. Not So Close ç»å…¸çš„çŠ¶å‹dpï¼Œç”¨ä¸€ä¸ªäºŒè¿›åˆ¶æ•° mask è¡¨ç¤ºä¸€è¡Œçš„çŠ¶æ€ã€‚åªè€ƒè™‘å½“å‰è¡Œåˆæ³•çŠ¶æ€éœ€è¦æ»¡è¶³ mask Â» 1 \u0026amp; mask == 0ï¼Œå› ä¸ºä¸èƒ½ç›¸é‚»ï¼›ç›¸é‚»ä¸¤è¡Œçš„çŠ¶æ€ iï¼Œj éœ€è¦æ»¡è¶³ i Â« 1 \u0026amp; j == 0 and i \u0026amp; j == 0 and i Â» 1 \u0026amp; j == 0ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; using namespace std; const int MOD = 1000000007; long long f[1010][1 \u0026lt;\u0026lt; 10]; int main() { int r, n; cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; n; f[0][0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt; (1 \u0026lt;\u0026lt; r); ++j) { if (j \u0026gt;\u0026gt; 1 \u0026amp; j) continue; for (int k = 0; k \u0026lt; (1 \u0026lt;\u0026lt; r); ++k) { if ((k \u0026gt;\u0026gt; 1 \u0026amp; k) || (k \u0026amp; j) || (k \u0026gt;\u0026gt; 1 \u0026amp; j) || (k \u0026lt;\u0026lt; 1 \u0026amp; j)) continue; f[i][j] = (f[i][j] + f[i - 1][k]) % MOD; } } } long long res = 0; for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; r); ++mask) { res = (res + f[n][mask]) % MOD; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } H. The Duel of Smokinâ€™ Joe ç»Ÿè®¡é€†åºå¯¹æ•°é‡ï¼Œå¦‚æœæ˜¯å¥‡æ•°å°±æ˜¯ Smokin Joe!ï¼Œå¦åˆ™å°±æ˜¯ Oh No!.\nåŸç†æ˜¯ä¸€æ¬¡äº¤æ¢ä¸€å®šä¼šæ”¹å˜é€†åºå¯¹æ•°é‡çš„å¥‡å¶æ€§ï¼Œå¦‚æœåŸæ¥æ˜¯å¥‡æ•°ï¼Œé‚£ä¸€å®šéœ€è¦å¥‡æ•°æ¬¡ï¼Œå…ˆæ‰‹å¿…èƒœï¼›åä¹‹åæ‰‹å¿…èƒœã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int tr[N], a[N], n; void add(int u) { for (; u \u0026lt;= n; u += u \u0026amp; -u) { tr[u]++; } } int query(int u) { int res = 0; for (; u; u -= u \u0026amp; -u) { res += tr[u]; } return res; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } long long cnt = 0; for (int i = n; i; --i) { cnt += query(a[i]); add(a[i]); } if (cnt \u0026amp; 1) printf(\u0026#34;Smokin Joe!\\n\u0026#34;); else printf(\u0026#34;Oh No!\\n\u0026#34;); return 0; } å½’å¹¶æ’åºæ˜¯ä»€ä¹ˆï¼Œæ„Ÿè§‰ä¸å¦‚æ ‘çŠ¶æ•°ç»„ï¼ˆï¼‰\nJ. Grow Measure Cut Repeat å› ä¸ºæ¯æ¬¡ cut éƒ½æ˜¯å•è°ƒä¸å¢çš„ï¼Œæ‰€ä»¥ä¸ä¼šå‘ç”Ÿç¬¬ä¸€æ¬¡ cut è¿‡çš„æ ‘ç¬¬äºŒæ¬¡ä¸ cut çš„æƒ…å†µï¼Œè¿™å°±å¥½åŠäº†ã€‚ç»´æŠ¤ä¸¤ä¸ªçº¿æ®µæ ‘ï¼Œä¸€ä¸ªç»´æŠ¤å¿½ç•¥æ‰€æœ‰è£å‰ªçš„å‰æä¸‹çš„é«˜åº¦ï¼Œä¸€ä¸ªç»´æŠ¤åªè€ƒè™‘æœ€åä¸€æ¬¡è£å‰ªçš„æƒ…å†µä¸‹çš„é«˜åº¦ã€‚\nè¯´èµ·æ¥ç®€å•ï¼Œä½†æ˜¯å®é™…ä¸Šéå¸¸ä¸å¥½å†™ï¼Œæ¯•ç«Ÿç”¨çº¿æ®µæ ‘ç»´æŠ¤ç­‰å·®æ•°åˆ—æœ¬æ¥å°±æ¯”è¾ƒå¤æ‚ã€‚å…·ä½“çš„ï¼Œç¬¬ä¸€é¢—æ ‘éœ€è¦ä¸¤ä¸ªæ‡’æ ‡è®°ä¸€ä¸ªæ˜¯é¦–é¡¹ï¼Œä¸€ä¸ªæ˜¯å…¬å·®ï¼›ç¬¬äºŒæ£µæ ‘éœ€è¦ä¸‰ä¸ªæ‡’æ ‡è®°ï¼Œä¸€ä¸ªé¦–é¡¹ï¼Œä¸€ä¸ªå…¬å·®ï¼Œè¿˜æœ‰ä¸€ä¸ªè¦†ç›–æ ‡è®°ï¼ˆå› ä¸ºè£å‰ªä¹‹åè¦æŠŠæ‰€æœ‰çš„æ•°è¦†ç›–æˆæ–°çš„Hï¼‰ï¼ŒåŒæ—¶éœ€è¦æ³¨æ„è¾¹ç•Œï¼Œæˆ‘å°±å› ä¸ºè¾¹ç•Œå¿«è°ƒæ­»äº†ğŸ˜­ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 500000; int seq[N]; struct SemgentTree { long long a[N], tag[N]; bool cover[N]; void pushdown(int u, int l, int r) { if (cover[u]) { int mid = (l + r) \u0026gt;\u0026gt; 1; a[u \u0026lt;\u0026lt; 1] = a[u], a[u \u0026lt;\u0026lt; 1 | 1] = a[u] + tag[u] * (mid - l + 1); tag[u \u0026lt;\u0026lt; 1] = tag[u], tag[u \u0026lt;\u0026lt; 1 | 1] = tag[u]; tag[u] = 0; a[u] = 0; cover[u \u0026lt;\u0026lt; 1] = cover[u \u0026lt;\u0026lt; 1 | 1] = true; cover[u] = 0; } if (a[u] || tag[u]) { int mid = (l + r) \u0026gt;\u0026gt; 1; a[u \u0026lt;\u0026lt; 1] += a[u], a[u \u0026lt;\u0026lt; 1 | 1] += a[u] + tag[u] * (mid - l + 1); tag[u \u0026lt;\u0026lt; 1] += tag[u], tag[u \u0026lt;\u0026lt; 1 | 1] += tag[u]; tag[u] = 0; a[u] = 0; } } void reset(int u, int l, int r, long long val) { cover[u] = true; a[u] = val, tag[u] = 0; } void modify(int u, int l, int r, int ql, int qr, int a1, int d) { if (ql \u0026gt; qr) return; // !!!!! if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { a[u] += a1 + (l - ql) * d; // é¦–é¡¹ tag[u] += d; // å…¬å·® } else { pushdown(u, l, r); int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) modify(u \u0026lt;\u0026lt; 1, l, mid, ql, qr, a1, d); if (qr \u0026gt; mid) modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr, a1, d); } } long long query(int u, int l, int r, int p) { if (l == r) return a[u]; else { pushdown(u, l, r); int mid = (l + r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) return query(u \u0026lt;\u0026lt; 1, l, mid, p); else return query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, p); } } } smt, limt; void print(int t) { for (int i = 1; i \u0026lt;= t; ++i) { printf(\u0026#34;%lld \u0026#34;, min(limt.query(1, 1, 100000, i), smt.query(1, 1, 100000, i))); } printf(\u0026#34;\\n\u0026#34;); } int main() { int q, n = 100000; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while (q--) { char s[2]; scanf(\u0026#34;%s\u0026#34;, s); if (s[0] == \u0026#39;A\u0026#39;) { int l, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;k); smt.modify(1, 1, n, max(1, l - k + 1), l, max(1, k - l + 1), 1); smt.modify(1, 1, n, l + 1, min(n, l + k - 1), k - 1, -1); limt.modify(1, 1, n, max(1, l - k + 1), l, max(1, k - l + 1), 1); limt.modify(1, 1, n, l + 1, min(n, l + k - 1), k - 1, -1); } else if (s[0] == \u0026#39;B\u0026#39;) { int p; scanf(\u0026#34;%d\u0026#34;, \u0026amp;p); printf(\u0026#34;%lld\\n\u0026#34;, min(smt.query(1, 1, n, p), limt.query(1, 1, n, p))); } else { int H; scanf(\u0026#34;%d\u0026#34;, \u0026amp;H); limt.reset(1, 1, n, H); } } return 0; } K. Bad Bunny ç‚¹åŒè”é€šåˆ†é‡ç¼©ç‚¹ï¼Œç„¶åæ ‘ä¸Šå€å¢æ±‚è·¯å¾„ä¸Šå‰²ç‚¹çš„ä¸ªæ•°ï¼Œå¦‚æœç«¯ç‚¹ä¸æ˜¯å‰²ç‚¹ï¼Œå°±é¢å¤–åŠ ä¸Šç«¯ç‚¹ã€‚\nè¯´ç€å¾ˆç®€å•ï¼Œè°ƒçš„æ—¶å€™ä¹Ÿæ˜¯å¾ˆæŠ˜ç£¨ï¼Œå› ä¸ºæˆ‘æ˜¯ç°å­¦çš„ç‚¹åŒè”é€šåˆ†é‡ç¼©ç‚¹ï¼Œä¹‹å‰åªå­¦è¿‡å¼ºè”é€šå’Œè¾¹åŒè”é€šã€‚ç‚¹åŒçš„ç¼©ç‚¹æ›´å¤æ‚ï¼ŒæŠŠåŒè”é€šåˆ†é‡ç¼©ç‚¹ï¼ŒåŒæ—¶è¿˜éœ€è¦æŠŠå‰²ç‚¹å¤åˆ¶ä¸€ä»½å•ç‹¬æ‹å‡ºæ¥è¿æ¥ï¼Œç¬¬ä¸€æ¬¡å†™çš„æ—¶å€™å®¹æ˜“æŒ‚ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; const int N = 200010; int head[N], head2[N], ver[N * 4], ne[N * 4], tot = 1; int dfn[N], low[N], id[N], t, bcc_cnt, rt; vector\u0026lt;int\u0026gt; bcc[N]; int cut[N], cut_id[N]; int f[N][20], g[N][20], dep[N]; stack\u0026lt;int\u0026gt; st; void add(int head[], int x, int y) { ver[++tot] = y; ne[tot] = head[x]; head[x] = tot; } void tarjan(int x, int from) { dfn[x] = low[x] = ++t; st.push(x); int cnt = 0; for (int i = head[x]; i; i = ne[i]) { if (i == (from ^ 1)) continue; int y = ver[i]; if (!dfn[y]) { cnt++; tarjan(y, i); low[x] = min(low[x], low[y]); if (dfn[x] \u0026lt;= low[y]) { bcc_cnt++; int tp; if (x != rt || cnt \u0026gt;= 2) cut[x] = true; do { tp = st.top(); st.pop(); id[tp] = bcc_cnt; bcc[bcc_cnt].push_back(tp); } while (tp != y); bcc[bcc_cnt].push_back(x); id[x] = bcc_cnt; } } else { low[x] = min(low[x], dfn[y]); } } } void dfs(int x) { g[x][0] = cut_id[x]; for (int i = 1; i \u0026lt; 20; ++i) { f[x][i] = f[f[x][i - 1]][i - 1]; g[x][i] = g[x][i - 1] + g[f[x][i - 1]][i - 1]; } for (int i = head2[x]; i; i = ne[i]) { int y = ver[i]; if (y == f[x][0]) continue; f[y][0] = x; dep[y] = dep[x] + 1; dfs(y); } } int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;input\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif // !ONLINE_JUDGE int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); add(head, x, y); add(head, y, x); } rt = 1; tarjan(1, 0); for (int i = 1; i \u0026lt;= n; ++i) { if (cut[i]) { id[i] = ++bcc_cnt; cut_id[bcc_cnt] = true; } } for (int i = 1; i \u0026lt;= bcc_cnt; ++i) { for (int y : bcc[i]) { if (cut[y]) { add(head2, id[y], i); add(head2, i, id[y]); } } } dep[1] = 1; dfs(1); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while (q--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); int res = !cut[x] + !cut[y]; x = id[x], y = id[y]; if (dep[x] \u0026lt; dep[y]) swap(x, y); for (int i = 19; i \u0026gt;= 0; --i) { if (dep[f[x][i]] \u0026gt;= dep[y]) { res += g[x][i]; x = f[x][i]; } } if (x != y) { for (int i = 19; i \u0026gt;= 0; --i) { if (f[x][i] != f[y][i]) { res += g[x][i] + g[y][i]; x = f[x][i], y = f[y][i]; } } res += g[x][0] + g[y][0]; x = f[x][0]; } if (cut_id[x]) res++; printf(\u0026#34;%d\\n\u0026#34;, res); } return 0; } ","date":"2025-04-06T14:53:26Z","permalink":"https://invalidnamee.github.io/p/2025st15/","title":"2025æ˜¥è®­ç¬¬åäº”åœº"},{"content":"æ—¶éš”å¥½ä¹…ï¼Œæˆ˜æ–—çˆ½ç»ˆäºå¤åˆ»äº†ğŸ˜‹ï¼Œæ‹¿ä¸ªæ¦œä¸€çœŸä¸å®¹æ˜“ã€‚\nA. Christmas Tree Adapter ç»ˆäºæœ‰ç­¾åˆ°é¢˜äº†ã€‚\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a, w, v; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; w \u0026gt;\u0026gt; v; if (a * v \u0026lt;= w) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } B. Cool Phone Numbers è€Œä¸”ç­¾åˆ°é¢˜è¿˜ä¸æ­¢ä¸€é“ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; set\u0026lt;char\u0026gt; st; int main() { string s; cin \u0026gt;\u0026gt; s; for (char c : s) { if (isdigit(c)) st.insert(c); } cout \u0026lt;\u0026lt; st.size() \u0026lt;\u0026lt; endl; return 0; } C. Ready for Contest ç«Ÿç„¶æœ‰å››é“ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; using namespace std; bool a[100010][4]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); a[x][y] = true; } for (int i = 1; i \u0026lt;= n; ++i) { if (a[i][1] \u0026amp; a[i][2]) printf(\u0026#34;%d\\n\u0026#34;, i); } return 0; } D. Fixing the Tournament å°½å¯èƒ½æŠŠæ’åä½çš„ä¸¤ä¸¤ç»„é˜Ÿï¼Œæœ€åå¦‚æœä¼šè¾“ï¼Œè¿˜éœ€è¦åŠ ä¸Šè¾“çš„é‚£ä¸€åœºã€‚\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { int n, r; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; min((int)floor(log2((1 \u0026lt;\u0026lt; n) - r + 1)) + 1, n) \u0026lt;\u0026lt; endl; return 0; } E. Identical Letters æ¯”è¾ƒç»å…¸çš„æ»‘åŠ¨çª—å£é—®é¢˜ï¼Œæšä¸¾ 26 ä¸ªå­—æ¯ï¼Œéå†æ•°ç»„åŒæŒ‡é’ˆç»´æŠ¤åˆ°æ¯ä¸€ä¸ªä½ç½®æ—¶å½“å‰å­—æ¯èƒ½æ„æˆçš„æœ€é•¿è¿ç»­åºåˆ—çš„é•¿åº¦ï¼Œå…¨éƒ¨å– max å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); string s; int n, m; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; m; n = s.length(); s = \u0026#39; \u0026#39; + s; int res = 0; for (char c = \u0026#39;a\u0026#39;; c \u0026lt;= \u0026#39;z\u0026#39;; ++c) { for (int i = 1, j = 1, del = 0; i \u0026lt;= n; ++i) { if (s[i] != c) del++; while (j \u0026lt;= i \u0026amp;\u0026amp; del \u0026gt; m) if (s[j++] != c) del--; res = max(res, i - j + 1 - del); } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } F. Espresso Made Your Way æˆ‘æ²¡æœ‰è°ƒçº¢æ¸©ï¼Œç»å¯¹æ²¡æœ‰ğŸ¤®ğŸ¤®ğŸ¤®ï¼Œé‚£ä¸ª +13 çš„ç»å¯¹ä¸æ˜¯æˆ‘ğŸ˜­\nè®¾åŸæ¥ä¸€æ¯çš„æƒé‡ä¸º 1ï¼Œé‚£ä¹ˆç¬¬ä¸€æ¯åŠ è¿›æ¥çš„æƒé‡ä¹Ÿæ˜¯ 1ï¼Œå†åŠ ç¬¬äºŒæ¯çš„æ—¶å€™ï¼Œå› ä¸ºå‰é¢å·²ç»æµªè´¹äº†ä¸€æ¯äº†ï¼Œå·²æœ‰çš„è¿™ä¸¤æ¯çš„æ··åˆç‰©å˜æˆä¸€æ¯äº†ï¼Œæ‰€ä»¥å¯ä»¥è®¤ä¸ºç¬¬äºŒæ¯å’Œå‰é¢ä¸¤æ¯çš„é‡åˆèµ·æ¥æ˜¯ç­‰ä»·çš„ï¼Œæƒé‡ä¸º 2ï¼ŒåŒç†åé¢çš„æƒé‡æ˜¯ 4, 8, 16, 32â€¦â€¦\næ‰€ä»¥æœ€åè°ƒå‡ºæ¥çš„ä¸œè¥¿â˜•ï¸ï¼ˆğŸ¥›ï¼‰å çš„æ¯”ä¾‹è‚¯å®šæ˜¯\n\\[\\frac{1}{2^n}(k_0 + \\sum_{i = 0}^{n - 1}k_{i + 1} 2^i)\\]\nå…¶ä¸­ n ä¸ºæµªè´¹çš„æ¯æ•°ï¼Œk ä¸º 0 æˆ– 1. å…¶å®æ±‚å’Œç¬¦å·é‡Œçš„å°±æ˜¯ä¸€ä¸ªæ•´æ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºï¼Œæ‰€ä»¥æ•´ä¸ªå¼å­å…¶å®ç­‰ä»·äº \\(\\frac{k}{2^n}, k \\in [0, 2^n] \\cap \\mathbb{Z}\\)ã€‚ç„¶åå°±å¥½è¯´äº†ï¼Œæšä¸¾ k éªŒè¯èƒ½ä¸èƒ½æˆç«‹å°±è¡Œã€‚éœ€è¦æ³¨æ„æšä¸¾çš„èŒƒå›´ï¼Œåº”è¯¥æšä¸¾åˆ° \\(\\log_2{10^{12}}\\)ï¼ï¼ï¼\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; long long c1, m1, c2, m2; int main() { cin \u0026gt;\u0026gt; c1 \u0026gt;\u0026gt; m1 \u0026gt;\u0026gt; c2 \u0026gt;\u0026gt; m2; if (c1 * m2 \u0026gt; c2 * m1) swap(c1, c2), swap(m1, m2); if (c1 == 0 || c2 == 0 || m1 == 0 || m2 == 0) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else { m1 += c1, m2 += c2; int i = 0; while (true) { __int128_t l = 0, r = (1ll \u0026lt;\u0026lt; i); bool f = false; while (l \u0026lt;= r) { __int128_t mid = (l + r) \u0026gt;\u0026gt; 1; if (mid * m2 \u0026gt; (__int128_t)c2 * (1ll \u0026lt;\u0026lt; i)) r = mid - 1; else if (mid * m1 \u0026lt; (__int128_t)c1 * (1ll \u0026lt;\u0026lt; i)) l = mid + 1; else { f = true; break; } } if (f) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; return 0; } i++; } } return 0; } è¿™æ˜¯æ­£ç€è¯•çš„åŠæ³•ï¼Œè¿˜å¯ä»¥åç€å°è¯•ï¼Œæ›´ easy ä¸€äº›ï¼Œä¸éœ€è¦äºŒåˆ†å°è¯•ï¼ŒæŠŠ C å’Œ M ä¸æ–­é™¤ä»¥ 2ï¼Œç›´åˆ°æœ€åä¸€ä¸ªä¸ç›¸ç­‰çš„ä½ç½®ã€‚\nG. Speed Ups ç›¸å¯¹æ¯”è¾ƒå¥½åšï¼Œçº¿æ€§ dp ç»´æŠ¤åˆ°æ¯ä¸€ä¸ªåŠ é€Ÿçš„ä½ç½®çš„æœ€çŸ­æ—¶é—´ï¼ˆè¿™é‡ŒæŒ‡çš„æ˜¯å¯ä»¥è¸©åˆ°è¿™ä¸ªåŠ é€Ÿçš„æƒ…å†µï¼Œä¸åŒ…æ‹¬ä¸Šä¸€ä¸ªåŠ é€Ÿæ²¡ç”¨å®Œè·¯è¿‡è¿™é‡Œçš„æƒ…å†µï¼‰ï¼Œç„¶åæšä¸¾èµ·ç‚¹å’Œæ‰€æœ‰åŠ é€Ÿçš„ä½ç½®ï¼Œç®—èµ°åˆ°ç»ˆç‚¹çš„æ—¶é•¿å– min.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iomanip\u0026gt; #define int long long using namespace std; struct Node { int x, m, d; } a[1010]; int f[1010]; signed main() { int n, l; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;l); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;a[i].x, \u0026amp;a[i].m, \u0026amp;a[i].d); } sort(a + 1, a + n + 1, [](Node a, Node b) { return a.x \u0026lt; b.x; }); for (int i = 1; i \u0026lt;= n; ++i) { f[i] = 0x3f3f3f3f; for (int j = 0; j \u0026lt; i; ++j) { if ((long long)a[j].m * a[j].d \u0026lt;= (a[i].x - a[j].x)) { f[i] = min(f[i], f[j] + a[j].d + (a[i].x - a[j].x - a[j].m * a[j].d)); } } } double res = 1e18; for (int i = 0; i \u0026lt;= n; ++i) { if ((long long)a[i].x + (long long)a[i].m * a[i].d \u0026lt;= l) res = min(res, (double)(f[i] + a[i].d + (l - a[i].m * a[i].d - a[i].x))); else res = min(res, (double)(f[i]) + (double)(l - a[i].x) / a[i].m); } printf(\u0026#34;%lf\\n\u0026#34;, res); return 0; } H. Magnetic Attractions ä¼—æ‰€å‘¨çŸ¥ï¼Œæ ¹æ®é«˜ä¸­ç‰©ç†çŸ¥è¯†ï¼Œè¿™ä¸ªåŒºåŸŸæ˜¯ä¸€ä¸ªåœ†å½¢åŒºåŸŸï¼Œä»¥ s ä¸ºåŸç‚¹ï¼Œ \\(\\vec{sS}\\) æ–¹å‘ä¸º x è½´ï¼Œå‚ç›´çš„æ–¹å‘ä¸º y è½´é‡æ–°å»ºä¸€ä¸ªåæ ‡ç³»ï¼Œè®° S çš„æ–°çš„åæ ‡ä¸º (d, 0).\n\\[\\frac{s}{x^2 + y^2} = \\frac{S}{(x - d)^2 + y^2}\\]\næ•´ç†å¯å¾—\n\\[(x - \\frac{s}{s - S})^2 + y^2 = \\frac{sd - sd^2}{s - S}\\]\n\\[r^2 = \\frac{sd - sd^2}{s - S}\\]\nç›´æ¥å¥—åœ†çš„é¢ç§¯å…¬å¼å°±èƒ½ç®—å‡ºæ¥\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { double s1, x1, y1, s2, x2, y2; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; s2 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; double d = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2)); double r2 = pow(s1 * d / (s2 - s1), 2) - s1 * d * d / (s1 - s2), pi = acos(-1); printf(\u0026#34;%lf\\n\u0026#34;, pi * r2); return 0; } I. Hotel Rooms å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ï¼Œçº¿æ®µæ ‘æˆ–è€…æ ‘çŠ¶æ•°ç»„éƒ½å¯ä»¥ï¼Œä¸ªäººæ„Ÿè§‰æ ‘çŠ¶æ•°ç»„å¥½å†™ä¸€ç‚¹ï¼Œäºæ˜¯å°±å†™çš„æ ‘çŠ¶æ•°ç»„ï¼Œä¹Ÿæ˜¯ä¸€éç§’äº†ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; using namespace std; int n, m; int tr[500010]; bool f[500010]; void add(int u, int val) { for (; u \u0026lt;= n; u += u \u0026amp; -u) { tr[u] += val; } } int query(int u) { int res = 0; for (; u; u -= u \u0026amp; -u) { res += tr[u]; } return res; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { add(i, 1); } for (int i = 1; i \u0026lt;= m; ++i) { char s[2]; scanf(\u0026#34;%s\u0026#34;, s); if (s[0] == \u0026#39;A\u0026#39;) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); printf(\u0026#34;%d\\n\u0026#34;, query(r) - query(l - 1)); } else { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); if (!f[x]) f[x] = true, add(x, -1); } } return 0; } ","date":"2025-04-04T11:21:25Z","permalink":"https://invalidnamee.github.io/p/2025st14/","title":"2025æ˜¥è®­ç¬¬åå››åœº"},{"content":"A. å›¢ç»“ å…¶å®éå¸¸ç®€å•ï¼Œä½†æ˜¯æˆ‘ä¸­æ‹›äº†ğŸ˜­\nä»–è¿™ä¸ªæ“ä½œç­‰ä»·äºå…ˆæŠŠ \\(\\gcd_{i = 1}^{n} A_i\\)ç®—å‡ºæ¥ï¼Œç„¶ååœ¨ 1 ï½ n é‡Œé¢é€‰ä¸€äº›æ•°å’Œå‰é¢çš„ç»“æœå– gcdï¼Œç›´åˆ°ç»“æœä¸º 1.\næœ€åæœ€åçš„æƒ…å†µï¼Œå°±æ˜¯ gcd(n - 1, n) = 1ï¼Œç„¶åå’Œå‰é¢çš„å– gcd ä¸€å®šæ˜¯ 1ï¼Œä»£ä»·æ˜¯ 3ï¼›æ‰€ä»¥åªéœ€è¦æšä¸¾ä»£ä»·æ˜¯å¦å­˜åœ¨ 1 å’Œä»£ä»·æ˜¯ 2 çš„ä¸¤ç§æƒ…å†µå³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 100010; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } int a[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } int g = a[1]; if (g == 1) printf(\u0026#34;0\\n\u0026#34;); else if (gcd(g, n) == 1) printf(\u0026#34;1\\n\u0026#34;); else if (gcd(g, n - 1) == 1) printf(\u0026#34;2\\n\u0026#34;); else printf(\u0026#34;3\\n\u0026#34;); return 0; }\tB. æŸ“è‰² ç®€å•çš„ dfs é¢˜ï¼Œä»æ ¹å¼€å§‹å¾€ä¸‹æœï¼Œé‡åˆ°ä¸ç¬¦åˆçš„å°±æŸ“è‰²ï¼Œç»Ÿè®¡æ¬¡æ•°å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 100010; vector\u0026lt;int\u0026gt; ed[N]; int col[N], t[N]; int res; void dfs(int x) { if (col[x] != t[x]) { col[x] = t[x]; res++; } for (int y : ed[x]) { col[y] = col[x]; dfs(y); } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 2; i \u0026lt;= n; ++i) { int p; scanf(\u0026#34;%d\u0026#34;, \u0026amp;p); ed[p].push_back(i); } for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;t[i]); } dfs(1); printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } C. ä¸‰å…ƒç»„ ï¼ˆè¿˜åœ¨ TLE ä½†æ˜¯æœ‰æˆï¼‰\nE. æ€ç»´å¯¼å›¾ ä¸€ç¬”ç”»é—®é¢˜ï¼Œç¦»æ•£ 2-2 åˆšè®²äº†ã€‚å¯¹äºæ¯ä¸ªè¿é€šå—ï¼Œè®°åº¦æ•°ä¸ºå¥‡æ•°çš„ç‚¹æœ‰ k ä¸ªï¼Œåˆ™éœ€è¦ç”» \\(\\lceil \\frac{k}{2} \\rceil\\) æ¬¡ã€‚æŠŠè¿é€šå—çš„ç­”æ¡ˆç´¯åŠ å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 10010; int deg[N]; vector\u0026lt;int\u0026gt; ed[N]; int cnt; bool v[N]; void dfs(int x) { if (v[x]) return; v[x] = true; if (deg[x] \u0026amp; 1) cnt++; for (int y : ed[x]) { dfs(y); } } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); ed[x].push_back(y); ed[y].push_back(x); deg[x]++, deg[y]++; } int res = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (!v[i]) { cnt = 0; dfs(i); if (!cnt) res++; else res += (cnt + 1) \u0026gt;\u0026gt; 1; }\t} printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } F. ESP_8266 è¿™å°±æ˜¯ä¸ªå•çº¯çš„æ¨¡æ‹Ÿé¢˜ï¼Œæ²¡ä»€ä¹ˆéœ€è¦æ³¨æ„çš„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import re l = [] while True: try: s = input() l.append(s) except EOFError: break s = \u0026#39;\\n\u0026#39;.join(l) pos = 0 for i in re.findall(r\u0026#39;\\([+-]\\d{2}\\)\u0026#39;, s): if i[1] == \u0026#39;+\u0026#39;: pos += int(i[2:4]) else: pos -= int(i[2:4]) print(pos) ","date":"2025-04-04T11:19:59Z","permalink":"https://invalidnamee.github.io/p/2025st13/","title":"2025æ˜¥è®­ç¬¬åä¸‰åœº"},{"content":"A. æ‹¼å†™æ£€æŸ¥ æŒ‰è¦æ±‚æ¨¡æ‹Ÿå°±è¡Œï¼Œåªéœ€è¦æ³¨æ„ å¦‚æœè¦æ£€æŸ¥çš„å•è¯åœ¨è¯è¡¨ä¸­å‡ºç°ï¼Œåˆ™åŸæ ·è¾“å‡ºè¯¥å•è¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 s = input() n = int(input()) l = [input() for _ in range(n)] if s in l: print(s) else: for t in l: f = False if (len(s) == len(t)): if (sum(s[i] != t[i] for i in range(len(s))) == 1): f = True elif (len(s) == len(t) + 1): for i in range(len(s)): if (s[:i] + s[i + 1:] == t): f = True break elif (len(s) == len(t) - 1): for i in range(len(t)): if (s == t[:i] + t[i + 1:]): f = True break if f: print(t) break else: print(\u0026#39;NOANSWER\u0026#39;) B. ç¿»è½¬ æœ‰ç‚¹ç±»ä¼¼çº¿æ€§dpçš„æ€æƒ³ï¼Œæ ¸å¿ƒé—®é¢˜å°±æ˜¯ 0 å’Œ 1 çš„åˆ†ç•Œç‚¹åœ¨å“ªã€‚é¢„å¤„ç†æŠŠå³ä¾§å…¨å˜æˆ 1 çš„æ“ä½œæ•°ã€‚\nç‰¹åˆ«çš„å¯¹äº i = nï¼Œ æ—¶å¦‚æœæ˜¯ s\n\\[i\\] = 0ï¼Œç¿»è½¬ä¸€æ¬¡ï¼›å¦‚æœ s\n\\[i\\] = 1ï¼Œä¸ç”¨ç¿»è½¬ï¼›\nå…¶ä»–æƒ…å†µï¼Œå¦‚æœ s\n\\[i\\] = 1ï¼Œä¸ç”¨åŠ¨ï¼›å¦‚æœ s\n\\[i\\] = 0 å¹¶ä¸” s\n\\[i + 1\\] = 0ï¼Œä¸ç”¨æ¶ˆè€—ç¿»è½¬æ¬¡æ•°ï¼ˆå› ä¸ºæŠŠå¯¹äº \\[s\\[i + 1\\], n] çš„æœ€åä¸€æ¬¡ç¿»è½¬æ”¹æˆå¯¹äº \\[s\\[i\\], n] çš„ç¿»è½¬å°±è¡Œï¼‰ï¼Œå¦åˆ™ç¿»è½¬ä¸¤æ¬¡ï¼ˆå…ˆæŠŠåé¢å…¨å˜ 0ï¼Œç„¶åä¸€èµ·å˜æˆ 1ï¼‰ã€‚\nç„¶åä»å·¦åˆ°å³éå†ï¼Œæšä¸¾åˆ†ç•Œç‚¹ï¼Œéå†åˆ° i æ—¶æŠŠ i å˜æˆ 1ï¼Œç„¶åè€ƒè™‘å½“å‰ç¿»è½¬æ¬¡æ•°çš„å¥‡å¶æ€§\nå¦‚æœæ˜¯å¶æ•°ï¼Œåé¢çš„åºåˆ—ä¸å˜ï¼Œå¯ä»¥ç›´æ¥ç”¨å‰é¢ç»´æŠ¤çš„ç»“æœï¼›\nå¦‚æœæ˜¯å¥‡æ•°ï¼Œåé¢åºåˆ—ç¿»è½¬ï¼Œå¦‚æœ s\n\\[i + 1\\] æœ¬æ¥æ˜¯ 1ï¼Œé‚£åªèƒ½å†ç¿»è½¬ä¸€æ¬¡äº†ï¼›å¦‚æœ s\n\\[i + 1\\] æœ¬æ¥æ˜¯ 0ï¼Œè¯´æ˜ç»´æŠ¤çš„æ—¶å€™å·²ç»ç¿»è½¬äº†ä¸€æ¬¡ï¼Œç›´æ¥æŠŠæœ€åä¸€æ¬¡æ— æ•ˆç¿»è½¬æ’¤é”€æ‰å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; int a[100010], b[100010]; int main() { int n, t = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%1d\u0026#34;, \u0026amp;a[i]); } a[n + 1] = 1; for (int i = n; i; --i) { if (a[i] || a[i + 1] == a[i]) b[i] = b[i + 1]; else if (i == n) b[i] = 1; else b[i] = b[i + 1] + 2; } int res = b[1]; for (int i = 1; i \u0026lt;= n; ++i) { if ((a[i] ^ (t \u0026amp; 1)) \u0026amp;\u0026amp; a[i] != a[i - 1]) t++; res = min(res, t + ((t \u0026amp; 1) ? (a[i + 1] ? b[i + 1] + 1 : b[i + 1] - 1) : b[i + 1])); } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } C. é›†åˆ æ¯”è¾ƒæš´åŠ›çš„åšæ³•ï¼ˆå®¹æ˜“çˆ†ç©ºé—´ï¼‰ï¼Œå¯ä»¥ç”¨åˆ†æ²»çš„æ€æƒ³ï¼Œé¢„å¤„ç† k å°çš„ï¼Œæš´åŠ› k å¤§çš„ï¼Œå¹³å‡æ¯æ¬¡æŸ¥è¯¢åªéœ€è¦ 1000 æ¬¡å·¦å³è®¡ç®—ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; unordered_map\u0026lt;int, int\u0026gt; s; int n; struct FenwickTree { int val[100001]; bool mark[100001]; void add(int u) { if (mark[u]) return; mark[u] = true; for (; u \u0026lt;= n; u += u \u0026amp; -u) { val[u] += 1; } } int query(int u) { int res = 0; for (; u; u -= u \u0026amp; -u) { res += val[u]; } return res; } } tr[101]; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int q; cin \u0026gt;\u0026gt; q; n = q; while (q--) { char c; int x; cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; x; if (c == \u0026#39;+\u0026#39;) { if (s[x] == 0) { for (int i = 1; i \u0026lt;= 100; ++i) { if (x % i == 0) { if (x / i \u0026lt;= 100000) tr[i].add(x / i); } } } s[x]++; } else { if (x \u0026gt; 100) { int i; for (i = 1; s[i * x]; ++i); cout \u0026lt;\u0026lt; i * x \u0026lt;\u0026lt; endl; } else { int l = 1, r = 100000; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (tr[x].query(mid) \u0026lt; mid) r = mid; else l = mid + 1; } cout \u0026lt;\u0026lt; l * x \u0026lt;\u0026lt; endl; } } } return 0; } ä¸é‚£ä¹ˆæš´åŠ›çš„åšæ³•ï¼Œå› ä¸ºæ²¡æœ‰åˆ é™¤æ“ä½œï¼Œæ‰€ä»¥å¯¹äºæ¯ä¸€ä¸ª kï¼Œåä¸€æ¬¡å¾—åˆ°çš„ç­”æ¡ˆä¸€å®šæ˜¯åœ¨å‰ä¸€æ¬¡ç­”æ¡ˆçš„åé¢ï¼Œäºæ˜¯æŠŠè¾ƒå°çš„ k æ‰“ä¸Šæ ‡è®°ï¼Œæ¯æ¬¡æŸ¥è¯¢ä»æ ‡è®°å¼€å§‹å¾€åé¢æŸ¥å³å¯ï¼ˆä½†æ˜¯æˆ‘æ²¡æƒ³åˆ°ï¼Œè¿˜åœ¨æš´åŠ›æ ‘çŠ¶æ•°ç»„+äºŒåˆ†ï¼‰ã€‚\nD. è®¡æ•° çº¿æ€§dpï¼Œå¤§æ¦‚æ€è·¯å¾ˆå¥½æƒ³ï¼Œæ¯”è¾ƒéš¾åšåˆ°çš„æ˜¯ä¸é‡ä¸æ¼ï¼Œæˆ‘ğŸ§ ä¸è¡Œï¼Œäºæ˜¯å†™äº†ä¸ª \\(O(2^n \\times n^3)\\)çš„å¤§æš´åŠ›å¯¹æ‹æ‹å‡ºæ¥äº†ã€‚\næ¯ä¸ª \\(A_i\\) åªèƒ½æœ‰è¢«åˆ å’Œä¸è¢«åˆ ä¸¤ç§æƒ…å†µï¼Œä»¤ \\(f_{i, 0}\\) è¡¨ç¤ºåªè€ƒè™‘ \\[1, i\\] è¿™ä¸ªåŒºé—´çš„å†…çš„æ•°çš„æƒ…å†µä¸‹ç¬¬ i ä¸ªæ•°ä¸è¢«åˆ çš„æ–¹æ¡ˆæ•°ï¼Œ\\(f_{i, 1}\\) è¡¨ç¤ºè¢«åˆ çš„æ–¹æ¡ˆæ•°ã€‚\nå¦‚æœ \\(A_i\\) å‰æœ‰æ¯”ä»–å°çš„æ•°ï¼Œè®°ç¬¬ä¸€ä¸ªæ¯”ä»–å°çš„æ•°ä¸º \\(A_j\\)ã€‚\né¦–å…ˆè€ƒè™‘ \\(f_{i, 0}\\)ï¼Œ\\(A_i\\) å¯ä»¥åˆ çš„åŒºé—´æœ‰ \\[k, i - 1\\]ï¼Œå…¶ä¸­ j + 1 â‰¤ k â‰¤ i - 1ï¼Œåœ¨ä¸å…¨åˆ æ‰çš„æƒ…å†µä¸‹ï¼Œä»å·¦åˆ°å³åˆ å’Œä»å³åˆ°å·¦åˆ ä¸€å®šæ˜¯ä¸é‡å¤çš„ï¼Œæ‰€ä»¥æ–¹æ¡ˆæ•°æ˜¯ \\(\\sum_{k = j + 1}^{i - 1} f_{i, 0}\\)ï¼›å¦‚æœ \\[j + 1, i - 1\\] å…¨åˆ æ‰äº†ï¼Œæ–¹æ¡ˆæ•°å°±æ˜¯ j çš„æ–¹æ¡ˆæ•° \\(f_{j, 0} + f_{j, 1}\\)ï¼Œåˆå¹¶ä¸€ä¸‹æœ‰\n\\[f_{i, 0} = \\sum_{k = j}^{i - 1} f_{k, 0} + f_{j, 1}\\]\nè€ƒè™‘ \\(f_{i, 1}\\)ï¼Œ\\(A_i\\) å¯ä»¥è¢« \\(A_j\\) åˆ ä¹Ÿå¯ä»¥è¢«èƒ½åˆ æ‰ \\(A_j\\) çš„ç‚¹åˆ ï¼Œæ‰€ä»¥\n\\[f_{i, 1} = f_{j, 0} + f_{j, 1}\\]\nå¦‚æœæ²¡æœ‰æ¯”ä»–å°çš„æ•°ï¼Œ ä»–å¯ä»¥ \\[k, i - 1\\]ï¼Œ1 â‰¤ k â‰¤ i - 1ï¼Œæ–¹æ¡ˆæ•°å°±æ˜¯ä¸å…¨åˆ çš„æ–¹æ¡ˆæ•° + å…¨åˆ çš„æ–¹æ¡ˆæ•°ï¼ˆå°±æ˜¯ 1ï¼‰\n\\[f_{i, 0} = \\sum_{k = 1}^{i - 1}f_{k, 0} + 1\\]\nä»–ä¸å¯èƒ½è¢«å·¦è¾¹çš„åˆ æ‰ï¼Œæ‰€ä»¥ \\(f_{i, 1} = 0\\).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; const int MOD = 998244353; const int N = 300010; int st[N], tp; long long f[N][2], s[N]; int a[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); s[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); while (tp \u0026amp;\u0026amp; a[i] \u0026lt;= a[st[tp]]) tp--; if (!tp) { f[i][0] = s[i - 1]; } else { f[i][0] = (((s[i - 1] - s[st[tp] - 1] + f[st[tp]][1]) % MOD) + MOD) % MOD; f[i][1] = (f[st[tp]][0] + f[st[tp]][1]) % MOD; } s[i] = (s[i - 1] + f[i][0]) % MOD; st[++tp] = i; } printf(\u0026#34;%lld\\n\u0026#34;, (f[n][0] + f[n][1]) % MOD); return 0; } ğŸ“ å¤§æš´åŠ›ï¼Œæšä¸¾æ‰€æœ‰å­åºåˆ—ï¼ŒæŒ¨ä¸ªæ£€æŸ¥åˆæ³•æ€§ï¼ˆå¦‚æœä¸€ä¸ªç‚¹è¢«åˆ äº†ï¼Œé‚£ä¹ˆä¸€å®šæœ‰ä¸€ä¸ªæ¯”ä»–å°çš„ç‚¹æ²¡æœ‰è¢«åˆ ï¼Œå¹¶ä¸”è¿™ä¸¤ä¸ªç‚¹è·¯å¾„ä¸Šçš„æ‰€æœ‰ç‚¹éƒ½è¢«åˆ äº†ï¼‰ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; using namespace std; int a[20]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i]; } int t = 0; for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; n); ++mask) { bool big_f = true; for (int i = 1; i \u0026lt;= n; ++i) { if (((mask \u0026gt;\u0026gt; (i - 1)) ^ 1) \u0026amp; 1) { bool f = false; for (int j = 1; j \u0026lt;= n; ++j) { if ((mask \u0026gt;\u0026gt; (j - 1)) \u0026amp; 1) { if (a[j] \u0026lt; a[i]) { bool ck = true; int l = min(i, j), r = max(i, j); for (int ii = l + 1; ii \u0026lt; r; ++ii) { if (mask \u0026gt;\u0026gt; (ii - 1) \u0026amp; 1) { ck = false; break; } } if (ck) { f = true; break; } } } } if (!f) { big_f = false; break; } } } t += big_f; } cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-04-02T11:30:01Z","permalink":"https://invalidnamee.github.io/p/2025st12/","title":"2025æ˜¥è®­ç¬¬åäºŒåœº"},{"content":"åˆšå¼€å§‹ä¸€çœ‹å‘ç°å•¥éƒ½ä¸ä¼šï¼Œç»†çœ‹å‘ç°ä»¥ä¸ºç®€å•çš„å¾ˆå¤æ‚ï¼Œä»¥ä¸ºå¾ˆå¤æ‚çš„å¾ˆç®€å•ã€‚\nA. æ¸¸æˆ çº¦æ•°å°½å¯èƒ½å¤šï¼Œæ‰€ä»¥åº”è¯¥è®©çº¦æ•°å°½å¯èƒ½å°ï¼Œé‚£å°±è®©ä»–éƒ½æ˜¯ 2ï¼Œæ‰¾ä¸€ä¸ªæœ€å¤§çš„ iï¼Œä½¿å¾— l â‰¤ (1 Â« i) â‰¤ r å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; for (int i = 30; i \u0026gt;= 0; --i) { if (l \u0026lt;= (1 \u0026lt;\u0026lt; i) \u0026amp;\u0026amp; (1 \u0026lt;\u0026lt; i) \u0026lt;= r) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; return 0; } } return 0; } B. æˆ– åªéœ€è¦ä¾æ¬¡è€ƒè™‘æ¯ä¸ªäºŒè¿›åˆ¶ä½æ˜¯å¦å« 1ã€‚äºæ˜¯å¯ä»¥ä»ç¬¬ 0 ä½å¼€å§‹ä¸€ä½ä¸€ä½æ‰¾è¿™ä¸ªèŒƒå›´å†…æ˜¯å¦åŒ…å«ä¸€ä¸ª 1 å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); long long res = 0; for (int i = 0; i \u0026lt; 30; ++i) { if (l \u0026lt; r || (l \u0026amp; 1) || (r \u0026amp; 1)) res |= 1 \u0026lt;\u0026lt; i; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1; } printf(\u0026#34;%lld\\n\u0026#34;, res); } return 0; } C. æœ€é•¿å­åºåˆ— éå¸¸åç›´è§‰çš„ä¸€é“é¢˜ï¼Œçœ‹ä¸Šå»å¾ˆç®€å•ï¼Œå®é™…ä¸Šå¾ˆæ¶å¿ƒã€‚\né•¿åº¦å¾ˆå¥½ç®—ï¼Œç›´æ¥å¼€ä¸ªæ¡¶æ ‡è®°ä¸€ä¸‹å°±è¡Œï¼Œä¸»è¦é—®é¢˜æ˜¯å¦‚ä½•æ„é€ å‡ºå­—å…¸åºæœ€å°çš„åˆæ³•å­åºåˆ—ã€‚ä¸éš¾æƒ³å‡ºè¦è®©å°½å¯èƒ½é å‰çš„ä½ç½®é€‰åˆ°æœ€ä¼˜è§£ï¼Œæ‰€ä»¥å¯ä»¥åŸºäºè´ªå¿ƒçš„æ€æƒ³æ„é€ ã€‚\nç»´æŠ¤æ¯ä¸ªå…ƒç´ å‡ºç°çš„ä½ç½®åºåˆ—ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®å’Œæœ€åå‡ºç°çš„ä½ç½®ï¼›\nä»å°åˆ°å¤§éå†æœ€åå‡ºç°çš„ä½ç½®ï¼Œè®¾è¯¥ä½ç½®æ˜¯ a æœ€åå‡ºç°çš„ä½ç½®ï¼ŒæŠŠå‰é¢çš„æ‰€æœ‰æ²¡æœ‰é€‰è¿‡çš„å…ƒç´ åŠ å…¥å¤‡é€‰é›†åˆï¼›\næ ¹æ®å¥‡å¶æ€§è´ªå¿ƒåœ°ä»å¤‡é€‰é›†åˆé‡Œé€‰å‡ºå½“å‰æœ€ä¼˜çš„é‚£ä¸ªæ•°ï¼ŒåŒæ—¶ä¿è¯è¿™ä¸ªæ•°å¦‚æœåœ¨å¤‡é€‰é›†åˆé‡å¤å‡ºç°ï¼Œé€‰æ‹©çš„ä¸€å®šæ˜¯æœ€å·¦è¾¹çš„ä¸€ä¸ªï¼Œè¾“å‡ºè¿™ä¸ªæ•°ï¼›\nå°†è¿™ä¸ªæ•°æ‰€åœ¨ä½ç½®å·¦ä¾§çš„æ‰€æœ‰å¤‡é€‰é¡¹å…¨éƒ¨åˆ æ‰ï¼Œå¦‚æœåˆ æ‰çš„ä¸€ä¸ªå…ƒç´ åœ¨å³ä¾§ä»æœ‰å‡ºç°åˆ™é€šè¿‡ä½ç½®åºåˆ—æ‰¾åˆ°ç¬¬ä¸€ä¸ªåˆæ³•ä½ç½®æ›´æ–°ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼›\nå¦‚æœè¿™ä¸ªæ•°ä¸æ˜¯ a åˆ™è½¬ 3ï¼Œå¦‚æœæ˜¯ a åˆ™ç»“æŸæŒ‘é€‰è½¬ 2ã€‚\nè§£é‡Šç¬¬ 5 æ¡æ­¥éª¤ï¼ša çš„å­˜åœ¨é™åˆ¶äº†å…¶ä»–å…ƒç´ å¯é€‰çš„ä½ç½®ï¼Œå¦‚æœå…ˆé€‰äº† a çš„ä½ç½®åé¢å…¶ä»–å…ƒç´ ï¼Œé‚£ä¹ˆ a å°±ä¸€å®šé€‰ä¸åˆ°äº†ï¼›ä½†æ˜¯å¦‚æœ a å·²ç»é€‰èµ°äº†ï¼Œé‚£ä¹ˆ a å°†ä¸ä¼šå¯¹å…¶ä»–å…ƒç´ çš„é€‰æ‹©äº§ç”Ÿé™åˆ¶ï¼Œå› æ­¤å¯ä»¥æ‰©å¤§æŒ‘é€‰èŒƒå›´ä»¥ä¿è¯æœ€ä¼˜ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 300010; int a[N], fp[N], p[N], ne[N]; // fp æ˜¯ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œne æ˜¯ä¸‹ä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œp æ˜¯ç»´æŠ¤ ne çš„è¿‡ç¨‹é‡ multiset\u0026lt;int\u0026gt; s; // å¤‡é€‰é›†åˆ bool v[N]; int ls[N]; // æœ€åå‡ºç°çš„ä½ç½® int main() { int n, m = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); if (!fp[a[i]]) { m++; fp[a[i]] = i; p[a[i]] = i; } else { ne[p[a[i]]] = i; p[a[i]] = i; } } printf(\u0026#34;%d\\n\u0026#34;, m); bool f = true; // true: æ‰¾æœ€å¤§ false: æ‰¾æœ€å° for (int i = n, t = 0; i; --i) { if (!v[a[i]]) { ne[i] = n + 1; v[a[i]] = true, ls[m - t++] = i; } } memset(v, 0, sizeof(v)); int lstp = 0; // ä¸Šæ¬¡å‡ºç°çš„ä½ç½® for (int i = 1; i \u0026lt;= m; ++i) { for (int j = ls[i - 1] + 1; j \u0026lt;= ls[i]; ++j) { if (!v[a[j]]) s.insert(a[j]); } if (v[a[ls[i]]]) continue; while (!s.empty()) { multiset\u0026lt;int\u0026gt;::iterator it; if (f) it = --s.end(); else it = s.begin(); int num = *it; v[num] = true; printf(\u0026#34;%d \u0026#34;, num); s.erase(num); // å…¨éƒ¨åˆ æ‰ for (int j = lstp + 1; j \u0026lt;= fp[num]; ++j) { if (!v[a[j]]) { s.erase(s.find(a[j])); // åªåˆ ä¸€ä¸ª while (fp[a[j]] \u0026lt; fp[num]) fp[a[j]] = ne[fp[a[j]]]; } } lstp = fp[num]; f ^= 1; if (num == a[ls[i]]) break; } } printf(\u0026#34;\\n\u0026#34;); return 0; } E. ç²¾çµçƒ æ•°æ®åˆ†å±‚ï¼Œé¢„å¤„ç†é—´éš”ä¸å¤§äº 1000 çš„æŸ¥è¯¢ï¼Œæš´åŠ›å¤„ç†é—´éš”å¤§äº 1000 çš„æŸ¥è¯¢ï¼Œæœ€å 1e8 çš„è®¡ç®—é‡å®Œå…¨å¯ä»¥è¿‡ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int a[N]; long long b[1010][1010]; int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int j = 1; j \u0026lt;= 1000; ++j) { b[j][i % j] += a[i]; } } while (q--) { int op, x, y; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;op, \u0026amp;x, \u0026amp;y); if (op == 1) { if (x \u0026lt;= 1000) printf(\u0026#34;%lld\\n\u0026#34;, b[x][y % x]); else { long long res = 0; for (int i = y; i \u0026lt;= n; i += x) res += a[i]; for (int i = y - x; i \u0026gt; 0; i -= x) res += a[i]; printf(\u0026#34;%lld\\n\u0026#34;, res); } } else { for (int j = 1; j \u0026lt;= 1000; ++j) { b[j][x % j] += y - a[x]; } a[x] = y; } } return 0; } F. é’¢æ¡(stick) æˆ‘ä¸€ç›´åœ¨ä»åˆ‡å‰²çš„è§’åº¦çœ‹ï¼Œæ²¡æƒ³åˆ°ä»åˆ‡å‡ºçš„æ®µçš„è§’åº¦çœ‹ã€‚\né¦–å…ˆ n æ˜¯æ²¡ç”¨çš„ï¼Œåªçœ‹ k å³å¯ã€‚åˆ‡äº† k åˆ€ä¹‹åä¼šåˆ‡å‡ºæ¥ k + 1 æ®µï¼Œåªè¦æœ‰ä¸€æ®µé•¿åº¦ â‰¥ \\(\\frac{n}{2}\\)å°±ä¸åˆæ³•ï¼Œæ¯ä¸€æ®µ â‰¥ \\(\\frac{n}{2}\\)çš„æ¦‚ç‡æ˜¯ç›¸ç­‰çš„è€Œä¸”æ˜¯ç‹¬ç«‹çš„ï¼ˆå› ä¸ºä¸å¯èƒ½ä¸¤æ®µéƒ½æ»¡è¶³ï¼Œå’Œæ€»é•¿åº¦ä¸º n çŸ›ç›¾ï¼‰ï¼Œéƒ½æ˜¯ \\(\\frac{1}{2 ^ k}\\)ï¼Œæ‰€ä»¥ä¸åˆæ³•æ¦‚ç‡æ˜¯ \\(\\frac{k + 1}{2 ^ k}\\)ï¼Œåˆæ³•æ¦‚ç‡æ˜¯ \\(1 - \\frac{k + 1}{2 ^ k}\\)ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int a = m + 1, b = 1 \u0026lt;\u0026lt; m; int g = gcd(a, b); cout \u0026lt;\u0026lt; (b - a) / g \u0026lt;\u0026lt; \u0026#39;/\u0026#39; \u0026lt;\u0026lt; b / g \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-03-29T05:15:28Z","permalink":"https://invalidnamee.github.io/p/2025st11/","title":"2025æ˜¥è®­ç¬¬åä¸€åœº"},{"content":"A. é²çš„å­¦ç”Ÿ å¤§æ°´é¢˜ï¼Œä½†æ˜¯æˆ‘æ²¡çœ‹åˆ°è¦å–æ¨¡è¿ WA ä¸¤æ¬¡ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int MOD = 1000000007; int main() { long long res = 0; int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); res += (long long)i * (n - i + 1) % MOD * t % MOD; res %= MOD; } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } B. é²çš„æ¢é™© n ä¸ªç‚¹ n æ¡è¾¹ï¼Œè€Œä¸”æ¯ä¸ªç‚¹éƒ½è‡³å°‘æœ‰ 1 åº¦ï¼Œæ˜¾ç„¶è¿™å¼ å›¾æ˜¯åŸºç¯æ ‘ï¼ˆä¸€æ£µæ ‘éšä¾¿åŠ ä¸€æ¡è¾¹æ„æˆçš„è¿é€šçš„åªæœ‰ä¸€ä¸ªç¯çš„å›¾ï¼‰æ„æˆæ£®æ—ã€‚æ‰€æœ‰çš„ç‚¹æœ€åéƒ½ä¼šèµ°åˆ°å¯¹åº”è¿é€šå—çš„ç¯é‡Œï¼Œéšåç»•ä¸€åœˆç»“æŸï¼›æ˜ç™½äº†è¿™ç‚¹é‚£ä¹ˆåšæ³•å°±å¾ˆç®€å•äº†ï¼Œè®°ç‚¹ i çš„ç­”æ¡ˆä¸º \\(val_i\\)\nåˆ’åˆ†è¿é€šå—ï¼›\nå¯¹æ¯ä¸ªè¿é€šå—æ‰¾åˆ°ç¯çš„ä½ç½®ï¼›\nå¯¹äºæ¯ä¸ªç¯ï¼Œç¯ä¸Šçš„ç‚¹çš„ \\(A_i\\) æ±‚å’Œèµ‹ç»™è¿™ä¸ªç¯ä¸Šçš„æ‰€æœ‰ç‚¹ï¼›\nä»æ‰€æœ‰ç¯ä¸Šçš„ç‚¹å¼€å§‹æœç´¢åå›¾ï¼Œæ›´æ–°å…¶ä»–ç‚¹çš„ \\(val_i\\)ã€‚\nä»£ç æ¯”è¾ƒæ¶å¿ƒï¼Œå¦‚éœ€å‚è€ƒï¼Œè¯·è°¨æ…ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010; vector\u0026lt;int\u0026gt; ed[N]; int pre[N]; int a[N], vis[N], tot; int cir[N]; long long sum[N]; bool mark[N]; bool v[N]; // è¿™é‡Œæˆ‘åŸæ¥æ˜¯æŠŠ val ç”¨ä½œæ ‡è®°æ•°ç»„ï¼Œç„¶åå› ä¸ºæœ‰ val æ˜¯ 0 ä½†æ˜¯ç¡®å®è®¿é—®è¿‡çš„æ•°æ®å¯¼è‡´ä¸æ˜¯çˆ†æ ˆå°±æ˜¯ t // å‘ç°ä¹‹åä¸€æ€’ä¹‹ä¸‹å¼€äº†è¿™ä¸ª vvvvv bool vvvvv[N]; long long val[N]; void bfs(int i) { queue\u0026lt;int\u0026gt; q; q.push(i); vis[i] = tot; while (!q.empty()) { int x = q.front(); q.pop(); for (int y : ed[x]) { if (vis[y]) continue; vis[y] = tot; q.push(y); } if (!vis[pre[x]]) { vis[pre[x]] = tot; q.push(pre[x]); } } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;pre[i]); ed[pre[i]].push_back(i); } for (int i = 1; i \u0026lt;= n; ++i) { if (!vis[i]) { tot++; bfs(i); } } queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++i) { if (!mark[vis[i]]) { mark[vis[i]] = true; int x, y; for (x = i; !v[x]; x = pre[x]) { v[x] = true; } y = x; do { cir[y] = vis[i]; sum[vis[i]] += a[y]; y = pre[y]; } while (y != x); } } for (int i = 1; i \u0026lt;= n; ++i) { if (cir[i]) { q.push(i); vvvvv[i] = true; val[i] = sum[cir[i]]; } } while (!q.empty()) { int x = q.front(); q.pop(); for (int y : ed[x]) { if (vvvvv[y]) continue; vvvvv[y] = true; val[y] = val[x] + a[y]; q.push(y); } } for (int i = 1; i \u0026lt;= n; ++i) { printf(\u0026#34;%lld\\n\u0026#34;, val[i]); } return 0; } C. ä»–ä¼šè¾“å‡ºå•¥ æˆ‘ç”¨ python å†™çš„ï¼Œå®é™…ä¸Šç”¨ C++ åŒºåˆ«ä¸å¤§ï¼Œæ³¨æ„åˆ«çˆ† int å°±è¡Œã€‚\næ€è·¯æ˜¯æŠŠç¬¬äºŒä¸ªå¾ªç¯ç›´æ¥ç”¨ç­‰å·®æ•°åˆ—æ±‚å’Œå…¬å¼ç®—å‡ºæ¥ï¼Œåªè·‘ç¬¬ä¸€å±‚å¾ªç¯æ—¶é—´å¤æ‚åº¦æ˜¯å®Œå…¨å¤Ÿçš„çš„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def fun(a, b, c): if a in range(a, b, c): t = len(range(a, b, c)) return a * t + c * t * (t - 1) // 2 else: return 0 input() s = input() a, b, c = map(int, s[s.find(\u0026#39;(\u0026#39;) + 1:s.find(\u0026#39;)\u0026#39;)].split(\u0026#39;,\u0026#39;)) s = input() d, e, f = s[s.find(\u0026#39;(\u0026#39;) + 1:s.find(\u0026#39;)\u0026#39;)].split(\u0026#39;,\u0026#39;) if d.isalpha() and e.isalpha(): print(sum(fun(i, i, int(f)) for i in range(a, b, c))) elif d.isalpha(): print(sum(fun(i, int(e), int(f)) for i in range(a, b, c))) elif e.isalpha(): print(sum(fun(int(d), i, int(f)) for i in range(a, b, c))) else: print(sum(fun(int(d), int(e), int(f)) for i in range(a, b, c))) ","date":"2025-03-24T09:41:59Z","permalink":"https://invalidnamee.github.io/p/2025st10/","title":"2025 æ˜¥è®­ç¬¬ååœº"},{"content":"A. é²çš„æ™ºåŠ› æˆ‘åˆšå¼€å§‹çœ‹åˆ°è¿™é“é¢˜ä¹‹åé»˜é»˜çš„æ”¾å¼ƒäº†ï¼Œé€‰æ‹©äº†åé¢çš„ dp é¢˜ã€‚\næœ€å°æ’åï¼šè‡³å°‘æœ‰å¤šå°‘ä¸ªäººæ¯”ä»–åˆ†æ•°é«˜ã€‚\næœ€å¤§æ’åï¼šè‡³å°‘æœ‰å¤šå°‘ä¸ªäººæ¯”ä»–åˆ†æ•°ä½ã€‚\nä¸¤è¾¹éƒ½æ˜¯è€ƒè™‘æé™æƒ…å†µï¼Œä»¥ç¬¬ä¸€ç§ä¸ºä¾‹ã€‚ä¸€ä¸ªäººè¦æƒ³ç¨³å®šçš„åˆ†æ•°æ¯”å¦ä¸€ä¸ªäººé«˜ï¼Œé‚£å¿…ç„¶æ¯é“é¢˜éƒ½æ¯”å¦ä¸€ä¸ªé«˜ï¼Œäºæ˜¯é—®é¢˜è½¬åŒ–æˆè‡³å°‘æœ‰å‡ ä¸ªäººæ¯é“é¢˜åˆ†æ•°éƒ½æ¯”ä»–é«˜ã€‚è®¾ç¬¬ i é“é¢˜çš„æ’åæ˜¯ \\(a_i\\)ï¼Œè€ƒè™‘ä¸€é“é¢˜çš„æ—¶å€™ï¼Œæƒ…å†µæ˜¯ç¡®å®šçš„ï¼Œè¿™é“é¢˜æ¯”ä»–é«˜çš„äººè‚¯å®šæ»¡è¶³æ‰€æœ‰é¢˜éƒ½æ¯”ä»–é«˜ï¼›ä¸¤é“é¢˜çš„æ—¶å€™ï¼Œè€ƒè™‘è¾¹ç•Œæƒ…å†µâ€”â€”ç¬¬äºŒé“é¢˜æ¯”ä»–é«˜çš„äººå’Œç¬¬ä¸€é“é¢˜æ¯”ä»–é«˜çš„äººæœ€å¤§ç¨‹åº¦çš„ä¸é‡å ï¼Œæ‰€ä»¥äººæ•°åº”è¯¥æ˜¯ \\(\\max{0, a_2 + a_1 - m - 1}\\)ï¼›ç°åœ¨ç›¸å½“äºå‰ä¸¤é“é¢˜å·²ç»åˆæˆä¸€é“å¤§çš„é¢˜äº†ï¼Œå†ä¸æ–­å¾€ä¸‹è®¡ç®—å°±èƒ½ç®—å‡ºæ¥æœ€åçš„ç»“æœã€‚ç¬¬äºŒç§åŒç†ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int a[1010]; int main() { int n, m, l, r; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; l = r = m - 1; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i]; l = max(0, a[i] + l - m); r = max(0, (m - a[i]) + r - (m - 1)); } cout \u0026lt;\u0026lt; l + 1 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m - r \u0026lt;\u0026lt; endl; return 0; } B. é²çš„å¥³å­© æœ€ä¼˜çš„é…å¯¹æ–¹æ¡ˆæ˜¯ä¸€ä¸ªæ­£åºä¸€ä¸ªå€’åºä¸€ä¸€é…å¯¹ã€‚å…³é”®çš„æ€§è´¨æ˜¯ 1 â‰¤ a, b â‰¤ 100ï¼Œå¼€ä¸¤ä¸ªæ•°ç»„è®°å½• \\[1, 100\\] æ¯ä¸ªæ•°çš„ä¸ªæ•°ï¼Œç„¶ååŒæŒ‡é’ˆæ‰«æä¸€æ¬¡å³å¯å¾—å‡ºç­”æ¡ˆã€‚äº‹å®å¯ä»¥è¯æ˜ï¼ŒæŒºå®¹æ˜“å†™æŒ‚çš„ï¼ˆæ¯”å¦‚æˆ‘ï¼‰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int a[210], b[210]; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { int ta, tb; cin \u0026gt;\u0026gt; ta \u0026gt;\u0026gt; tb; a[ta]++, b[tb]++; int mx = -0x3f3f3f3f; int l = 0, r = 101; int lc = 0, rc = 0; while (l \u0026lt;= 100 \u0026amp;\u0026amp; r \u0026gt; 0) { if (lc \u0026amp;\u0026amp; rc) { mx = max(mx, l + r); int tmp = min(lc, rc); lc -= tmp, rc -= tmp; } if (!rc) rc = b[--r]; if (!lc) lc = a[++l]; } cout \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; endl; } return 0; } C. é²çš„çŸ³æ¿ å‰æ’è­¦å‘Šï¼Œæœ€å¥½åˆ«ç”¨ vector ä¸€ç›´ç”³è¯·å†…å­˜å®¹æ˜“ TLEğŸ˜­\nè¿™é¢˜å¥½åƒæœ‰æ•°å­¦çš„æ–¹æ³•å¯ä»¥ä¸€ä¸ªå¼å­ç§’äº†ï¼Œæ²¡å…³ç³»ï¼Œæˆ‘ä¼šä¸€ä¸ªçŸ©é˜µå¿«é€Ÿå¹‚ç§’äº†ã€‚\nçº¿æ€§ dp çš„æ–¹æ³•æ˜¯å¼€ä¸€ä¸ªçŠ¶æ€æ•°ç»„ f\n\\[N\\]\\[2\\]ï¼Œf\n\\[i\\]\\[0\\] = è¡¨ç¤ºæ¶‚åˆ°ç¬¬ i å—ä¸”ç¬¬ i å—é¢œè‰²å’Œç¬¬ä¸€å—ä¸€è‡´çš„æ–¹æ¡ˆæ•°ï¼Œf\n\\[i\\]\\[1\\] è¡¨ç¤ºæ¶‚åˆ°ç¬¬ i å—ä¸”ç¬¬ i å—é¢œè‰²å’Œç¬¬ä¸€å—ä¸ä¸€è‡´çš„æ–¹æ¡ˆæ•°ï¼Œç­”æ¡ˆæ˜¯ f\n\\[n\\]\\[1\\]ã€‚\n\\[f_{i, 0} = f_{i - 1, 1}\\]\n\\[f_{i, 1} = (m - 1)f_{i - 1, 0} + (m - 2)f_{i - 1, 1}\\]\nç”¨çŸ©é˜µä¹˜æ³•å†™è¿™ä¸ªé€’æ¨å¼\n\\[\\begin{pmatrix} f_{i - 1, 0} \u0026amp; f_{i - 1, 1} \\end{pmatrix} \\begin{pmatrix} 0 \u0026amp; m - 1\\ 1 \u0026amp; m - 2 \\end{pmatrix} = \\begin{pmatrix} f_{i, 0} \u0026amp; f_{i, 1} \\end{pmatrix}\\]\næ˜¾ç„¶ç­”æ¡ˆæ˜¯ \\([\\begin{pmatrix} m \u0026amp; 0\\end{pmatrix}\\begin{pmatrix} 0 \u0026amp; m - 1 \\ 1 \u0026amp; m - 2 \\end{pmatrix}^{n - 1}]{1, 2}\\)ï¼Œå³ \\(m\\begin{pmatrix} 0 \u0026amp; m - 1 \\ 1 \u0026amp; m - 2 \\end{pmatrix}^{n - 1}{1, 2}\\).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MOD = 1000000007; long long mat[2][2], res[2][2], a[2][2], b[2][2]; void mul(long long a[][2], long long b[][2]) { static long long t[2][2]; t[0][1] = t[0][0] = t[1][1] = t[1][0] = 0; for (int k = 0; k \u0026lt; 2; ++k) { for (int i = 0; i \u0026lt; 2; ++i) { for (int j = 0; j \u0026lt; 2; ++j) { t[i][j] = (t[i][j] + a[i][k] * b[k][j] % MOD) % MOD; } } } for (int i = 0; i \u0026lt; 2; ++i) { for (int j = 0; j \u0026lt; 2; ++j) { a[i][j] = t[i][j]; } } } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); if (n == 1) { cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; continue; } mat[0][0] = 0, mat[0][1] = m - 1, mat[1][0] = 1, mat[1][1] = m - 2; res[0][0] = res[1][1] = 1, res[0][1] = res[1][0] = 0; n--; while (n) { if (n \u0026amp; 1) mul(res, mat); mul(mat, mat); n \u0026gt;\u0026gt;= 1; } printf(\u0026#34;%d\\n\u0026#34;, (long long)m * res[0][1] % MOD); } return 0; } D. æ¸¸è§ˆè®¡åˆ’ æä¾›ä¸€ä¸ªæš´åŠ›çš„è§£æ³•ï¼Œå…·ä½“æœ‰å¤šæš´åŠ›è§ä¸‹å›¾ï¼Œå·®ç‚¹æ‹¼å°½å…¨åŠ›æ— æ³•æˆ˜èƒœäº†â€¦â€¦\næš´åŠ›çš„æµç¨‹æ˜¯\nå¯¹äºæ¯ä¸€ä¸ªç‚¹è·‘ä¸€é bfs æ‰¾åˆ°åˆ°æ‰€æœ‰å…¶ä»–ç‚¹çš„æœ€çŸ­è·¯ï¼›\nå¯¹äºæ¯ä¸€ä¸ªç‚¹æ‰¾åˆ°æœ€çŸ­è·¯æœ€é•¿çš„ä¸‰ä¸ªç‚¹ï¼Œè®°ä¸‹æ¥ï¼›\næš´åŠ›æšä¸¾ä¸­é—´ç‚¹ B, Cï¼Œæšä¸¾åˆ° B è·ç¦»æœ€é•¿çš„ä¸‰ä¸ª Aï¼Œåˆ° C è·ç¦»æœ€é•¿çš„ä¸‰ä¸ª Dï¼Œè¿‡æ»¤æ‰€æœ‰A, B, C, D é‡å¤æƒ…å†µï¼ŒæŠŠè·¯å¾„åŠ èµ·æ¥æ›´æ–°ç­”æ¡ˆã€‚\nè¿™ä¸ªåšæ³•æ˜¾ç„¶æ˜¯æ­£ç¡®çš„ï¼Œå­˜äº†ä¸‰ä¸ªæœ€è¿œçš„ç‚¹ä¿è¯äº†æœ€åçš„æƒ…å†µä¸‹ä¹Ÿä¸è‡³äºå…¨éƒ¨å†²çªã€‚\nä»£ç åç»­æ›´æ–°äº†ä¸€ä¸‹ï¼Œä¸ä¼š 997ms äº†ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 4010, M = 5010; int head[N], ne[M * 2], ver[M * 2], tot; int d[N][N], q[N], hh, tt; int mxp[N][3]; inline void read(int \u0026amp;_) { _ = 0; char c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) _ = _ * 10 + c - 48, c = getchar(); } inline void add(int x, int y) { ver[++tot] = y; ne[tot] = head[x]; head[x] = tot; } int main() { int n, m; read(n), read(m); for (int i = 1; i \u0026lt;= m; ++i) { int x, y; read(x), read(y); add(x, y); add(y, x); } memset(d, -1, sizeof(d)); for (int i = 1; i \u0026lt;= n; ++i) { hh = tt = 0; d[i][i] = 0; q[tt] = i; while (hh \u0026lt;= tt) { int x = q[hh++]; if (d[i][x] \u0026gt;= d[i][mxp[i][0]]) { mxp[i][2] = mxp[i][1], mxp[i][1] = mxp[i][0]; mxp[i][0] = x; } else if (d[i][x] \u0026gt;= d[i][mxp[i][1]]) { mxp[i][2] = mxp[i][1]; mxp[i][1] = x; } else if (d[i][x] \u0026gt;= d[i][mxp[i][2]]) { mxp[i][2] = x; } for (int j = head[x]; j; j = ne[j]) { int y = ver[j]; if (~d[i][y]) continue; d[i][y] = d[i][x] + 1; q[++tt] = y; } } } int res = 0; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt; i; ++j) { for (int k = 0; k \u0026lt; 3; ++k) { if (mxp[i][k] == j) continue; for (int p = 0; p \u0026lt; 3; ++p) { if (i != mxp[j][p] \u0026amp;\u0026amp; mxp[i][k] != mxp[j][p]) res = max(res, d[mxp[i][k]][i] + d[i][j] + d[j][mxp[j][p]]); } } } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } ","date":"2025-03-24T09:41:34Z","permalink":"https://invalidnamee.github.io/p/2025st9/","title":"2025æ˜¥è®­ç¬¬ä¹åœº"},{"content":"æ—§ç‰ˆçš„å’Œ hyoi ä¸€èµ·å´©äº†ï¼Œæ‰€ä»¥å†å‘ä¸€éå‡çº§ç‰ˆ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; class Hipre { vector\u0026lt;int\u0026gt; a; public: void mv(int t) { vector\u0026lt;int\u0026gt; b(t, 0); b.insert(b.end(), a.begin(), a.end()); a = b; } Hipre() { a = vector\u0026lt;int\u0026gt;(1, 0); } Hipre(int n) { if (!n) { a = vector\u0026lt;int\u0026gt;(1, 0); } else while (n) { a.push_back(n % 10); n /= 10; } } int length() const { return a.size(); } int to_int() { int res = 0, mul = 1; for (int i = 0; i \u0026lt; a.size(); ++i) { res += a[i] * mul; mul *= 10; } return res; } int \u0026amp;operator [](const int \u0026amp;p) { return a[p]; } friend istream \u0026amp;operator \u0026gt;\u0026gt;(istream \u0026amp;cin, Hipre \u0026amp;a) { static string s; cin \u0026gt;\u0026gt; s; a.a = vector\u0026lt;int\u0026gt;(s.length()); for (int i = 0; i \u0026lt; s.length(); ++i) { a.a[i] = s[s.length() - i - 1] - 48; } while (a.length() \u0026gt; 1 \u0026amp;\u0026amp; a.a.back() == 0) a.a.pop_back(); return cin; } friend ostream \u0026amp;operator \u0026lt;\u0026lt;(ostream \u0026amp;cout, const Hipre \u0026amp;a) { for (int i = a.length() - 1; i \u0026gt;= 0; --i) cout \u0026lt;\u0026lt; a.a[i]; return cout; } bool operator \u0026lt;(const Hipre \u0026amp;c) const { if (length() != c.length()) return length() \u0026lt; c.length(); else { for (int i = length() - 1; i \u0026gt;= 0; --i) { if (a[i] != c.a[i]) return a[i] \u0026lt; c.a[i]; } return false; } } bool operator ==(const Hipre \u0026amp;c) const { if (length() != c.length()) return false; else { for (int i = length() - 1; i \u0026gt;= 0; --i) { if (a[i] != c.a[i]) return false; } return true; } } Hipre operator +(const Hipre \u0026amp;c) { auto \u0026amp;b = c.a; Hipre res; res.a = vector\u0026lt;int\u0026gt;(max(a.size(), b.size()) + 1, 0); for (int i = 0; i \u0026lt; res.length(); ++i) { if (i \u0026lt; a.size() \u0026amp;\u0026amp; i \u0026lt; b.size()) res[i] += a[i] + b[i]; else if (i \u0026lt; a.size()) res[i] += a[i]; else if (i \u0026lt; b.size()) res[i] += b[i]; if (res[i] \u0026gt; 9) res.a[i + 1] += 1, res[i] -= 10; } while (res.length() \u0026gt; 1 \u0026amp;\u0026amp; res.a.back() == 0) res.a.pop_back(); return res; } Hipre operator -(const Hipre \u0026amp;c) { Hipre res = *this; for (int i = 0; i \u0026lt; res.length(); ++i) { if (i \u0026lt; c.length()) res[i] -= c.a[i]; if (res[i] \u0026lt; 0) res[i] += 10, res.a[i + 1] -= 1; } while (res.length() \u0026gt; 1 \u0026amp;\u0026amp; res.a.back() == 0) res.a.pop_back(); return res; } Hipre operator *(const Hipre \u0026amp;c) { auto \u0026amp;b = c.a; Hipre res; res.a = vector\u0026lt;int\u0026gt;(a.size() + b.size(), 0); for (int i = 0; i \u0026lt; a.size(); ++i) { for (int j = 0; j \u0026lt; b.size(); ++j) { res.a[i + j] += a[i] * b[j]; } } for (int i = 0; i \u0026lt; res.length() - 1; ++i) { res.a[i + 1] += res[i] / 10; res[i] %= 10; } while (res.length() \u0026gt; 1 \u0026amp;\u0026amp; res.a.back() == 0) res.a.pop_back(); return res; } Hipre operator *=(const int \u0026amp;c) { if (c) a.resize(a.size() + (int)floor(log10(c)) + 1); for (int i = 0; i \u0026lt; a.size(); ++i) { a[i] *= c; } for (int i = 0; i \u0026lt; a.size() - 1; ++i) { if (a[i] \u0026gt; 9) a[i + 1] += a[i] / 10, a[i] %= 10; } while (a.size() \u0026gt; 1 \u0026amp;\u0026amp; a.back() == 0) a.pop_back(); return *this; } Hipre operator *(const int \u0026amp;c) { Hipre t = *this; return t *= c; } Hipre operator /(const int \u0026amp;c) { Hipre res; res.a = vector\u0026lt;int\u0026gt;(a.size()); int t = 0; for (int i = a.size() - 1; i \u0026gt;= 0; --i) { t = t * 10 + a[i]; if (t \u0026gt;= c) res[i] = t / c; t %= c; } while (res.length() \u0026gt; 1 \u0026amp;\u0026amp; res.a.back() == 0) res.a.pop_back(); return res; } Hipre operator /(Hipre c) { Hipre res, b = *this; int l = b.length() - c.length(); res.a = vector\u0026lt;int\u0026gt;(l + 1, 0); c.mv(b.length() - c.length()); for (int i = l; i \u0026gt;= 0; --i) { while (!(b \u0026lt; c)) { b = b - c; res[i]++; } c.a.erase(c.a.begin()); } while (res.length() \u0026gt; 1 \u0026amp;\u0026amp; res.a.back() == 0) res.a.pop_back(); return res; } Hipre operator %(Hipre c) { Hipre b = *this; int l = b.length() - c.length(); c.mv(b.length() - c.length()); for (int i = l; i \u0026gt;= 0; --i) { while (!(b \u0026lt; c)) { b = b - c; } c.a.erase(c.a.begin()); } while (b.length() \u0026gt; 1 \u0026amp;\u0026amp; b.a.back() == 0) b.a.pop_back(); return b; } }; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); Hipre a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; a / b \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-03-22T03:15:46Z","permalink":"https://invalidnamee.github.io/p/high-precision/","title":"é«˜ç²¾å…¨å®¶æ¡¶ï¼ˆå‡çº§ç‰ˆï¼‰"},{"content":"è¿™æ¬¡è®­ç»ƒèµ›ä¸»æ‰“ä¸€ä¸ªç‰¹æ®Šæƒ…å†µ REï¼Œä¸ç»†å¿ƒä¸€ç‚¹æœ‰ä¸€ä¸‡ä¸ªå‘èƒ½è®©ç¨‹åºç‚¸æ‰â€¦â€¦\nA. èƒ½é‡ä¼ è¾“ ä¸éš¾ï¼ˆä¸å®¹æ˜“ï¼‰å‘ç°ï¼Œk è¶Šå°èšé›†åˆ°çš„ä½ç½®è¶Šå¤šï¼Œæ“ä½œæ¬¡æ•°è¶Šå°ï¼Œæ‰€ä»¥åšæ³•æ˜¯\nç»Ÿè®¡ 1 çš„ä¸ªæ•°ï¼Œæ‰¾åˆ°é™¤äº† 1 ä»¥å¤–çš„æœ€å°çš„çº¦æ•°ä½œä¸º kï¼›\næ¯ k ä¸ª 1 åˆ†æˆä¸€ç»„ï¼Œå„ç»„ç‹¬ç«‹è®¡ç®—æœ€å°æ“ä½œæ¬¡æ•°ï¼›\nä½¿å¾—æ“ä½œæ•°æœ€å°çš„ä½ç½®ä¸€å®šæ˜¯ä¸­ä½æ•°ï¼Œæ‰€ä»¥æŠŠåˆ°ä½ç½®ä¸­ä½æ•°çš„è·ç¦»æ±‚å’Œå³å¯ã€‚\næ³¨æ„ç‰¹åˆ¤ 0 ä¸ªï¼Œä¼šç‚¸æ‰ï¼ï¼ï¼\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;vector\u0026gt; #define int long long using namespace std; int a[100010], b[100010]; int len; signed main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n, s = 0, l; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i]; s += a[i]; } if (s == 0) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } l = sqrt(s); int t = s; for (int i = 2; i \u0026lt;= l; ++i) { if (s % i == 0) { t = i; break; } } long long res = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (a[i]) b[++len] = i; if (len == t) { int pos = b[(len + 1) / 2]; for (int j = 1; j \u0026lt;= len; ++j) { res += abs(b[j] - pos); } len = 0; } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } B. èƒ½æºå±æœº ä½ è¯´çš„å¯¹ï¼Œä½†æ˜¯æˆ‘å¯ä»¥ç”¨ Pythonï¼Œç”¨ C++ å†™é«˜ç²¾çš„è¯å¤§æ¦‚æ€è·¯å°±æ˜¯é™¤æ•°åé¢è¡¥é›¶ç›´åˆ°æœ€é«˜ä½å’Œè¢«é™¤æ•°å¯¹é½ï¼Œå‡åˆ°ä¸èƒ½å†å‡ï¼Œç„¶åé™¤æ•°åˆ ä¸€ä¸ªé›¶ç»§ç»­å‡ï¼Œé«˜ç²¾å…¨å®¶æ¡¶ä¼ é€é—¨ã€‚\n1 2 3 4 5 import sys sys.set_int_max_str_digits(300000) a = int(input()) b = int(input()) print(a // b) C. é²æ˜Ÿæ•‘æ´ æ²¡ä»€ä¹ˆæŠ€æœ¯å«é‡ï¼Œæ¥æ¥å›å›æœçš„å¾ˆæ¶å¿ƒã€‚å…ˆä» s æœåˆ° pï¼ŒæŠŠè·¯ä¸Šçš„ç‚¹å…¨éƒ½æ ‡è®°ä¸Šï¼›ç„¶åï¼ŒæŠŠæ ‡è®°ä¸Šçš„ç‚¹éƒ½åŠ åˆ°ä¸€ä¸ªæ–°é˜Ÿåˆ—é‡Œï¼Œæœ t å³å¯ã€‚\npsï¼šæ³¨æ„æŒ‰ç…§é¢˜ç›®è¯´çš„é¡ºåºæœã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; /* ä¸Šä»£è¡¨ 1ï¼Œå³ä»£è¡¨ 2ï¼Œä¸‹ä»£è¡¨ 3ï¼Œå·¦ä»£è¡¨ 4 */ const int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1}; int a[1010][1010]; int dis[1010][1010]; bool vis[1010][1010]; pair\u0026lt;int, int\u0026gt; pre[1010][1010]; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n, m, sx, sy, tx, ty, px, py; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; sx \u0026gt;\u0026gt; sy \u0026gt;\u0026gt; tx \u0026gt;\u0026gt; ty \u0026gt;\u0026gt; px \u0026gt;\u0026gt; py; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { cin \u0026gt;\u0026gt; a[i][j]; } } // è¾¹ç•Œå…¨éƒ½å µä¸Šï¼Œé˜²æ­¢æœå‡ºå»æ•°ç»„è¶Šç•Œ RE for (int i = 1; i \u0026lt;= n; ++i) a[i][0] = a[i][m + 1] = 1; for (int i = 1; i \u0026lt;= m; ++i) a[0][i] = a[n + 1][i] = 1; queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; q.push({sx, sy}); vis[sx][sy] = true; bool f = false; while (!q.empty()) { auto x = q.front(); q.pop(); if (x == make_pair(px, py)) { f = true; while (!q.empty()) { q.pop(); } memset(vis, 0, sizeof(vis)); if (pre[x.first][x.second] == make_pair(0, 0)) { vis[sx][sy] = true; dis[sx][sy] = 1; q.push({sx, sy}); break; } do { q.push(x); dis[x.first][x.second] = 1; vis[x.first][x.second] = true; x = pre[x.first][x.second]; } while (x != make_pair(sx, sy)); vis[sx][sy] = true; dis[sx][sy] = 1; q.push(make_pair(sx, sy)); break; } for (int i = 0; i \u0026lt; 4; ++i) { auto y = x; y.first += dx[i], y.second += dy[i]; if (a[y.first][y.second] || vis[y.first][y.second]) continue; pre[y.first][y.second] = x; vis[y.first][y.second] = true; q.push(y); } } if (!f) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } while (!q.empty()) { auto x = q.front(); q.pop(); for (int i = 0; i \u0026lt; 4; ++i) { auto y = x; y.first += dx[i], y.second += dy[i]; if (dis[y.first][y.second] || a[y.first][y.second]) continue; dis[y.first][y.second] = dis[x.first][x.second] + 1; q.push(y); } } cout \u0026lt;\u0026lt; dis[tx][ty] - 1 \u0026lt;\u0026lt; endl; return 0; } E. ä¿„ç½—æ–¯æ–¹å— (tetris) ç®€åŒ–ç‰ˆï¼šè¦†ç›–å¢™å£.\næˆ‘åšè¿™é“é¢˜çš„æ—¶å€™ç”¨çº¿æ€§çš„ dp æ‰“è¡¨æ‰¾è§„å¾‹åšçš„ï¼Œå®é™…ä¸Šæ˜¯å¯ä»¥ç›´æ¥æ¨å‡ºæ¥çš„ã€‚\næœ€åä¸‰ä¸ªæ–¹å—åªè¦æ”¾è¿›å»ä¸€å®šä¼šå µæ­»ï¼Œç›´æ¥å¿½ç•¥ï¼›æšä¸¾æœ€åä¸€ä¸ªå®Œæ•´çš„çŸ©å½¢å—çš„å½¢çŠ¶ï¼Œåªæœ‰ä»¥ä¸‹å››ç§å½¢çŠ¶\nä¸¤ä¸ª 1 Ã— 4 çš„æ–¹å—å¹¶æ’ï¼›\nä¸€ä¸ª 2 Ã— 2 çš„æ–¹å—ï¼›\nä¸¤ä¸ªç›¸åŒ L å½¢æ–¹å—ï¼Œä¸­é—´å¯ä»¥å¤¹å¤šä¸ª 1 Ã— 4 çš„æ–¹å—ï¼›\nä¸¤ä¸ªä¸åŒ L å½¢æ–¹å— + ä¸€ä¸ª 1 Ã— 4 çš„æ–¹å—ï¼Œä¸­é—´åŒæ ·å¯ä»¥å¤¹å¤šä¸ª 1 Ã— 4 çš„æ–¹å—ã€‚\nå¦‚ä¸‹å›¾\nè®¡ \\(f_i\\) ä¸º 2 Ã— i æ—¶çš„æ–¹æ¡ˆæ•°ï¼Œä¸éš¾å¾—å‡º\n\\[f_i = f_{i - 4} + f_{i - 2} + 2 (f_{i - 4} + f_{i - 8} + \\dots) + 2 (f_{i - 6} + f_{i - 10} + \\dots)\\]\nç»´æŠ¤ä¸€ä¸ª f æ•°ç»„çš„å‰ç¼€å’Œå³å¯å¾—åˆ°çº¿æ€§çš„åšæ³•ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int MOD = 1000000007; int f[10000010]; int s[10000010], s2[10000010]; int main() { int n; while (cin \u0026gt;\u0026gt; n) { f[0] = 1; s[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { f[i] = 0; if (i - 2 \u0026gt;= 0) f[i] = (f[i] + f[i - 2]) % MOD; if (i - 4 \u0026gt;= 0) f[i] = (f[i] + f[i - 4]) % MOD; if (i \u0026gt;= 4) f[i] = (f[i] + 2 * s[i - 4] % MOD) % MOD; if (i \u0026gt;= 6) f[i] = (f[i] + 2 * s[i - 6] % MOD) % MOD; if (i \u0026gt;= 4) s[i] = (f[i] + s[i - 4]) % MOD; else s[i] = f[i]; } cout \u0026lt;\u0026lt; f[n] \u0026lt;\u0026lt; endl; } return 0; } æ˜¾ç„¶è¿™è¿˜ä¸å¤Ÿï¼Œæ•°æ®èŒƒå›´æ˜¯ 1e18 è¿˜éœ€è¦å†ä¼˜åŒ–ï¼Œäºæ˜¯åˆåˆ°äº†å–œé—»ä¹è§çš„çŸ©é˜µå¿«é€Ÿå¹‚ç¯èŠ‚ã€‚\næ˜¾ç„¶å¥‡æ•°æ˜¯ä¸å¯èƒ½çš„ï¼Œå¯¹äºå¶æ•°çš„æƒ…å†µé‡æ–°ç¼–å·ä¸€ä¸‹ï¼ˆå¥½çœ‹ï¼‰\n\\[f_i = f_{i - 1} + f_{i - 2} + 2 (f_{i - 2} + f_{i - 4} + \\dots) + 2 (f_{i - 3} + f_{i - 5} + \\dots)\\]\nåé¢ä¸¤é¡¹å¯ä»¥åˆå¹¶\n\\[f_i = f_{i - 1} + f_{i - 2} + 2 \\sum_{j = 0}^{i - 2}{f_j}\\]\nè¿™æ ·å°±å¥½æ„é€ çŸ©é˜µäº†ï¼Œå…¶ä¸­ \\(s_i = \\sum_{j = 0}^i{f_j}\\)\n\\[\\begin{pmatrix} f_{i - 2} \u0026amp; f_{i - 1} \u0026amp; s_{i - 2} \\end{pmatrix} \\begin{pmatrix} 0 \u0026amp; 1 \u0026amp; 0\\ 1 \u0026amp; 1 \u0026amp; 1\\ 0 \u0026amp; 2 \u0026amp; 1\\ \\end{pmatrix} = \\begin{pmatrix} f_{i - 1} \u0026amp; f_{i} \u0026amp; s_{i - 1} \\end{pmatrix}\\]\nç´¯ä¹˜å¯ä»¥å¾—åˆ°\n\\[\\begin{pmatrix} 1 \u0026amp; 1 \u0026amp; 1 \\end{pmatrix} \\begin{pmatrix} 0 \u0026amp; 1 \u0026amp; 0\\ 1 \u0026amp; 1 \u0026amp; 1\\ 0 \u0026amp; 2 \u0026amp; 1\\ \\end{pmatrix} ^{n - 1} = \\begin{pmatrix} f_{n - 1} \u0026amp; f_{n} \u0026amp; s_{n - 1} \\end{pmatrix}\\]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MOD = 1000000007; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; mul(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; b) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(3, vector\u0026lt;int\u0026gt;(3, 0)); for (int k = 0; k \u0026lt; 3; ++k) { for (int i = 0; i \u0026lt; 3; ++i) { for (int j = 0; j \u0026lt; 3; ++j) { res[i][j] = (res[i][j] + (long long)a[i][k] * b[k][j] % MOD) % MOD; } } } return res; } int main() { long long n; while (cin \u0026gt;\u0026gt; n) { if (n \u0026amp; 1) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else { n \u0026gt;\u0026gt;= 1; n--; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; mat = { {0, 1, 0}, {1, 1, 1}, {0, 2, 1} }, res = { {1, 0, 0}, {0, 1, 0}, {0, 0, 1} }; while (n) { if (n \u0026amp; 1) res = mul(res, mat); mat = mul(mat, mat); n \u0026gt;\u0026gt;= 1; } cout \u0026lt;\u0026lt; ((long long)res[1][0] + res[1][1] + 2 * res[1][2]) % MOD \u0026lt;\u0026lt; endl; } } return 0; } ","date":"2025-03-22T03:07:17Z","permalink":"https://invalidnamee.github.io/p/2025st8/","title":"2025æ˜¥è®­ç¬¬å…«åœº"},{"content":"ä¼—æ‰€å‘¨çŸ¥ç¦»æ•£è¯¾æœ¬ 204 é¡µ 17 é¢˜è®©ç”¨ Dijkstra å’Œ Floyd æ±‚ä¸€ä¸ª 9 ä¸ªç»“ç‚¹çš„å›¾çš„æœ€çŸ­è·¯å¾„ã€‚2025 å¹´ 3 æœˆ 18 æ—¥ä¸Šåˆï¼Œæˆ‘æŠ„äº†ä¸€èŠ‚å²çº²è¯¾çš„ Dijkstra è¿‡ç¨‹å’Œ Floyd çš„é‚»æ¥çŸ©é˜µï¼Œå¿ƒä¸­æ„¤æ‡‘ä¸å¹³ã€‚äºæ˜¯ä¸­åˆå›å®¿èˆçŒ›æ•²ä»£ç é›¶ç‚¹å‡ ç§’å°±æŠŠå…¨éƒ¨éƒ½è¿‡ç¨‹éƒ½è¾“å‡ºå‡ºæ¥äº†ï¼Œé‚æŠŠä»£ç æ‰“åŒ…è·Ÿç¦»æ•£ä½œä¸šä¸€èµ·äº¤ä¸Šå»äº†ã€‚\nä½†æ˜¯è¿™æ ·è¿˜ä¸å¤Ÿï¼Œå†™çš„ä»£ç è¿˜èƒ½å†æ°´ä¸€ç¯‡åšå®¢ï¼ˆè™½ç„¶ä¸ä¼šæœ‰äººçœ‹ğŸ˜­ï¼‰\nå›¾çš„å­˜å‚¨ æ‰‹æ•² æœ€å¥½æ˜¯æŠŠè¾¹ä¸€æ¡ä¸€æ¡æ•²å‡ºæ¥ï¼Œæ ¼å¼å¦‚ x y wï¼Œè¡¨ç¤º x å’Œ y é—´æœ‰ä¸€æ¡è¾¹æƒä¸º w çš„è¾¹(è¿™é“é¢˜æ˜¯æ— å‘è¾¹).\ndat.txt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 9 15 1 2 6 1 3 3 1 4 2 2 3 2 3 4 2 2 5 1 4 5 6 4 6 10 5 6 10 5 7 2 6 8 2 5 8 3 7 9 3 5 9 6 8 9 4 æ ‡å‡ºæ¥ç‚¹æ•°å’Œè¾¹æ•°æ–¹ä¾¿ç¨‹åºè¯»ã€‚\nç”µè„‘å­˜ Dijkstra æœ€å¥½ç”¨é‚»æ¥è¡¨â€”â€”è¯´ç™½äº†å°±æ˜¯å¼€ n ä¸ªå•é“¾è¡¨ï¼Œå¯ä»¥ç”¨ C++ çš„ vector æˆ–è€… Python çš„ list æ¨¡æ‹Ÿï¼Œå¥½å¤„æ˜¯å ç”¨ç›¸å¯¹é‚»æ¥çŸ©é˜µè¾ƒå°ï¼Œè€Œä¸”éå†æ–¹ä¾¿ï¼Œé€‚åˆä¸é‚£ä¹ˆç¨ å¯†çš„å›¾ã€‚\nFloyd åªèƒ½ç”¨é‚»æ¥çŸ©é˜µï¼Œå› ä¸º Floyd ç®—æ³•å°±æ˜¯åœ¨çŸ©é˜µä¸Šå®šä¹‰çš„ã€‚\nç®—æ³•å®ç° è¿™é‡Œæš‚æ—¶ä»¥ä¹¦ä¸Šçš„æè¿°ä¸ºå‡†ï¼Œæ–¹ä¾¿ç†è§£ã€‚æœ¬åœ°æœ‰ C++ ç¯å¢ƒçš„è¯å¯ä»¥è‡ªå·±è·‘ä¸€ä¸‹ç©ç©ã€‚å®é™…ä¸Š Floyd æ¯” Dijkstra å¥½å†™å¾ˆå¤šï¼Œå’Œç›´è§‰æ˜¯ç›¸åçš„ã€‚\nDijkstra dijkstra.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 10; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; ed[N]; // è¾¹è¡¨ï¼Œå­˜è¾¹ int d[N]; bool inP[N]; // æ ‡è®°æ˜¯å¦åœ¨ P é›†åˆä¸­ int main() { // ä» dat.txt ä¸­è¯»å–æ•°æ® freopen(\u0026#34;dat.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;out_dij.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) { int x, y, z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; // ä¸¤æ¡æœ‰å‘è¾¹æ¨¡æ‹Ÿæ— å‘è¾¹ ed[x].push_back({z, y}); ed[y].push_back({z, x}); } // åˆå§‹åŒ–è·ç¦»ä¸ºæ— ç©·å¤§ memset(d, 0x3f, sizeof(d)); d[1] = 0; for (int i = 1; i \u0026lt;= n; ++i) { // å¯»æ‰¾åŠ å…¥ P é›†åˆçš„ç‚¹ int x = 0; for (int j = 1; j \u0026lt;= n; ++j) { if (d[j] \u0026lt; d[x] \u0026amp;\u0026amp; !inP[j]) x = j; } inP[x] = true; // ç”¨è¿™ä¸ªç‚¹æ›´æ–°å…¶ä»–ç›¸è¿çš„ T é›†åˆä¸­çš„ç‚¹ for (auto [v, y] : ed[x]) { if (!inP[y]) d[y] = min(d[y], d[x] + v); } // è¾“å‡ºè¿‡ç¨‹ä¸­çš„ P é›†åˆï¼ŒT é›†åˆå’Œ d æ•°ç»„ cout \u0026lt;\u0026lt; \u0026#34;round \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;*****************************\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;P : \u0026#34;; for (int i = 1; i \u0026lt;= n; ++i) { if (inP[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T : \u0026#34;; for (int i = 1; i \u0026lt;= n; ++i) { if (!inP[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;d : \u0026#34;; for (int i = 1; i \u0026lt;= n; ++i) { if (d[i] == 0x3f3f3f3f) cout \u0026lt;\u0026lt; \u0026#34;inf\u0026#34; \u0026lt;\u0026lt; \u0026#39; \u0026#39;; else cout \u0026lt;\u0026lt; d[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;*****************************\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } Floyd floyd.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; const int N = 10; int D[N][N][N]; int main() { // ä» dat.txt ä¸­è¯»å–æ•°æ® freopen(\u0026#34;dat.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;out_floyd.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); // è¯»å– \u0026amp; é¢„å¤„ç†æ•°æ® int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; // å…¨éƒ¨åˆå§‹åŒ–æˆæ— ç©·å¤§ memset(D, 0x3f, sizeof(D)); // é‚»æ¥çŸ©é˜µä¸»å¯¹è§’çº¿åˆå§‹åŒ–æˆ 0 for (int i = 1; i \u0026lt;= n; ++i) D[0][i][i] = 0; for (int i = 1; i \u0026lt;= m; ++i) { int x, y, z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; D[0][x][y] = D[0][y][x] = z; } // è¾“å‡ºé‚»æ¥çŸ©é˜µ cout \u0026lt;\u0026lt; \u0026#34;A\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { if (D[0][i][j] == 0x3f3f3f3f) cout \u0026lt;\u0026lt; \u0026#34; inf\u0026#34;; else cout \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; D[0][i][j]; } cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; // FLoyd å¹¶è¾“å‡º D_k for (int k = 1; k \u0026lt;= n; ++k) { cout \u0026lt;\u0026lt; \u0026#34;D_\u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { D[k][i][j] = min(D[k - 1][i][j], D[k - 1][i][k] + D[k - 1][k][j]); if (D[k][i][j] == 0x3f3f3f3f) cout \u0026lt;\u0026lt; \u0026#34; inf\u0026#34;; else cout \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; D[k][i][j]; } cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } return 0; } è¡¥å……è¯´æ˜ Dijkstra å¯ä»¥ç”¨å †ä¼˜åŒ–ï¼Œä¼˜åŒ–åçš„ Dijkstra å¯ä»¥åº”å¯¹ç»“ç‚¹æ•°å’Œè¾¹æ•°éƒ½åœ¨åä¸‡çº§åˆ«çš„æ•°æ®ã€‚\nä¸Šé¢çš„ä»£ç æ²¡æœ‰å†™å †ä¼˜åŒ–ä¸€æ–¹é¢æ˜¯æ—¶é—´å¤æ‚åº¦çš„ç“¶é¢ˆåœ¨è¾“å‡ºè¿‡ç¨‹ä¸Šï¼Œå¦ä¸€æ–¹é¢æ˜¯ä¿è¯å¯¹åˆå­¦è€…çš„å¯è¯»æ€§ã€‚\nåœ¨åŒæ—¶å¸¦è¾¹æƒå’Œç‚¹æƒçš„æ— å‘å›¾ä¸Šè·‘å †ä¼˜åŒ–çš„ Dijkstra è¯¦è§æˆ‘çš„å¦ä¸€ç¯‡ articleï¼Œæ¬¢è¿ğŸ‰ğŸ‰ğŸ‰ã€‚\nFloyd ä¸€èˆ¬å®ç°çš„æ—¶å€™ä¸ä¼šå¼€ä¸‰ç»´æ•°ç»„ï¼ˆå¯èƒ½æ˜¯å› ä¸ºç©ºé—´å ç”¨å¤ªå¤§ï¼‰ï¼Œä¸éš¾å‘ç°å¦‚æœä¸è¾“å‡º D_k çš„è¯ç¬¬ä¸€ç»´æ˜¯å¤šä½™çš„ï¼Œç›´æ¥åœ¨åŸé‚»æ¥çŸ©é˜µä¸Šæ“ä½œä¸ä¼šå½±å“ç»“æœï¼Œ d[i][j] = min(d[i][j], d[i][k] + d[j][k]) å³å¯ã€‚\né™„å½•ï¼šä»£ç è¾“å‡º out_dij.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 round 1 ***************************** P : 1 T : 2 3 4 5 6 7 8 9 d : 0 6 3 2 inf inf inf inf inf ***************************** round 2 ***************************** P : 1 4 T : 2 3 5 6 7 8 9 d : 0 6 3 2 8 12 inf inf inf ***************************** round 3 ***************************** P : 1 3 4 T : 2 5 6 7 8 9 d : 0 5 3 2 8 12 inf inf inf ***************************** round 4 ***************************** P : 1 2 3 4 T : 5 6 7 8 9 d : 0 5 3 2 6 12 inf inf inf ***************************** round 5 ***************************** P : 1 2 3 4 5 T : 6 7 8 9 d : 0 5 3 2 6 12 8 9 12 ***************************** round 6 ***************************** P : 1 2 3 4 5 7 T : 6 8 9 d : 0 5 3 2 6 12 8 9 11 ***************************** round 7 ***************************** P : 1 2 3 4 5 7 8 T : 6 9 d : 0 5 3 2 6 11 8 9 11 ***************************** round 8 ***************************** P : 1 2 3 4 5 6 7 8 T : 9 d : 0 5 3 2 6 11 8 9 11 ***************************** round 9 ***************************** P : 1 2 3 4 5 6 7 8 9 T : d : 0 5 3 2 6 11 8 9 11 ***************************** out_floyd.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 A 0 6 3 2 inf inf inf inf inf 6 0 2 inf 1 inf inf inf inf 3 2 0 2 inf inf inf inf inf 2 inf 2 0 6 10 inf inf inf inf 1 inf 6 0 10 2 3 6 inf inf inf 10 10 0 inf 2 inf inf inf inf inf 2 inf 0 inf 3 inf inf inf inf 3 2 inf 0 4 inf inf inf inf 6 inf 3 4 0 D_1 0 6 3 2 inf inf inf inf inf 6 0 2 8 1 inf inf inf inf 3 2 0 2 inf inf inf inf inf 2 8 2 0 6 10 inf inf inf inf 1 inf 6 0 10 2 3 6 inf inf inf 10 10 0 inf 2 inf inf inf inf inf 2 inf 0 inf 3 inf inf inf inf 3 2 inf 0 4 inf inf inf inf 6 inf 3 4 0 D_2 0 6 3 2 7 inf inf inf inf 6 0 2 8 1 inf inf inf inf 3 2 0 2 3 inf inf inf inf 2 8 2 0 6 10 inf inf inf 7 1 3 6 0 10 2 3 6 inf inf inf 10 10 0 inf 2 inf inf inf inf inf 2 inf 0 inf 3 inf inf inf inf 3 2 inf 0 4 inf inf inf inf 6 inf 3 4 0 D_3 0 5 3 2 6 inf inf inf inf 5 0 2 4 1 inf inf inf inf 3 2 0 2 3 inf inf inf inf 2 4 2 0 5 10 inf inf inf 6 1 3 5 0 10 2 3 6 inf inf inf 10 10 0 inf 2 inf inf inf inf inf 2 inf 0 inf 3 inf inf inf inf 3 2 inf 0 4 inf inf inf inf 6 inf 3 4 0 D_4 0 5 3 2 6 12 inf inf inf 5 0 2 4 1 14 inf inf inf 3 2 0 2 3 12 inf inf inf 2 4 2 0 5 10 inf inf inf 6 1 3 5 0 10 2 3 6 12 14 12 10 10 0 inf 2 inf inf inf inf inf 2 inf 0 inf 3 inf inf inf inf 3 2 inf 0 4 inf inf inf inf 6 inf 3 4 0 D_5 0 5 3 2 6 12 8 9 12 5 0 2 4 1 11 3 4 7 3 2 0 2 3 12 5 6 9 2 4 2 0 5 10 7 8 11 6 1 3 5 0 10 2 3 6 12 11 12 10 10 0 12 2 16 8 3 5 7 2 12 0 5 3 9 4 6 8 3 2 5 0 4 12 7 9 11 6 16 3 4 0 D_6 0 5 3 2 6 12 8 9 12 5 0 2 4 1 11 3 4 7 3 2 0 2 3 12 5 6 9 2 4 2 0 5 10 7 8 11 6 1 3 5 0 10 2 3 6 12 11 12 10 10 0 12 2 16 8 3 5 7 2 12 0 5 3 9 4 6 8 3 2 5 0 4 12 7 9 11 6 16 3 4 0 D_7 0 5 3 2 6 12 8 9 11 5 0 2 4 1 11 3 4 6 3 2 0 2 3 12 5 6 8 2 4 2 0 5 10 7 8 10 6 1 3 5 0 10 2 3 5 12 11 12 10 10 0 12 2 15 8 3 5 7 2 12 0 5 3 9 4 6 8 3 2 5 0 4 11 6 8 10 5 15 3 4 0 D_8 0 5 3 2 6 11 8 9 11 5 0 2 4 1 6 3 4 6 3 2 0 2 3 8 5 6 8 2 4 2 0 5 10 7 8 10 6 1 3 5 0 5 2 3 5 11 6 8 10 5 0 7 2 6 8 3 5 7 2 7 0 5 3 9 4 6 8 3 2 5 0 4 11 6 8 10 5 6 3 4 0 D_9 0 5 3 2 6 11 8 9 11 5 0 2 4 1 6 3 4 6 3 2 0 2 3 8 5 6 8 2 4 2 0 5 10 7 8 10 6 1 3 5 0 5 2 3 5 11 6 8 10 5 0 7 2 6 8 3 5 7 2 7 0 5 3 9 4 6 8 3 2 5 0 4 11 6 8 10 5 6 3 4 0 ","date":"2025-03-18T14:43:12Z","permalink":"https://invalidnamee.github.io/p/dm01/","title":"ç¦»æ•£æ•°å­¦ï¼šæœ€çŸ­è·¯çš„ä»£ç å®ç°"},{"content":"å†™äº†ä¸€åŠï¼Œç¾¤é‡Œå‘å‡ºæ¥å®˜æ–¹é¢˜è§£äº†â€¦â€¦ä½†æ˜¯æˆ‘ç é£æ¯”ä»–çš„å¥½ï¼Œå¯è¯»æ€§å¼ºä¸€ç‚¹ï¼Œä½†æ˜¯ä¸ºäº†å¼ºè¿«ç—‡å’Œç•™ä½œè®°å½•ï¼Œæˆ‘å¿…é¡»å†™å®ŒğŸ˜‡ã€‚æ‰€ä»¥è¿™ç¯‡åšå®¢çš„æ€§è´¨å·²ç»ä»é¢˜è§£ transform æˆèµ›åçš„æ„Ÿæƒ³äº†ã€‚\nä¸ªäººæ„Ÿè§‰æœ‰ç‚¹åƒæ˜¯æ°´èµ›çš„æ„Ÿè§‰ï¼ŒL1 éå¸¸é¡ºåˆ©ï¼ŒL2 å’Œ L3 çš„æœ€åä¸¤é“å¼€å§‹è°ƒä¸å‡ºæ¥ï¼Œæœ€ç»ˆç»“æœæ˜¯ 190 åˆ†(æˆ‘çš„ L3-1 çš„ 30 åˆ†è¿˜è¢«é˜Ÿå‹åƒäº†ğŸ˜­ï¼‰ï¼ŒL1 æ‹¿æ»¡ï¼ŒL2 çš„ 3ï¼Œ4 WAï¼ŒL3 çš„ 2 TLEï¼Œ3 æ²¡çœ‹ã€‚\næˆ‘çš„ windows è¿˜æ²¡å›æ¥ï¼Œæ‰€ä»¥ç”¨çš„æœºæˆ¿çš„ç¼–è¯‘ä¸€ä¸‹å°±æ­»æœºçš„ç”µè„‘ï¼ˆä½†è¿™ä¸æ˜¯æˆ‘æ²¡å­˜ä»£ç çš„ç†ç”±ï¼‰ï¼Œåªèƒ½äº‹åé‡æ•²ä¸€éä»£ç äº†ï¼Œé¡ºä¾¿å›å¿†ä¸€ä¸‹å½“æ—¶çš„å¿ƒæƒ…ã€‚\nL1 åŸºç¡€çº§ L1 çš„ 8 é“é¢˜éƒ½éå¸¸é¡ºåˆ©ï¼Œæ²¡æœ‰è¢«å¡ï¼Œå¯æƒœé€Ÿåº¦è¿˜æ˜¯æ²¡æœ‰ @xx liu (qwertyuiop) å¿«ã€‚\nL1-1 é‡è§YFffffff 1 print(\u0026#39;Hello YFffffff\u0026#39;) L1-2 æ¡ƒä¹‹å¤­å¤­ï¼Œç¼ç¼å…¶å 1 2 3 n = int(input()) s = max(map(int, input().split())) print(s, \u0026#39;sad\u0026#39; if s \u0026amp; 1 else \u0026#39;love\u0026#39;) L1-3 ä½“æ¸©é¢„è­¦ç³»ç»Ÿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 n = int(input()) if n: t = [0 for i in range(4)] s = [\u0026#39;zhengchang\u0026#39;, \u0026#39;dire\u0026#39;, \u0026#39;gaore\u0026#39;, \u0026#39;yichangshuju\u0026#39;] for i in range(n): tmp = round(float(input()) * 10) if tmp in range(360, 373): t[0] += 1 elif tmp in range(373, 381): t[1] += 1 elif tmp in range(381, 411): t[2] += 1 else: t[3] += 1 print(\u0026#39;\\n\u0026#39;.join(f\u0026#39;{s[i]}:{t[i]}\u0026#39; for i in range(4) if t[i])) else: print(\u0026#39;wuxiaoshuju\u0026#39;) L1-4 ç ´ç¢çš„å¿ƒï¼Œæ— æ³•æŒ½å›çš„è·ç¦» 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; int a[110]; int main() { int n, res = 0x3f3f3f3f; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i]; } for (int p = 1; p \u0026lt;= 100; ++p) { int s = 0; for (int i = 1; i \u0026lt;= n; ++i) { s += (a[i] - p) * (a[i] - p); } res = min(res, s); } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } L1-5 å¿ƒç¢ï¼ŸæŠ½å¡æ—¶é—´ï¼ 1 2 3 4 5 6 7 8 9 10 a = list(map(int, input().split())) b = list(map(int, input().split())) for i in range(4): if a[i] \u0026lt; b[i]: print(\u0026#39;spider YFffffff\u0026#39;) break else: a[i + 1] += (a[i] - b[i]) // 5 else: print(a[4] if a[4] else \u0026#39;QAQ\u0026#39;) L1-6 å­—ç¬¦ä¸²ç³•æ‰‹ 1 2 3 4 5 6 7 8 l = int(input()) s = input() res = 1000 for i in range(l // 2, l): t = s[:i] + s[i::-1] res = min(res, i * 2 + 1 - l) if s == (s[:i] + s[i::-1])[:l] else res res = min(res, i * 2 - l) if s == (s[:i] + s[i - 1::-1])[:l] else res print(res) L1-7 è‹¥æ•¢æ¥æ°ªï¼Œå¿…å«ä½ å¤§è´¥è€Œå½’ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 l = [] n, x = map(int, input().split()) for i in range(n): a = input().split() l.append((-int(a[1]), -int(a[2]), -int(a[3]), int(a[4]), a[0])) cnt = 0 l.sort() for i in l: if x - i[3] \u0026gt;= 0: print(i[4]) x -= i[3] cnt += 1 else: break print(cnt) L1-8 å›åˆ°å¥¹çš„èº«è¾¹å¥½å— 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 n, m, k, p = map(int, input().split()) a = [(0, 0)] for i in range(m): a.append(tuple(map(int, input().split()))) a.append((n, n)) a.sort() for i in range(1, len(a)): if a[i][0] - a[i - 1][1] \u0026gt; k: if p and k: p, k = p - 1, k - 1 else: print(\u0026#39;buguanle\u0026#39;, a[i - 1][1]) break else: print(\u0026#39;YES\u0026#39;, k) è¿™ä¸ªæ—¶å€™ L1 é¡ºç€åšå®Œäº†ï¼Œè¿˜åœ¨æ²¾æ²¾è‡ªå–œã€‚\nL2 è¿›é˜¶çº§ å®è¯è¯´æˆ‘æ„Ÿè§‰ä¸æ˜¯å¾ˆå›°éš¾çš„ï¼Œä½†æ˜¯ wa äº†ä¸¤é“é¢˜ã€‚\nL2-1 æ¥è‡ªYFffffffçš„æŒ‘æˆ˜ è¿™ä¸ªç­–ç•¥å½“æ—¶æœ‰ä¸€å®šè’™çš„æˆåˆ†ï¼Œå®é™…ä¸Šä¹Ÿæ˜¯æ­£ç¡®çš„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int T; cin \u0026gt;\u0026gt; T; while (T--) { int n; string s, t = \u0026#34;\u0026#34;; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; if (n == 1 || s[1] \u0026gt;= s[0]) cout \u0026lt;\u0026lt; s[0] \u0026lt;\u0026lt; s[0] \u0026lt;\u0026lt; endl; else { for (char c : s) { if (t.empty() || c \u0026lt;= t.back()) t += c; else break; } cout \u0026lt;\u0026lt; t; for (int i = t.length() - 1; i \u0026gt;= 0; --i) cout \u0026lt;\u0026lt; t[i]; cout \u0026lt;\u0026lt; endl; } } return 0; } L2_2 ä¸è¦åˆéš¾æˆ‘ä»¬äº† æœ€çŸ­è·¯æ¿å­é¢˜ï¼Œåšåˆ°è¿™å„¿çš„æ—¶å€™ä¹Ÿè¿˜æ˜¯éå¸¸é¡ºåˆ©ï¼Œè¿™æ—¶å€™å¿ƒæ€å·²ç»è¢«æœºæˆ¿ç”µè„‘ç£¨çš„å·®ä¸å¤šäº†ï¼Œè¿™æ¬¡ä¸æ€ªç”µè„‘æ€ªæˆ‘æ²¡äº‹å…ˆæ‹·è¿‡æ¥ä¸€ä»½æ–°çš„ç¼–è¯‘å™¨ï¼Œæˆ‘åœ¨æœ¬åœ°è°ƒè¯•çš„æ—¶å€™å› ä¸º \u0026gt;\u0026gt;\u0026gt; ä¸èƒ½è¿ç»­ï¼Œauto éå† vector ä¸èƒ½ç”¨è¢«æŠ˜ç£¨çš„è¦æ­»ï¼Œè¿˜å¥½æ˜¯ä¸€éè¿‡äº†ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 200010; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; ed[N]; int w[N]; long long dis[N], cnt[N]; bool vis[N]; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n, m, s, t; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; w[i]; for (int i = 1; i \u0026lt;= m; ++i) { int x, y, z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; ed[x].push_back({z, y}); ed[y].push_back({z, x}); } priority_queue\u0026lt;pair\u0026lt;long long, int\u0026gt;, vector\u0026lt;pair\u0026lt;long long, int\u0026gt;\u0026gt;, greater\u0026lt;pair\u0026lt;long long, int\u0026gt;\u0026gt;\u0026gt; q; memset(dis, 0x3f, sizeof(dis)); cnt[s] = 1; dis[s] = 0; q.push({dis[s], s}); while (!q.empty()) { int x = q.top().second; q.pop(); if (vis[x]) continue; vis[x] = true; for (auto [v, y] : ed[x]) { if (dis[y] \u0026gt; dis[x] + w[y] + v) { dis[y] = dis[x] + w[y] + v; cnt[y] = cnt[x]; q.push({dis[y], y}); } else if (dis[y] == dis[x] + w[y] + v) { cnt[y] += cnt[x]; } } } cout \u0026lt;\u0026lt; dis[t] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; cnt[t] \u0026lt;\u0026lt; endl; return 0; } L2-3 èŠ±éèŠ±ï¼Œé›¾éé›¾ æˆ‘ wa æ‰çš„åšæ³•æ˜¯å¼€äº†ä¸ªé˜Ÿåˆ—å­˜å‚¨è¾¹ï¼Œæœ‰æ›´æ”¹çš„æ—¶å€™ä»æ›´æ”¹çš„ç‚¹å‡ºå‘ dfs æ›´æ–°æ‰€æœ‰èƒ½æ›´æ–°çš„ç‚¹ï¼Œä½†æ˜¯é—®é¢˜åœ¨äºæˆ‘ dfs çš„è·¯å¾„å¹¶ä¸ä¸€å®šæ˜¯æŒ‰ç…§è¾¹ä»å‰åˆ°åæ›´æ–°çš„ï¼›å…¶å®å½“æ—¶åˆæƒ³åˆ°ç”¨å¹¶æŸ¥é›†ï¼Œä½†æ˜¯æœ€ååˆæš‚æ—¶æ”¾å¼ƒäº†ã€‚\nè¿™é“é¢˜æœ€åçš„æœ‰æ•ˆå…³ç³»å›¾ä¸€å®šæ˜¯ä¸€ä¸ªæ£®æ—ï¼Œæ¯ä¸ªè¿é€šå­å›¾éƒ½æ˜¯æœ‰å‘æ ‘ï¼Œè¾¹ä»æ ¹æŒ‡å‘å¶å­ï¼Œå…¶ä¸­åªæœ‰æ ¹ç»“ç‚¹çš„ a å·²ç»ç»™å‡ºï¼Œä»æ ¹åˆ°å¶å­è·‘ä¸€é dfs å°±å¯ä»¥æ›´æ–°å‡ºæ‰€æœ‰ç‚¹çš„ aï¼›ç”¨å¹¶æŸ¥é›†å¯ä»¥ç»´æŠ¤ä¸€ä¸ªå­å›¾å†…æ˜¯å¦å·²ç»æœ‰ä¸€ä¸ª a å·²ç»ç»™å‡ºçš„æ ¹èŠ‚ç‚¹ï¼Œå¯¹äºä¸€ä¸ª U å…³ç³»ï¼Œä¸¤ä¸ªå·²ç»æœ‰æ ¹çš„å­å›¾è¿åœ¨ä¸€èµ·æˆ–è€…å­å›¾å†…éƒ¨è¿è¾¹å¯èƒ½ä¼šçŸ›ç›¾ï¼Œå³ä½¿ä¸çŸ›ç›¾è¿™æ¡è¾¹ä¹Ÿæ˜¯å¤šä½™çš„ï¼Œæ‰€ä»¥å…¨éƒ¨éƒ½åˆ¤å®šä¸ºæ— æ•ˆå³å¯ã€‚\nps: dfs ä¼šçˆ†æ ˆï¼Œåˆ«é—®æˆ‘æ€ä¹ˆçŸ¥é“çš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 40010; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; ed[N]; int fa[N], a[N]; bool f[N]; // ç»´æŠ¤æ˜¯å¦å·²ç»æœ‰æ ¹ int getfa(int x) { return x == fa[x] ? x : fa[x] = getfa(fa[x]); } int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) fa[i] = i; while (m--) { char c; cin \u0026gt;\u0026gt; c; if (c == \u0026#39;U\u0026#39;) { int x, y, w; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; w; int px = getfa(x), py = getfa(y); if (px == py || (f[px] \u0026amp; f[py])) continue; fa[py] = px; f[px] ^= f[py]; ed[x].push_back({w, y}); ed[y].push_back({w, x}); } else { int x, w; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; w; if (!f[getfa(x)]) { a[x] = w; f[getfa(x)] = true; } } } queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++i) { if (a[i]) q.push(i); } while (!q.empty()) { int x = q.front(); q.pop(); for (auto [v, y] : ed[x]) { if (a[y]) continue; a[y] = a[x] ^ v; q.push(y); } } for (int i = 1; i \u0026lt;= n; ++i) { if (!a[i]) { cout \u0026lt;\u0026lt; \u0026#34;sad\u0026#34; \u0026lt;\u0026lt; endl; return 0; } } for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; } L2-4 æ˜¯ç•™ä¸ä½ä½ çš„å†°å¯’é£å½± æˆ‘ç°åœ¨è¿˜è®¤ä¸ºæ»‘åŠ¨çª—å£æ˜¯å¯è¡Œçš„ï¼Œè€ƒåœºä¸Šå†™çš„å¯èƒ½é€»è¾‘è¿˜æ˜¯æœ‰ç‚¹å°é—®é¢˜ï¼Œæœ¬è´¨ä¸Šæˆ‘å½“æ—¶å†™çš„å•è°ƒé˜Ÿåˆ—åªæ˜¯æ²¡æœ‰å…·è±¡åŒ–çš„æŠŠç‚¹åˆå¹¶äº†ã€‚ç…§ç€é¢˜è§£çš„æ€è·¯å†™å®Œä»£ç ä¹‹åå‘ç°æˆ‘å½“æ—¶çš„é—®é¢˜æ˜¯ç»´æŠ¤çš„èŒƒå›´å°äº†ï¼Œä¸€ä¸ªæ»‘åŠ¨çª—å£èƒ½ 0 ä»£ä»·åˆ°è¾¾çš„æœ€å·¦ç«¯å’Œæœ€å³ç«¯ç”±å·¦ä¾§ç¬¬äºŒä¸ªå’Œå³ä¾§ç¬¬äºŒä¸ªç‚¹å†³å®šï¼Œè€Œä¸æ˜¯çª—å£çš„å·¦å³ç«¯ç‚¹ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int a[N]; int l[N], r[N], t; int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n, k, m; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;k, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } t = 0; a[0] = -0x3f3f3f3f, a[n + 1] = 0x3f3f3f3f; for (int i = 1; i \u0026lt;= n; ++i) { if (i == 1 \u0026amp;\u0026amp; a[i + 1] - a[i] \u0026gt; k || i == n \u0026amp;\u0026amp; a[i] - a[i - 1] \u0026gt; k) { t++; l[t] = r[t] = a[i]; } else if (a[i] - a[i - 1] \u0026lt;= k) { l[t] = min(l[t], a[i] - k); r[t] = max(r[t], a[i - 1] + k); } else if (a[i + 1] - a[i] \u0026lt;= k) { t++; l[t] = r[t] = a[i]; } } for (int i = 2; i \u0026lt;= t; ++i) { m -= (l[i] - r[i - 1] + k - 1) / k; } if (m \u0026gt;= 0) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); } return 0; } L3 ç™»é¡¶çº§ L3-1 é“¶ç™½ä¹‹æ£® æƒ³åˆ°æ•²äº†äºŒåå¤šåˆ†é’ŸåŸºç¯æ ‘ dp ä»£ç ï¼Œæˆ‘è‡ªå·±éƒ½æƒ³ç¬‘ğŸ˜‡ğŸ˜‡ğŸ˜‡ã€‚è¿™æ˜¯ä¸€å¼ åç»§å›¾ï¼Œæ¯ä¸ªç‚¹åˆåº¦ä¸º1ï¼Œæ‰€ä»¥æ„æˆåŸºç¯æ ‘ï¼Œç„¶åæˆ‘å°±æƒ³åäº†ã€‚å…¶å®ä¸ç”¨åŒºåˆ†ç¯å†…ç¯å¤–ç›´æ¥ä¸€èµ·å€å¢é¢„å¤„ç†ä¸€ä¸‹ç„¶åæŠŠ k äºŒè¿›åˆ¶åˆ†è§£ç®—å°±è¡Œã€‚è¿˜æ˜¯å¿˜ä¸äº†ä¹‹å‰ä¸€é“æ ‘ä¸Šå€å¢ + ç¯å½¢dp çš„åŸºç¯æ ‘é¢˜ğŸ˜®â€ğŸ’¨ï¼Œæˆ‘å†™ç€å†™ç€å‘ç°ç¯é‡Œé¢è¿˜å¾—å€å¢ï¼Œç„¶åç”¨äº†åŒä¸€ä¸ªå€å¢æ•°ç»„ï¼Œåˆå†™äº†ä¸€ä¼šå„¿æ‰å‘ç°é—®é¢˜çš„ä¸¥é‡æ€§ï¼Œç›´æ¥æŠŠä»£ç å…¨åˆ äº†é‡å†™äº†ä¸€éã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int f[N][50]; long long g[N][50]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;f[i][0]); g[i][0] = f[i][0]; } for (int j = 1; j \u0026lt; 50; ++j) { for (int i = 1; i \u0026lt;= n; ++i) { f[i][j] = f[f[i][j - 1]][j - 1]; g[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1]; } } while (m--) { int x; long long k, res = 0; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;x, \u0026amp;k); for (int i = 0; i \u0026lt; 50; ++i) { if (k \u0026gt;\u0026gt; i \u0026amp; 1) { res += g[x][i]; x = f[x][i]; } } printf(\u0026#34;%lld\\n\u0026#34;, res); } return 0; } L3-2 æ‘¸çƒæ¸¸æˆ å½“æ—¶çŸ©é˜µå¿«é€Ÿå¹‚ t äº†ï¼ŒæŒ‰è¯´ä¸è¯¥ t çš„ï¼›ä½†æ˜¯è¿™ä¸æ˜¯é‡ç‚¹ï¼Œé‡ç‚¹æ˜¯ï¼šæˆ‘è¦å‘æˆ‘é«˜ä¸­æ•°å­¦è€å¸ˆé“æ­‰ğŸ˜­ï¼Œè¿™é“é¢˜æ˜¯ä¸€é˜¶çº¿æ€§é€’æ¨æ±‚é€šé¡¹ï¼Œæˆ‘æŠŠä»–å½“äºŒé˜¶çš„äº†ï¼Œç”šè‡³è¿˜è¯•å›¾æ‰¾ç‰¹å¾æ–¹ç¨‹ã€‚2025/03/07 æ™šä¸Š 22:00 æˆ‘çªç„¶æ„è¯†åˆ°äº†é—®é¢˜çš„ä¸¥é‡æ€§ï¼Œäºæ˜¯ä¸€ä¸ªä¸åŠ¨ç‚¹æ±‚å‡ºæ¥ç­‰æ¯”æ•°åˆ—çš„é€’æ¨å¼ç„¶åç§’äº†ã€‚ä»–çš„é¢˜è§£å¤ªéº»çƒ¦äº†ï¼Œå…¶å®è¿™å°±æ˜¯ä¸€é“å¹³å¹³æ— å¥‡çš„é«˜ä¸­æ¦‚ç‡é¢˜ï¼Œæœç„¶ä¸Šå¤§å­¦ğŸ§ ä¼šé€€åŒ–ã€‚\nè®¡çƒçš„æ€»ä¸ªæ•°ä¸º nï¼Œi æ¬¡æ“ä½œåçš„æœŸæœ›ä¸º \\(E_i\\)ï¼Œæ ¹æ®æœŸæœ›é€’æ¨ï¼Œæœ‰\n\\[E_i = \\frac{E_{i - 1}}{n}E_{i - 1} + \\frac{n - E_{i - 1}}{n}(E_{i - 1} + 1)\\]\nåŒ–ç®€å¾—\n\\[E_i = \\frac{n - 1}{n}E_{i - 1} + 1\\]\nè®¡ç®—ä¸åŠ¨ç‚¹ï¼Œè§£æ–¹ç¨‹ \\(x = \\frac{n - 1}{n}x + 1\\)å¾—ï¼Œ\\(x= n\\). æ‰€ä»¥æœ‰\n\\[E_i - n = \\frac{n - 1}{n}(E_{i - 1} - n)\\]\nåé¢å°±ä¸ç”¨æˆ‘æ•™äº†ï¼Œé¦–é¡¹æ˜¯ n - aï¼Œå…¬æ¯”æ˜¯ \\(\\frac{n - 1}{n}\\)ç­‰æ¯”æ•°åˆ—é€šå‘å…¬å¼ç›´æ¥æ±‚ \\(E_k\\)å³å¯ã€‚\nå¯¹ä¸èµ· 90 è€å¸ˆï¼Œè¿‡äº†åŠå¹´å°±å¿˜å¹²å‡€äº†ğŸ˜­ğŸ˜­ğŸ˜­.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; using namespace std; int MOD = 1000000007; long long power(long long n, long long p) { long long res = 1, base = n; while (p) { if (p \u0026amp; 1) res = res * base % MOD; base = base * base % MOD; p \u0026gt;\u0026gt;= 1; } return res; } int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int T; long long a, b, c, k; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; k; b += a; cout \u0026lt;\u0026lt; (((a - b + MOD) % MOD * power((b - 1) * power(b, MOD - 2) % MOD, k)) % MOD + b + MOD) % MOD \u0026lt;\u0026lt; endl; } return 0; } L3-3 ç”µè· è¿™é“è‡ªå·±åšæ˜¯çœŸåšä¸å‡ºæ¥ï¼Œæ­£ç¡®çš„ç»“è®ºæ˜¯ä¸€ä¸ª D åˆæ³•å½“ä¸”ä»…å½“æŒ‰ x æ’åºæ£€æŸ¥å’ŒæŒ‰ y æ’åºæ£€æŸ¥è‡³å°‘æœ‰ä¸€ä¸ªå¯ä»¥é€šè¿‡ï¼Œå…¶ä½™æƒ…å†µé€šè¿‡é€‚å½“äº¤æ¢å¯ä»¥è½¬åŒ–æˆæŒ‰ x å’Œ y æ£€æŸ¥çš„ä¸€ç§ã€‚å¦‚æœæˆ‘è‡ªå·±æƒ³åªèƒ½æƒ³åˆ°æŒ‰å…¶ä¸­ä¸€ä¸ªæ’åºï¼Œè°ƒä»£ç çš„æ—¶å€™ä¹Ÿæ˜¯è°ƒçš„éå¸¸å¤´ç–¼ã€‚\nä»£ç è¿˜å¯ä»¥å‹ä¸€å‹ï¼Œæ’åºå’Œå‰ç¼€åç¼€ max å’Œ min å¯ä»¥å†™æˆä¸€ä¸ªå‡½æ•°ã€‚ä½†æ˜¯æˆ‘å·²ç»ä¸æƒ³çœ‹è¿™ä¸ªğŸ’©äº†\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 100010; pair\u0026lt;int, int\u0026gt; a[N]; int pre_mn[N], pre_mx[N], pos_mn[N], pos_mx[N]; int n; long long pow2(int t) { return (long long)t * t; } long long calc(int l, int r) { if (l == 1 \u0026amp;\u0026amp; r == n) return 0; int mn = 0x3f3f3f3f, mx = -0x3f3f3f3f; if (l != 1) mn = min(mn, pre_mn[l - 1]), mx = max(mx, pre_mx[l - 1]); if (r != n) mn = min(mn, pos_mn[r + 1]), mx = max(mx, pos_mx[r + 1]); return max(pow2(mx - mn), max(pow2(mx), pow2(mn)) + max(pow2(a[l].first), pow2(a[r].first))); } bool check(long long mid) { for (int i = 1, j = 1; i \u0026lt;= n; ++i) { while (j \u0026lt;= n \u0026amp;\u0026amp; (long long)(a[j].first - a[i].first) * (a[j].first - a[i].first) \u0026lt;= mid) { if (calc(i, j) \u0026lt;= mid) return true; j++; } if (calc(i, j - 1) \u0026lt;= mid) return true; } return false; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[i].first, \u0026amp;a[i].second); } sort(a + 1, a + n + 1); pre_mn[0] = 0x3f3f3f3f; pre_mx[0] = -0x3f3f3f3f; pos_mn[n + 1] = 0x3f3f3f3f; pos_mx[n + 1] = -0x3f3f3f3f; for (int i = 1; i \u0026lt;= n; ++i) { pre_mx[i] = max(pre_mx[i - 1], a[i].second); pre_mn[i] = min(pre_mn[i - 1], a[i].second); } for (int i = n; i; --i) { pos_mx[i] = max(pos_mx[i + 1], a[i].second); pos_mn[i] = min(pos_mn[i + 1], a[i].second); } long long l = 0, r = 80000000000000000; while (l \u0026lt; r) { long long mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } long long res = l; for (int i = 1; i \u0026lt;= n; ++i) swap(a[i].first, a[i].second); sort(a + 1, a + n + 1); pre_mn[0] = 0x3f3f3f3f; pre_mx[0] = -0x3f3f3f3f; pos_mn[n + 1] = 0x3f3f3f3f; pos_mx[n + 1] = -0x3f3f3f3f; for (int i = 1; i \u0026lt;= n; ++i) { pre_mx[i] = max(pre_mx[i - 1], a[i].second); pre_mn[i] = min(pre_mn[i - 1], a[i].second); } for (int i = n; i; --i) { pos_mx[i] = max(pos_mx[i + 1], a[i].second); pos_mn[i] = min(pos_mn[i + 1], a[i].second); } l = 0, r = 80000000000000000; while (l \u0026lt; r) { long long mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } res = min(res, l); printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } ç»ˆäºè¡¥å®Œäº†ï¼Œå¥–åŠ±è‡ªå·±æ­‡ä¸€æ™šä¸ŠğŸ˜´ğŸ˜´ğŸ˜´\n","date":"2025-03-18T13:34:31Z","permalink":"https://invalidnamee.github.io/p/tianti2025cd/","title":"ç¬¬å››å±Šæˆéƒ½ä¿¡æ¯å·¥ç¨‹å¤§å­¦å¤©æ¢¯èµ›"},{"content":"è¿™è®­ç»ƒèµ›æ€ä¹ˆè¶Šæ¥è¶Šæ°´äº†ï¼ŒC è€ƒåœºä¸Šæ²¡åšå‡ºæ¥ï¼ŒD è°ƒäº†å¾ˆä¹…ï¼Œä½†æ˜¯å®é™…ä¸Šéƒ½ä¸æ€ä¹ˆç®—éš¾ï¼Œå‰©ä¸‹çš„å››é“å°±æ˜¯çº¯ç²¹çš„å¤§æ°´é¢˜äº†ã€‚\nA. æŠ½ç‰Œ æˆ‘ä»£ç å†™çš„æ¯”è¾ƒéº»çƒ¦ï¼Œå®é™…ä¸Šæ²¡å¿…è¦ã€‚\nç­”æ¡ˆä¸º 0ï¼šå·²ç»æ»¡è¶³å…¶ä¸­ä¸€ä¸ªæ¡ä»¶äº†ï¼›\nç­”æ¡ˆä¸º 1ï¼šèŠ±è‰²ç›¸åŒçš„ç‰Œä¸­ï¼Œæœ‰ä¸¤ä¸ªç›¸åŒæˆ–è€…å·® 1 æˆ– 2ï¼›\nç­”æ¡ˆä¸º 2ï¼šä»¥ä¸Šéƒ½ä¸æ»¡è¶³ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; t[128]; int main() { for (int i = 0; i \u0026lt; 3; ++i) { char c; int tmp; cin \u0026gt;\u0026gt; tmp \u0026gt;\u0026gt; c; t[c].push_back(tmp); } int res = 3; for (int i = 0; i \u0026lt; 128; ++i) { if (!t[i].empty()) { sort(t[i].begin(), t[i].end()); if (t[i].size() == 1) res = min(res, 2); else if (t[i].size() == 2) { if (t[i][1] - t[i][0] == 2 || t[i][1] - t[i][0] == 1) res = min(res, 1); else res = min(res, 2); if (t[i][0] == t[i][1]) res = min(res, 1); } else if (t[i].size() == 3) { if (t[i][0] + 1 == t[i][1] \u0026amp;\u0026amp; t[i][1] + 1 == t[i][2]) { res = 0; break; } else if (t[i][0] == t[i][1] \u0026amp;\u0026amp; t[i][1] == t[i][2]) { res = 0; break; } else if (t[i][0] == t[i][1] || t[i][1] == t[i][2]) { res = min(res, 1); } else if (t[i][1] - t[i][0] == 2 || t[i][1] - t[i][0] == 1 || t[i][2] - t[i][1] == 2 || t[i][2] - t[i][1] == 1) { res = min(res, 1); } } } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } B. åŒºé—´æ±‚å’Œ ç›´æ¥å‰ç¼€å’Œ + map/äºŒåˆ† å°±è¡Œã€‚\npsï¼šåˆ«å­¦æˆ‘æŠŠ int çˆ†äº†ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; #define int long long using namespace std; map\u0026lt;long long, int\u0026gt; mp; signed main() { long long res = 0; int n, m; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); vector\u0026lt;long long\u0026gt; s(n + 1, 0); mp[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;s[i]); s[i] += s[i - 1]; res += mp[s[i] - m]; mp[s[i]] ++; } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } C. é²çš„è¦å¡ å¯¹äºä¸€ç»„è¦å¡ï¼Œä»–ä»¬çš„çš„æŒ‡æŒ¥ä¸­å¿ƒçš„æ¨ª(çºµ)åæ ‡å¿…ç„¶æ˜¯ä»–ä»¬æ¨ª(çºµ)åæ ‡çš„ä¸­ä½æ•°ï¼Œä¸ªæ•°ä¸ºå¶æ•°çš„æƒ…å†µä»»å–ä¸­é—´çš„ä¸¤ä¸ªç‚¹éƒ½æ˜¯å¯ä»¥çš„ï¼Œæ‰€ä»¥ä¸­å¿ƒçš„åæ ‡ä¸€å®šåœ¨å·²æœ‰çš„æ•°å€¼ä¸­é€‰ï¼›æš´åŠ›æšä¸¾å·²ç»ç»™å‡ºçš„ç‚¹æ¨ªçºµåæ ‡è‡ªç”±ç»„åˆï¼Œå¯¹æ¯ä¸ªç‚¹åˆ†åˆ«æ±‚è·ç¦»ï¼Œæ’åºå‰ç¼€å’Œæ›´æ–°ç­”æ¡ˆå³å¯ã€‚\npsï¼šåˆ«å­¦æˆ‘æŠŠ int çˆ†äº†ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #define int long long using namespace std; int p[110][2]; int a[110], b[110]; signed main() { int n, k; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;p[i][0], \u0026amp;p[i][1]); } memset(a, 0x3f, sizeof(a)); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { for (int k = 1; k \u0026lt;= n; ++k) { b[k] = abs(p[i][0] - p[k][0]) + abs(p[j][1] - p[k][1]); } sort(b + 1, b + n + 1); for (int k = 1; k \u0026lt;= n; ++k) { b[k] += b[k - 1]; a[k] = min(a[k], b[k]); } } } for (int i = 1; i \u0026lt;= k; ++i) printf(\u0026#34;%lld\\n\u0026#34;, a[i]); return 0; } D. èƒ½æºæ™¶ä½“ è¿™æ˜¯ä¸€é“ dp é¢˜ã€‚\n**å…³é”®æ€§è´¨ï¼š**é¢˜ç›®ä¸­çš„æ–¹æ¡ˆæ•°ç­‰ä»·äºç”¨æ€»é•¿ä¸º n çš„é•¿åº¦ä¸º \\[1, k\\] çš„å•è°ƒä¸å‡çš„çº¿æ®µå³ç«¯ç‚¹å¯¹é½è¦†ç›– \\[1, k\\] è¿™ä¸ªåŒºé—´çš„æ–¹æ¡ˆæ•°ã€‚è¿™ä¹ˆåšè§£é™¤äº† k ä¸ªä½ç½®çš„é™åˆ¶ï¼Œå¹¶ä¸”ä»ç„¶ä¿æŒäº† k å…ƒç»„çš„æœ‰åºæ€§ï¼ˆè¿™é‡Œçš„çº¿æ®µé•¿åŒ…æ‹¬ç«¯ç‚¹ï¼Œé•¿åº¦ä¸º lï¼Œè¡¨ç¤ºæœ€å l ä¸ªæ•°éƒ½ +1ï¼‰\nå®šä¹‰çŠ¶æ€ï¼š\\(f_{i, j}\\)ï¼Œè¡¨ç¤ºç›®å‰ç”¨äº† i ä¸ªæ¨¡å—ï¼Œæœ€åä¸€æ¡çº¿æ®µé•¿åº¦ä¸º j çš„æ–¹æ¡ˆæ•°ï¼Œç­”æ¡ˆæ˜¾ç„¶æ˜¯ \\(f_{n, k}\\).\nçŠ¶æ€è½¬ç§»ï¼š\\(f_{i, j} = \\sum_{l = 1}^{j}{f_{i - l, l}}\\)ï¼Œæ±‚å’Œå¯ä»¥åœ¨ dp çš„è¿‡ç¨‹ä¸­ç”¨å‰ç¼€å’Œä¼˜åŒ–ï¼Œæ—¶é—´å¤æ‚åº¦é™åˆ° \\(O(nk)\\).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; const int MOD = 998244353; int f[5010][5010]; int n, k; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 1; i \u0026lt;= k; ++i) f[0][i] = 1; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= k; ++j) { if (j \u0026lt;= i) f[i][j] = (f[i][j - 1] + f[i - j][j]) % MOD; else f[i][j] = f[i][j - 1]; } } cout \u0026lt;\u0026lt; ((f[n][k] - f[n][k - 1]) % MOD + MOD) % MOD \u0026lt;\u0026lt; endl; return 0; } E. èµ„æ–™é¡µæ•° é‰´å®šä¸ºæ°´é¢˜ï¼ŒæŠŠè„šæ³¨çš„è¡Œæ•°æ†ç»‘åˆ°è¡Œé‡Œé¢æš´åŠ›æ¨¡æ‹Ÿå³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; const int N = 200010; vector\u0026lt;int\u0026gt; ed[N]; int f[N]; int n, m, k; bool dp(int x, int fa) { f[x] = 1; int t = 0; for (int y : ed[x]) { if (y == fa) continue; if (!dp(y, x)) return false; if (f[y]) t++; f[x] += f[y]; } if (t \u0026gt; 2) return false; else if (t == 2) { if (f[x] != k) return false; else f[x] = 0; } else { f[x] %= k; } return true; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 1; i \u0026lt; n * k; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); ed[x].push_back(y); ed[y].push_back(x); } if (dp(1, 1)) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } F. å†ç ´éš¾å…³ ä»£ç é‡ç•¥å¤§çš„æ°´é¢˜ï¼ŒæŠŠçŠ¶æ€å‹æˆ 16 ä½äºŒè¿›åˆ¶æ•°ï¼ŒçŠ¶æ€ä¸ªæ•°ä¸€å…±åªæœ‰ \\(2^{16}\\)ä¸ªï¼Œç›´æ¥ bfs å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; queue\u0026lt;int\u0026gt; q; int s = 0, t = 0; int f[100000]; int g[4][4]; void to_g(int mask) { for (int i = 0; i \u0026lt; 16; ++i) { g[i / 4][i % 4] = mask \u0026gt;\u0026gt; i \u0026amp; 1; } } int to_s() { int res = 0; for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { res |= g[i][j] \u0026lt;\u0026lt; (i * 4 + j); } } return res; } int main() { memset(f, -1, sizeof(f)); int s, t; for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { scanf(\u0026#34;%1d\u0026#34;, \u0026amp;g[i][j]); } } s = to_s(); for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { scanf(\u0026#34;%1d\u0026#34;, \u0026amp;g[i][j]); } } t = to_s(); f[s] = 0; q.push(s); while (!q.empty()) { int x = q.front(); q.pop(); if (x == t) { printf(\u0026#34;%d\\n\u0026#34;, f[x]); return 0; } to_g(x); for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { if (i \u0026lt; 3 \u0026amp;\u0026amp; g[i][j] != g[i + 1][j]) { swap(g[i][j], g[i + 1][j]); int y = to_s(); if (!(~f[y])) { f[y] = f[x] + 1; q.push(y); } swap(g[i][j], g[i + 1][j]); } if (j \u0026lt; 3 \u0026amp;\u0026amp; g[i][j] != g[i][j + 1]) { swap(g[i][j], g[i][j + 1]); int y = to_s(); if (!(~f[y])) { f[y] = f[x] + 1; q.push(y); } swap(g[i][j], g[i][j + 1]); } } } } return 0; } ","date":"2025-03-15T13:52:11Z","permalink":"https://invalidnamee.github.io/p/2025st7/","title":"2025æ˜¥è®­ç¬¬ä¸ƒåœº"},{"content":"æ„Ÿè§‰è¿™æ¬¡åšçš„è¿˜è¡Œï¼Œä¸»è¦è¿˜æ˜¯ç®€å•é¢˜å¤šäº†ä¸€ç‚¹ã€‚æ•°å­¦é¢˜èµ›åè¢« GPT ç§’äº†ï¼Œè€Œæˆ‘è¿½ç€ GPT é—®äº†åŠå¤©â€¦â€¦\nA. é­”æ³•çŸ³ ç­¾åˆ°é¢˜ï¼Œä½†æ˜¯æœ‰ç‚¹ç»•ï¼ˆæˆ‘å°±è¢«å‘äº†ï¼‰ã€‚æœ‰è§£çš„æ¡ä»¶æ˜¯ä¸‰ä¸ªæ•°éƒ½ç›¸ç­‰æˆ–è€…ä¸¤ä¸ªæ•°ç›¸ç­‰ï¼Œå¦ä¸€ä¸ªæ¯”è¿™ä¸¤ä¸ªå°ï¼›å‰è€…ç›´æ¥è¾“å‡ºä¸‰ä¸ªç›¸ç­‰çš„ï¼Œåè€…è¾“å‡ºä¸€ä¸ªè¾ƒå¤§çš„å’Œä¸¤ä¸ªè¾ƒå°çš„å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { long long a[3]; scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;a[0], \u0026amp;a[1], \u0026amp;a[2]); sort(a, a + 3); if (a[0] != a[1] \u0026amp;\u0026amp; a[1] != a[2]) printf(\u0026#34;NO\\n\u0026#34;); else if (a[1] \u0026lt; a[2]) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n%lld %lld %lld\\n\u0026#34;, a[1], a[0], a[0]); return 0; } B. å›æ–‡ç«‹æ–¹æ•° ç›´æ¥æšä¸¾ \\(i \\in [1, \\lfloor \\sqrt[3]{N} \\rfloor]\\)ï¼ŒéªŒè¯ iÂ³ æ˜¯å¦å›æ–‡ï¼Œæ‰¾æœ€å¤§çš„å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; bool check(long long t) { string s = to_string(t); for (int i = 0; i \u0026lt; s.length(); ++i) { if (s[i] != s[s.length() - i - 1]) return false; } return true; } int main() { long long n, t = 0; cin \u0026gt;\u0026gt; n; for (int i = 1; (long long)i * i * i \u0026lt;= n; ++i) { if (check((long long)i * i * i)) { t = (long long)i * i * i; } } printf(\u0026#34;%lld\\n\u0026#34;, t); return 0; } C. gcd è¿˜æ²¡é—®æ˜ç™½ GPTï¼Œä½†æ˜¯å¼ºè¿«ç—‡è¶‹åŠ¿æˆ‘å¿…é¡»åœ¨ç¬¬ä¸ƒåœºå‰å‘ç¬¬å…­åœºï¼Œæ‰€ä»¥å…ˆğŸ¦ä¸€ä¸‹ã€‚\nè¿™æ˜¯äº‹åä¸çŸ¥é“ä»€ä¹ˆåŸç†è¿‡äº†çš„ä»£ç ï¼Œä¼¼ä¹è¦æ±‚ a æ˜¯ b - a çš„å€æ•°è€Œä¸”å’Œ b - a äºŒè¿›åˆ¶ä½ä¸é‡å ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int n; cin \u0026gt;\u0026gt; n; long long ans = 0; for (int d = 1; d \u0026lt;= n; d++){ for (int a = d; a + d \u0026lt;= n; a += d) { if ((a ^ (a + d)) == d) { ans++; } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } E. æ‘˜Galo ç±»ä¼¼æ ‘å½¢èƒŒåŒ…é—®é¢˜ï¼Œæ ‘å½¢dpå›æº¯çš„æ—¶å€™ç”¨å­©å­çš„ f æ•°ç»„æ›´æ–°çˆ¶äº²çš„ f æ•°ç»„ï¼Œæœ€åçˆ¶äº²çš„ \\(f_1 = min{f_1, w}\\)ï¼Œæ³¨æ„ä¼˜åŒ–å¸¸æ•°ï¼Œå®¹æ˜“è¢«å¡æˆ TLEã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 100010; int head[N], ne[N], ver[N], tot; int w[N]; vector\u0026lt;long long\u0026gt; f[N]; int cnt[N]; int n, k; void add(int x, int y) { ver[++tot] = y; ne[tot] = head[x]; head[x] = tot; } void dp(int x) { cnt[x] = 1; long long s = 0; for (int i = head[x]; i; i = ne[i]) { int y = ver[i]; dp(y); cnt[x] += cnt[y]; for (int j = min(k + 1, cnt[x]); j; --j) { for (int l = min(cnt[y], j); l \u0026gt;= 0; --l) { f[x][j] = max(f[x][j], f[x][j - l] + f[y][l]); } } } f[x][1] = max(f[x][1], (long long)w[x]); } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 2; i \u0026lt;= n; ++i) { int f; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;f, \u0026amp;w[i]); add(f, i); } for (int i = 1; i \u0026lt;= n; ++i) { f[i] = vector\u0026lt;long long\u0026gt;(k + 2, 0); } dp(1); long long res = 0; for (int i = 0; i \u0026lt;= k + 1; ++i) { res = max(res, f[1][i]); } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } F. é˜Ÿåˆ—å®‰æ’ æ’åºï¼Œä»å°åˆ°å¤§æ’å°±è¡Œã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; long long a[100010]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); } sort(a + 1, a + n + 1); long long s = 0; for (int i = 1; i \u0026lt; n; ++i) { a[i] += a[i - 1]; s += a[i]; } printf(\u0026#34;%lld\\n\u0026#34;, s); return 0; } ","date":"2025-03-15T13:51:32Z","permalink":"https://invalidnamee.github.io/p/2025st6/","title":"2025æ˜¥è®­ç¬¬å…­åœº"},{"content":"åˆæ˜¯ç†Ÿæ‚‰çš„åšå¼ˆé—®é¢˜ï¼Œåˆæ˜¯ç†Ÿæ‚‰çš„åšä¸å‡ºæ¥ï¼Œä¸è¿‡å‰©ä¸‹ä¸‰é“èƒ½åšå‡ºæ¥çš„éƒ½æŒºæœ‰æ„æ€çš„ï¼Œç›¸å¯¹æ¯”è¾ƒæ»¡è¶³ã€‚\nA. æ¸¸æˆ ç­”æ¡ˆ= min(max(ä»å°åˆ°å¤§äº¤æ›¿é€‰ï¼Œä»å¤§åˆ°å°äº¤æ›¿é€‰)ï¼Œmax(Aä»æœ€å¤§çš„è¿ç»­é€‰ï¼ŒAä»æœ€å°çš„è¿ç»­é€‰)).\næç¤ºï¼šA å¸Œæœ›ç­”æ¡ˆå°½å¯èƒ½å¤§ï¼Œæ‰€ä»¥ç”± A å†³ç­–å†³å®šçš„åº”å– maxï¼ŒB å¸Œæœ›ç­”æ¡ˆå°½å¯èƒ½å°ï¼Œæ‰€ä»¥ç”± B å†³ç­–å†³å®šçš„åº”è¯¥å– min.\nå»ºè®®ï¼šç»™ @xx liu (qwertyuiop) ä½¬ç£•ä¸€ä¸ª\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int a[100010]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } sort(a + 1, a + n + 1); long long A = 0, B = 0; long long res; for (int i = n; i \u0026gt; 0; i -= 2) A += a[i]; for (int i = n - 1; i \u0026gt; 0; i -= 2) B += a[i]; res = abs(A) - abs(B); A = 0, B = 0; for (int i = 1; i \u0026lt;= n; i += 2) A += a[i]; for (int i = 2; i \u0026lt;= n; i += 2) B += a[i]; res = max(res, abs(A) - abs(B)); A = 0, B = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (i \u0026lt;= (n + 1) / 2) A += a[i]; else B += a[i]; } long long t1 = abs(A) - abs(B); A = 0, B = 0; reverse(a + 1, a + n + 1); for (int i = 1; i \u0026lt;= n; ++i) { if (i \u0026lt;= (n + 1) / 2) A += a[i]; else B += a[i]; } res = min(max(t1, abs(A) - abs(B)), res); printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } B. éŸ³ç¬¦ å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–çš„ dp æ•ˆç‡æœ€é«˜ï¼Œ æˆ–è€…çº¿æ®µæ ‘ä¹Ÿè¡Œï¼Œä¸¤ç‰ˆä»£ç éƒ½è´´ä¸€ä¸‹ã€‚\n\\[res = \\max_{i = 1}^{n} \\max_{j \u0026lt; i\\ \\land\\ a_i - a_j \u0026lt;= k}{i - j + 1 + \\max_{k \u0026lt; j\\ \\land \\ a_{j - 1} - a_k \u0026lt;= k}{j - k}}\\]\nä¸€ä¸ªåŒæŒ‡é’ˆç»´æŠ¤å†…å±‚ maxï¼Œä¸€ä¸ªå•è°ƒé˜Ÿåˆ—ç»´æŠ¤ \\(\\max_{j \u0026lt; i\\ \\land\\ a_i - a_j \u0026lt;= k}{- j + 1 + \\max_{k \u0026lt; j\\ \\land \\ a_j - a_k \u0026lt;= k}{j - k + 1}}\\)ï¼Œå°±å¯ä»¥å®ç° O(n).\nå•è°ƒé˜Ÿåˆ—ä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; const int N = 500010; int a[N], q[N]; long long f[N]; int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } long long res = 0; int pre_max = 0; sort(a + 1, a + n + 1); int hh = 0, tt = -1, t = 0; for (int i = 1, j = 1; i \u0026lt;= n; ++i) { while (hh \u0026lt;= tt \u0026amp;\u0026amp; a[i] - a[q[hh]] \u0026gt; k) hh++; while (j \u0026lt;= i \u0026amp;\u0026amp; a[i] - a[j] \u0026gt; k) j++; if (hh \u0026lt;= tt) res = max(res, i + f[q[hh]]); f[i] = -i + 1 + pre_max; pre_max = max(pre_max, i - j + 1); while (hh \u0026lt;= tt \u0026amp;\u0026amp; f[i] \u0026gt;= f[q[tt]]) tt--; q[++tt] = i; } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } çº¿æ®µæ ‘æš´æˆ¾ä»£ç ï¼ˆç¦»æ•£åŒ–ç–‘ä¼¼åå‘ä¼˜åŒ–äº†ï¼‰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; const int N = 500010; map\u0026lt;int, int\u0026gt; mp; int a[N], b[N]; long long tr[N * 4], f[N][2], s[N]; void pushup(int u) { tr[u] = max(tr[u \u0026lt;\u0026lt; 1], tr[u \u0026lt;\u0026lt; 1 | 1]); } void init(int u, int l, int r) { if (l == r) tr[u] = l == 0 ? 0 : -__LONG_LONG_MAX__; else { int mid = l + r \u0026gt;\u0026gt; 1; init(u \u0026lt;\u0026lt; 1, l, mid), init(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r); pushup(u); } } void modify(int u, int l, int r, int p, int v) { if (l == r) tr[u] = v; else { int mid = l + r \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) modify(u \u0026lt;\u0026lt; 1, l, mid, p, v); else modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, p, v); pushup(u); } } long long query(int u, int l, int r, int ql, int qr) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return tr[u]; else { long long res = -__LONG_LONG_MAX__; int mid = l + r \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) res = max(res, query(u \u0026lt;\u0026lt; 1, l, mid, ql ,qr)); if (qr \u0026gt; mid) res = max(res, query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr)); return res; } } int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); init(1, 0, n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); mp[a[i]]; } int m = 0; for (auto \u0026amp;i : mp) { i.second = ++m; b[m] = i.first; } for (int i = 1; i \u0026lt;= n; ++i) { s[mp[a[i]]]++; } for (int i = 1; i \u0026lt;= m; ++i) s[i] += s[i - 1]; long long res = 0; for (int i = 1; i \u0026lt;= m; ++i) { int l = 0, r = i - 1; while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (b[mid] \u0026lt; b[i] - k) l = mid; else r = mid - 1; } f[i][0] = max(f[i - 1][0], s[i] - s[l]); f[i][1] = s[i] + query(1, 0, n, l, i - 1); modify(1, 0, n, i, -s[i] + f[i][0]); } for (int i = 1; i \u0026lt;= m; ++i) { res = max(res, f[i][1]); } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } éå¸¸åç›´è§‰ï¼Œå…¶å®æˆ‘æ•²çº¿æ®µæ ‘æ¯”ä¸Šé¢çš„å•è°ƒé˜Ÿåˆ—å¿«ï¼Œå•è°ƒé˜Ÿåˆ—æ¯”è¾ƒè€ƒéªŒæ€ç»´ï¼Œä¸åƒæˆ‘ä»¬çº¿æ®µæ ‘å’ŒäºŒåˆ†æŸ¥æ‰¾ï¼Œç›´æ¥èƒŒæ¿å­å°±è¡Œäº†ã€‚\nC. æ˜Ÿæ˜Ÿç‚¹ç¯ è¿‡æ»¤æ‰æ‰€æœ‰è¾¹æƒå¤§äº m çš„è¾¹ï¼Œç„¶åè·‘æœ€å°ç”Ÿæˆæ ‘ï¼ŒåŒæ—¶ç»Ÿè®¡è¾¹æƒå’Œï¼Œæœ€ååŠ ä¸Š è¿é€šå—ä¸ªæ•° * m å°±æ˜¯ç­”æ¡ˆã€‚ç›¸å¯¹æ¯”è¾ƒ easy.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1010; struct edge { int x, y, z; } ed[N * N]; int fa[N]; int getfa(int x) { return x == fa[x] ? x : fa[x] = getfa(fa[x]); } int main() { int val, n, m = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;val, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) fa[i] = i; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); if (i \u0026lt; j) ed[++m] = {i, j, t}; } } sort(ed + 1, ed + m + 1, [](edge a, edge b) { return a.z \u0026lt; b.z; }); long long res = 0; for (int i = 1; i \u0026lt;= m; ++i) { if (ed[i].z \u0026gt; val) break; int x = ed[i].x, y = ed[i].y; x = getfa(x), y = getfa(y); if (x == y) continue; else { fa[y] = x; res += ed[i].z; } } for (int i = 1; i \u0026lt;= n; ++i) if (i == fa[i]) res += val; printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } D. ç¿˜è¯¾ ç±»ä¼¼äºåˆ†ç»„èƒŒåŒ…é—®é¢˜ï¼Œå…ˆæŠŠæ¯ä¸€å¤©å•ç‹¬çš„æ—· \\[0, k\\] èŠ‚è¯¾çš„åå‘†åœ¨æ•™å­¦æ¥¼çš„æ—¶é—´ç®—å‡ºæ¥ï¼Œç„¶åè·‘åˆ†ç»„èƒŒåŒ…dpå³å¯ã€‚ï¼ˆç†è®ºä¸Šå¯ä»¥åœ¨ç»´æŠ¤æ¯å¤©å•ç‹¬çš„æ—¶é—´çš„åŒæ—¶åšåˆ†ç»„èƒŒåŒ…dpï¼Œä½†æ˜¯æˆ‘ä¸çŸ¥é“ä¸ºä»€ä¹ˆä¸€ç›´å†™æŒ‚ï¼‰\npsï¼šè¯´çš„å¾ˆç®€å•ï¼Œä½†æ˜¯å†…éƒ¨é€»è¾‘å…¶å®æœ‰ç‚¹ç»•ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; a[510]; int f[510][510]; int g[510][510]; int main() { int n, m, k; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); if (t) a[i].push_back(j); } } memset(f, 0x3f, sizeof(f)); memset(g, 0x3f, sizeof(g)); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt; a[i].size(); ++j) { // æ—·è¯¾ j èŠ‚ int t = a[i].size() - j; // ä¸Šè¯¾ t èŠ‚ for (int k = t - 1; k \u0026lt; a[i].size(); ++k) { f[i][j] = min(f[i][j], a[i][k] - a[i][k - t + 1] + 1); } } f[i][a[i].size()] = 0; } g[0][0] = 0; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= k; ++j) { for (int l = 0; l \u0026lt;= j; ++l) { g[i][j] = min(g[i][j], g[i - 1][l] + f[i][j - l]); } } } int res = 0x3f3f3f3f; for (int i = 0; i \u0026lt;= k; ++i) { res = min(res, g[n][i]); } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } ","date":"2025-03-11T12:48:31Z","permalink":"https://invalidnamee.github.io/p/2025st5/","title":"2025æ˜¥è®­ç¬¬äº”åœº"},{"content":"å› ä¸ºåé¢æœ‰ä¸€åœºæ ¡èµ›ï¼Œè¿™åœºè®­ç»ƒèµ›æ²¡ä»€ä¹ˆå°è±¡äº†ã€‚\nA. ç¾ä¸½æ•° å…ˆè€ƒè™‘åˆæ³•æƒ…å†µï¼Œä»é«˜ä½åˆ°ä½ä½ä»å°åˆ°å¤§è¯•å¡«ã€‚è¯¥ä½å¡« i åˆæ³•å½“ä¸”ä»…å½“ i å’Œä¸Šä¸€ä½ä¸ç›¸ç­‰ä¸”ç”¨æ‰ä¸€æ¬¡ i ä¹‹åå‰©ä¸‹çš„çŠ¶æ€æ˜¯åˆæ³•çŠ¶æ€ï¼ˆå³ä¸ªæ•°æœ€å¤§çš„æ•°çš„ä¸ªæ•°ä¸å¤§äº \\(\\lceil \\frac{æ€»æ•°}{2} \\rceil\\)ï¼‰\nå¦‚æœå¡«åˆ°æŸä¸€ä½æ—¶ï¼Œä»»ä½• i éƒ½ä¸åˆæ³•ï¼Œé‚£ä¹ˆæ•´ä½“å°±ä¸åˆæ³•ï¼Œè¾“å‡º -1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int cnt[10]; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { vector\u0026lt;int\u0026gt; res; int s = 0; for (int i = 0; i \u0026lt; 10; ++i) { cin \u0026gt;\u0026gt; cnt[i]; s += cnt[i]; } int pre = 0; while (s) { bool flag = false; for (int i = 0; i \u0026lt; 10; ++i) { if (i != pre \u0026amp;\u0026amp; cnt[i]) { int mx = 0; for (int j = 0; j \u0026lt; 10; ++j) { if (i == j) continue; mx = max(mx, cnt[j]); } if (s - 1 - 2 * mx \u0026gt;= -1 \u0026amp;\u0026amp; s - 1 - 2 * (cnt[i] - 1) \u0026gt;= 0) { flag = true; res.push_back(i); s--; cnt[i]--; pre = i; break; } } } if (!flag) break; } if (s) cout \u0026lt;\u0026lt; -1; for (int i : res) cout \u0026lt;\u0026lt; i; cout \u0026lt;\u0026lt; endl; } return 0; } B. å†›è®­ å¤§æ°´é¢˜ï¼Œå¦‚æœç›¸é‚»ä¸¤ä¸ªä½ç½®çš„æ•°ç›¸å·®ä¸ä¸º 1ï¼Œå°±éœ€è¦åˆ‡å‰²ä¸€æ¬¡ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; using namespace std; int a[1000010]; int main() { int n, t = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); a[0] = -1; for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); if (a[i] != a[i - 1] + 1 \u0026amp;\u0026amp; a[i] != a[i - 1] - 1) t++; } printf(\u0026#34;%d\\n\u0026#34;, t - 1); return 0; } D. å‘å·¥èµ„ ç»å…¸çš„è´ªå¿ƒé—®é¢˜ï¼ŒæŠŠåŒºé—´æŒ‰ç…§å³ç«¯ç‚¹æ’åºï¼Œå¯¹äºæ¯ä¸€ä¸ªåŒºé—´ï¼ŒæŸ¥æ‰¾åŒºé—´å†…æœ€é å·¦çš„é‡‘ç –ç»™ä»–ï¼Œæ‰¾ä¸åˆ°å°±è·³è¿‡ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; pair\u0026lt;int, int\u0026gt; a[1000010]; map\u0026lt;int, int\u0026gt; s; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[i].first, \u0026amp;a[i].second); } for (int i = 1; i \u0026lt;= m; ++i) { int c; scanf(\u0026#34;%d\u0026#34;, \u0026amp;c); s[c]++; } sort(a + 1, a + n + 1, [](pair\u0026lt;int, int\u0026gt; a, pair\u0026lt;int, int\u0026gt; b) { return a.second \u0026lt; b.second; }); int res = 0; for (int i = 1; i \u0026lt;= n; ++i) { auto it = s.lower_bound(a[i].first); if (it != s.end() \u0026amp;\u0026amp; it-\u0026gt;first \u0026lt;= a[i].second) { it-\u0026gt;second--; if (it-\u0026gt;second == 0) s.erase(it); res++; } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } E. ç­¹å¤‡è®¡åˆ’ æœ€ä¼˜è§£åº”è¯¥æ˜¯å¼€ä¸¤ä¸ªæƒå€¼çº¿æ®µæ ‘ï¼Œåˆ†åˆ«ç»´æŠ¤ä¸­ä½æ•°å’Œåˆæ³•ä½ç½®ã€‚å¯¹äºæ¯æ¬¡æŸ¥è¯¢ï¼ŒæŸ¥è¯¢ç¬¬ä¸€ä¸ªçº¿æ®µæ ‘æ‰¾åˆ°ä¸­ä½æ•°ï¼Œç„¶ååœ¨ç¬¬äºŒä¸ªçº¿æ®µæ ‘ä¸­æŸ¥å·¦ä¾§ç¬¬ä¸€ä¸ªå’Œå³ä¾§ç¬¬ä¸€ä¸ªåˆæ³•ä½ç½®ï¼Œæ¯”è¾ƒä¸¤ä¸ªä½ç½®çš„ç»“æœå³å¯ï¼›æ¯”è¾ƒæ—¶è¿˜éœ€è¦å†å¼€ä¸€ä¸ªçº¿æ®µæ ‘ç»´æŠ¤å‰ç¼€å’Œå’Œåç¼€å’Œã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010; struct SegmentTree { long long tr[N * 4]; int tag[N * 4]; SegmentTree() { memset(tag, -1, sizeof(tag)); } void pushup(int u) { tr[u] = tr[u \u0026lt;\u0026lt; 1] + tr[u \u0026lt;\u0026lt; 1 | 1]; } void pushdown(int u, int l, int r) { if (~tag[u]) { int mid = l + r \u0026gt;\u0026gt; 1; tag[u \u0026lt;\u0026lt; 1] = tag[u \u0026lt;\u0026lt; 1 | 1] = tag[u]; if (tag[u]) tr[u \u0026lt;\u0026lt; 1] = mid - l + 1, tr[u \u0026lt;\u0026lt; 1 | 1] = r - mid; else tr[u \u0026lt;\u0026lt; 1] = tr[u \u0026lt;\u0026lt; 1 | 1] = 0; tag[u] = -1; } } void modify(int u, int l, int r, int p, long long v) { if (l == r) tr[u] += v; else { pushdown(u, l, r); int mid = l + r \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) modify(u \u0026lt;\u0026lt; 1, l, mid, p, v); else modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, p, v); pushup(u); } } void modify(int u, int l, int r, int ql, int qr, int v) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { if (v) tr[u] = r - l + 1; else tr[u] = 0; tag[u] = v; } else { pushdown(u, l, r); int mid = l + r \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) modify(u \u0026lt;\u0026lt; 1, l, mid, ql, qr, v); if (qr \u0026gt; mid) modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr, v); pushup(u); } } long long query(int u, int l, int r, int ql, int qr) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return tr[u]; else { pushdown(u, l, r); long long res = 0; int mid = l + r \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) res = query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr); if (qr \u0026gt; mid) res += query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr); return res; } } int kth_element(int u, int l, int r, long long k) { if (l == r) return l; else { pushdown(u, l, r); int mid = l + r \u0026gt;\u0026gt; 1; if (tr[u \u0026lt;\u0026lt; 1] \u0026gt;= k) return kth_element(u \u0026lt;\u0026lt; 1, l, mid, k); else return kth_element(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, k - tr[u \u0026lt;\u0026lt; 1]); } } } cnt, pos, sum; int n, q; long long calc(int p) { long long res = 0; if (p \u0026gt; 1) res = (long long)p * cnt.query(1, 1, n, 1, p - 1) - sum.query(1, 1, n, 1, p - 1); if (p \u0026lt; n) res += (long long)(-p) * cnt.query(1, 1, n, p + 1, n) + sum.query(1, 1, n, p + 1, n); return res; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); cnt.modify(1, 1, n, i, t); sum.modify(1, 1, n, i, (long long)t * i); } pos.modify(1, 1, n, 1, n, 1); while (q--) { int t, a, b; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;t, \u0026amp;a, \u0026amp;b); if (t == 1) { cnt.modify(1, 1, n, a, b); sum.modify(1, 1, n, a, (long long)a * b); } else if (t == 2) { cnt.modify(1, 1, n, a, -b); sum.modify(1, 1, n, a, -(long long)a * b); } else if (t == 3) { pos.modify(1, 1, n, a, b, 1); } else { pos.modify(1, 1, n, a, b, 0); } int p = cnt.kth_element(1, 1, n, cnt.query(1, 1, n, 1, n) + 1 \u0026gt;\u0026gt; 1); int pre_cnt = pos.query(1, 1, n, 1, p), l = -1, r = -1; if (pre_cnt) l = pos.kth_element(1, 1, n, pre_cnt); if (pre_cnt \u0026lt; pos.query(1, 1, n, 1, n)) r = pos.kth_element(1, 1, n, pre_cnt + 1); if (~l \u0026amp;\u0026amp; ~r) { if (calc(l) \u0026lt;= calc(r)) printf(\u0026#34;%lld\\n\u0026#34;, l); else printf(\u0026#34;%lld\\n\u0026#34;, r); } else if (~l) printf(\u0026#34;%lld\\n\u0026#34;, l); else if (~r) printf(\u0026#34;%lld\\n\u0026#34;, r); else printf(\u0026#34;-1\\n\u0026#34;); } return 0; } æˆ‘å½“æ—¶ç”¨çš„æ›´æš´åŠ›çš„ä¸¤ä¸ª log çš„åšæ³•å¡è¿‡å»äº†â€”â€”çº¿æ®µæ ‘åªæ‰“æ ‡è®°ï¼Œç”¨äºŒåˆ†æŸ¥æ‰¾æ‰¾åˆ°åˆæ³•ä½ç½®ï¼Œæµªè´¹äº†çº¿æ®µæ ‘æœ¬èº«çš„åˆ†æ²»ç»“æ„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010; long long tr[N], sum[N]; int s[N * 4], lazy[N * 4]; int n, q; inline void pushup(int u) { s[u] = s[u \u0026lt;\u0026lt; 1] + s[u \u0026lt;\u0026lt; 1 | 1]; } inline void pushdown(int u, int l, int r) { if (~lazy[u]) { int mid = l + r \u0026gt;\u0026gt; 1; s[u \u0026lt;\u0026lt; 1] = lazy[u] * (mid - l + 1), s[u \u0026lt;\u0026lt; 1 | 1] = lazy[u] * (r - mid); lazy[u \u0026lt;\u0026lt; 1] = lazy[u \u0026lt;\u0026lt; 1 | 1] = lazy[u]; lazy[u] = -1; } } inline void modify(int u, int l, int r, int ql, int qr, int v) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { s[u] = (r - l + 1) * v; lazy[u] = v; } else { pushdown(u, l, r); int mid = l + r \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) modify(u \u0026lt;\u0026lt; 1, l, mid, ql, qr, v); if (qr \u0026gt; mid) modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr, v); pushup(u); } } inline int smt_query(int u, int l, int r, int ql, int qr) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return s[u]; else { pushdown(u, l, r); int mid = l + r \u0026gt;\u0026gt; 1, res = 0; if (ql \u0026lt;= mid) res = smt_query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr); if (qr \u0026gt; mid) res += smt_query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr); return res; } } inline void add(int u, int k) { int tmp = u; for (; u \u0026lt;= n; u += u \u0026amp; -u) { tr[u] += k; sum[u] += (long long)tmp * k; } } inline long long query(int u) { long long res = 0; for (; u; u -= u \u0026amp; -u) { res += tr[u]; } return res; } inline long long qs(int u) { long long res = 0; for (; u; u -= u \u0026amp; -u) { res += sum[u]; } return res; } inline long long f(int p) { return (long long)p * query(p) * 2 - qs(p) * 2 + qs(n) - (long long)query(n) * p; } void smt_print() { for (int i = 1; i \u0026lt;= n; ++i) { printf(\u0026#34;%d \u0026#34;, smt_query(1, 1, n, i, i)); } printf(\u0026#34;\\n\u0026#34;); } void print() { for (int i = 1; i \u0026lt;= n; ++i) { printf(\u0026#34;%d \u0026#34;, query(i) - query(i - 1)); } printf(\u0026#34;\\n\u0026#34;); for (int i = 1; i \u0026lt;= n; ++i) { printf(\u0026#34;%d \u0026#34;, qs(i) - qs(i - 1)); } printf(\u0026#34;\\n\u0026#34;); } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for (int i = 1; i \u0026lt;= n; ++i) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); add(i, t); } memset(lazy, -1, sizeof(lazy)); while (q--) { int t, a, b; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;t, \u0026amp;a, \u0026amp;b); if (t == 1) { add(a, b); } else if (t == 2) { add(a, -b); } else if (t == 3) { modify(1, 1, n, a, b, 0); } else { modify(1, 1, n, a, b, 1); } int l = 1, r = n; long long s = query(n); while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (query(mid) * 2 \u0026gt;= s) r = mid; else l = mid + 1; } if (smt_query(1, 1, n, l, l) == 0) printf(\u0026#34;%d\\n\u0026#34;, l); else { int L, R; int p = l; l = 0, r = p; while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (smt_query(1, 1, n, mid, p) \u0026lt; p - mid + 1) l = mid; else r = mid - 1; } L = l; l = p, r = n + 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (smt_query(1, 1, n, p, mid) \u0026lt; mid - p + 1) r = mid; else l = mid + 1; } R = l; if (L == 0 \u0026amp;\u0026amp; R == n + 1) printf(\u0026#34;-1\\n\u0026#34;); else if (L == 0) printf(\u0026#34;%d\\n\u0026#34;, R); else if (R == n + 1) printf(\u0026#34;%d\\n\u0026#34;, L); else if (f(L) \u0026lt;= f(R)) printf(\u0026#34;%d\\n\u0026#34;, L); else printf(\u0026#34;%d\\n\u0026#34;, R); } } return 0; } ","date":"2025-03-11T12:47:01Z","permalink":"https://invalidnamee.github.io/p/2025st4/","title":"2025æ˜¥è®­ç¬¬å››åœº"},{"content":"æ›´æ–°è®°å½• æœ¬äººå®åŠ›æœ‰é™ï¼Œæœ‰ä¸€äº›é¢˜è‡³ä»Šè¿˜æ²¡åšå‡ºæ¥ï¼Œä¹‹åä¼šæ—¶ä¸æ—¶å¡«å‘ï¼Œæ•…æŠŠå¡«å‘è®°å½•åŠ åˆ°æœ€ä¸Šé¢äº†ï¼Œç›®å‰è¿˜å·® I, K, Lã€‚\n2025/03/11 æ›´æ–°äº† J é¢˜çš„è§£æ³•ã€‚\n2025/03/16 æ›´æ–°äº† J é¢˜è§£æ³•çš„è§£é‡Šã€‚\nProblem A. ç²¾å‡†åˆ‡å‰² è¿™é‡Œæä¾›ä¸€ç§æš´åŠ›çš„æ–¹æ³•ï¼Œä»¥å·¦ä¸‹è§’ä¸ºåŸç‚¹ï¼Œé•¿è¾¹ä¸º x è½´ï¼ŒçŸ­è¾¹ä¸º y è½´å»ºç«‹å¹³é¢ç›´è§’åæ ‡ç³»ï¼ˆä¸ºä¿è¯ç²¾åº¦ï¼Œæ‰€æœ‰åæ ‡ä¹˜ nï¼Œå› ä¸º n æ˜¯åˆ†æ¯ï¼‰ï¼Œæš´åŠ›å°è¯•ä¸»å¯¹è§’çº¿åœ¨ä¸€åˆ—æ ¼å­å·¦ä¾§å’Œå³ä¾§çš„æˆªè·ï¼Œè®°ä¸º \\(y_1,y_2\\)è®° \\(t = \\lfloor \\frac{y_1}{n} \\rfloor \\times n\\)ï¼Œå¦‚æœ \\((y_1 - t) + (y_2 - t) = n\\) è¡¨æ˜åˆ‡å‰²æ˜¯å¯¹ç§°çš„ï¼Œè¯¥å—è¢«å‡åˆ†ã€‚\næˆ‘æ„Ÿè§‰ä¸€å®šæœ‰ä¸æš´åŠ›çš„åŠæ³•ï¼Œæ¬¢è¿è®¡ç®—å‡ ä½•å¤§ä½¬çš„æ–°ç‚¹å­ã€‚\nå‚è€ƒä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int f(int n, int m) { if (n \u0026lt; m) swap(n, m); int res = 0; for (int i = 1; i \u0026lt;= n; ++i) { int t = (i - 1) * m / n * n; if ((i * m - t) + ((i - 1) * m - t) == n) res++; } return res; } int main() { cout \u0026lt;\u0026lt; f(22, 38) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; f(21, 36) \u0026lt;\u0026lt; endl; return 0; } Problem B. è®©æ—¶é—´èµ°èµ°åœåœ è¿™é“æ‰æ˜¯çœŸç­¾åˆ°é¢˜ï¼Œä¸‹é¢é‚£é“ç­¾åˆ°é¢˜å­¦å­¦å•ŠğŸ˜­\nè®°åˆå§‹çŠ¶æ€ä¸º 0ï¼Œå¹³å¹´ +365ï¼Œé—°å¹´ +366ï¼Œå¯¹ 7 å–æ¨¡ï¼Œå¦‚æœæ˜¯ 0ï¼Œå°±æ˜¯ç¦åˆ©å¹´ã€‚\nå‚è€ƒä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int i, t = 1, cur = 0; for (i = 2001; t \u0026lt; 8; ++i) { cur += 365; if (i % 100 == 0 \u0026amp;\u0026amp; i % 400 == 0 || i % 4 == 0) cur++; cur %= 7; if (cur == 0) t++; } cout \u0026lt;\u0026lt; i - 1 \u0026lt;\u0026lt; endl; return 0; } Problem C. å¤§åŠ›å‡ºå¥‡è¿¹ çœ‹é¢˜ç›®å¥½åƒå°±æ˜¯è®©æš´åŠ›çš„ï¼ˆå­©å­åªä¼šæš´åŠ›ï¼‰ï¼Œèµ›åæˆ‘åœ¨æœ¬åœ°è·‘æˆ‘çš„ O(nÂ²) æš´åŠ›ç¨‹åºåªè·‘äº† 4min 19sï¼Œæ€è€ƒä¸‹ä¸€é“é¢˜çš„æ—¶å€™æŒ‚ä¸Šæš´åŠ›ï¼Œä¸‹ä¸€é“æ•²å®Œäº†å°±è·‘å®Œäº†ã€‚ç­”æ¡ˆæ˜¯ 809/1001.\næš´åŠ›çš„ä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } int main() { long long a = 0, b = 1; int n = 111111; for (int i = 2; i \u0026lt;= n; ++i) { int t = 0; for (int j = 2; j \u0026lt;= i; ++j) { if (gcd(i, j) != 1) t++; } if (a * i \u0026lt; t * b) a = t, b = i; printf(\u0026#34;%d tries left\\n\u0026#34;, n - i); } int g = gcd(a, b); a /= g, b /= g; printf(\u0026#34;%lld/%lld\\n\u0026#34;, a, b); return 0; } æœ‰å›¾æœ‰çœŸç›¸ï¼ˆç¬¬ä¸€æ¬¡è·‘çš„æ—¶å€™å¿˜äº†çº¦åˆ†äº†ï¼Œä½†æ˜¯æ— ä¼¤å¤§é›…ï¼Œè¿è¡Œæ—¶é—´å¤§è‡´æ˜¯å‡†çš„ï¼‰\nProblem D. æ—¶å·¦æ—¶å³ ç›´æ¥æŒ‰ç…§é¢˜ç›®çš„è¦æ±‚æ¨¡æ‹Ÿå³å¯ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(nm)ï¼Œå®Œå…¨å¤Ÿç”¨ã€‚ç»´æŠ¤ ne\n\\[i\\]\\[j\\] è¡¨ç¤ºå½“å‰åœ¨ç¬¬ i ä¸ªé€šé“ï¼Œåœ¨ç¬¬ j æ¬¡ç§»åŠ¨æ—¶ç§»åŠ¨åˆ°çš„ä¸‹ä¸€ä¸ªç‚¹ï¼Œé»˜è®¤ä¸º iï¼›ç„¶åéå† \\[1, n\\]ï¼Œåˆ†åˆ«æ¨¡æ‹Ÿä¸€éå¹¶è®°å½•ç­”æ¡ˆå³å¯ã€‚\nå‚è€ƒä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; using namespace std; int ne[110][1010], res[110]; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { ne[i][j] = i; } } for (int i = 1; i \u0026lt;= m; ++i) { int t; cin \u0026gt;\u0026gt; t; ne[t][i] = t + 1, ne[t + 1][i] = t; } for (int i = 1; i \u0026lt;= n; ++i) { int t = i; for (int j = 1; j \u0026lt;= m; ++j) t = ne[t][j]; res[t] = i; } for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; endl; return 0; } Problem E. â€œåˆä½œâ€ ä»èµ„è´¨æœ€å¼±çš„è‰¾æ¯”è¿™é‡Œè€ƒè™‘å¾ˆå›°éš¾ï¼Œå› ä¸ºä¸å¥½ç¡®å®šè°ä¼šå’Œå®ƒåˆä½œï¼Œè°ä¼šæ”»å‡»å®ƒã€‚ä¸å¦¨ä»èµ„è´¨æœ€å¼ºçš„è‰¾æ¯”å¼€å§‹è€ƒè™‘ã€‚\nèµ„è´¨æœ€å¼ºçš„è‰¾æ¯”ä¸€å®šä¼šæ´»ä¸‹æ¥ï¼Œå¹¶ä¸”æŒç»­æ”»å‡»èµ„è´¨æ¯”ä»–å¼±çš„è‰¾æ¯”ï¼›\nè€ƒè™‘èµ„è´¨æ¬¡å¼ºçš„è‰¾æ¯”ï¼Œä¸ºäº†ç•™ä¸‹æ¥ï¼Œå®ƒä¼šé€‰æ‹©å¸®åŠ©ä¸€å®šæ•°é‡çš„è‰¾æ¯”é˜²å¾¡ï¼ˆè¿™ä¸ªæ•°é‡å°½å¯èƒ½å°ï¼‰ï¼Œç›´åˆ°è¿™ä¸€ä¸ªåŒºé—´å†…çš„è‰¾æ¯”çš„èµ„è´¨å’Œå¤§äºæˆ–è€…ç­‰äºèµ„è´¨æœ€å¼ºçš„è‰¾æ¯”ã€‚å¦‚æ­¤ï¼Œä¸€ä¸ªåŒºé—´å†…çš„è‰¾æ¯”éƒ½èƒ½æ´»ä¸‹æ¥ï¼›æ´»ä¸‹æ¥ä¹‹åä»–ä»¬ä¼šé€‰æ‹©å°½å¯èƒ½èµ¶èµ°å…¶ä»–è‰¾æ¯”ï¼Œå› æ­¤ä¼šå’Œæœ€å¼ºçš„åˆä½œï¼Œæ”»å‡»å…¶ä»–æ›´å¼±çš„è‰¾æ¯”ï¼›\nå¾ªç¯å¾€å¤ï¼Œç›´åˆ°å‰©ä¸‹çš„æ‰€æœ‰è‰¾æ¯”åˆä½œéƒ½æ— æ³•æŠµå¾¡æ”»å‡»è€…ï¼Œè‡³æ­¤æ”»å‡»è€…å…¨éƒ¨ç•™ä¸‹æ¥ï¼Œå‰©ä¸‹çš„è‰¾æ¯”å…¨éƒ¨è¢«èµ¶èµ°ã€‚\næ¥ä¸‹æ¥æ¨¡æ‹Ÿè¿™ä¸ªè¿‡ç¨‹å³å¯ã€‚\nå‚è€ƒä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 500010; int s[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[i]); } sort(s + 1, s + n + 1); long long rs = s[n], ls = 0; int p = n; for (int i = n - 1; i; --i) { ls += s[i]; if (ls \u0026gt;= rs) { rs += ls; ls = 0; p = i; } } printf(\u0026#34;%d\\n\u0026#34;, n - p + 1); return 0; } Problem F. æœªå®Œå¾…ç»­ è¿™é“é¢˜éå¸¸çš„å‘äººï¼ŒæŒ–å‘æŒ–çš„éå¸¸å·§å¦™ï¼Œå¦‚æœé¢˜é¢èƒ½åŠ ä¸€å¥â€œé€šè¿‡æ—‹è½¬å¯ä»¥ç­‰ä»·çš„æƒ…å†µè§†ä¸ºå¤šç§â€å°±æ›´å®Œå–„äº†ã€‚\nä¸€èˆ¬æƒ…å†µ è€ƒè™‘çº¿æ€§dpï¼Œè®° f\n\\[i\\]\\[0\\] ä¸ºç¬¬ i åˆ—ä¸æ”¾ç‰Œçš„æ–¹æ¡ˆä¸ªæ•°ï¼Œf\n\\[i\\]\\[1\\] ä¸ºç¬¬ i åˆ—æ”¾ç‰Œçš„æ–¹æ¡ˆä¸ªæ•°ï¼Œæ˜¾ç„¶æœ‰\n\\[f_{i, 0} = f_{i - 1, 0} + f_{i - 1, 1}\\]\n\\[f_{i, 1} = 2f_{i - 1, 0}\\]\nè¿™ä¸ªé€’æ¨å¼å¯ä»¥ç”¨çŸ©é˜µåŠ é€Ÿï¼Œæ„é€ é€’æ¨å¼å¦‚ä¸‹\n\\[\\begin{pmatrix} f_{i - 1, 0} \u0026amp; f_{i - 1, 1} \\end{pmatrix} * \\begin{pmatrix} 1 \u0026amp; 2\\ 1 \u0026amp; 0 \\end{pmatrix} = \\begin{pmatrix} f_{i, 0} \u0026amp; f_{i, 1} \\end{pmatrix}\\]\nåˆå§‹çŠ¶æ€ \\(\\begin{pmatrix} 1 \u0026amp; 0 \\end{pmatrix}\\)ï¼Œç”¨çŸ©é˜µå¿«é€Ÿå¹‚æ±‚ \\(\\begin{pmatrix} 1 \u0026amp; 2\\ 1 \u0026amp; 0 \\end{pmatrix}^n\\)ï¼Œç„¶åç›¸ä¹˜ï¼Œå°±èƒ½å¾—åˆ° \\(\\begin{pmatrix} f_{n, 0} \u0026amp; f_{n, 1} \\end{pmatrix}\\). è¿™æ ·å°±å¾—åˆ°äº† O(log n) çš„åšæ³•ã€‚\nç‰¹æ®Šæƒ…å†µ è€ƒè™‘ 3 Ã— 3 çš„æƒ…å†µï¼Œå› ä¸ºé¢˜ç›®è¯´å¹³è¡Œäºé•¿åº¦ä¸º 3 çš„è¾¹ï¼Œæ­¤æ—¶å¹³è¡Œäºå“ªæ¡è¾¹éƒ½æ˜¯å¯ä»¥çš„ï¼ŒåŸæ¥æœ‰ 11 ç§æƒ…å†µï¼Œé¡ºæ—¶é’ˆæ—‹è½¬ 90Â°ï¼Œè¿˜æœ‰ 10 ç§æƒ…å†µï¼Œå¦å¤–è¿˜æœ‰ä»¥ä¸‹å››ç§æƒ…å†µï¼Œå…±è®¡ 25 ç§ï¼Œç‰¹åˆ¤ n = 3 æ—¶è¾“å‡º 25 å³å¯ã€‚\n1 2 3 **_ __* *__ _** __* __* *__ *__ __* **_ _** *__ å‚è€ƒä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MOD = 1000000007; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; mul(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; b) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(2, vector\u0026lt;int\u0026gt;(2, 0)); for (int k = 0; k \u0026lt; 2; ++k) { for (int i = 0; i \u0026lt; 2; ++i) { for (int j = 0; j \u0026lt; 2; ++j) { res[i][j] = (res[i][j] + (long long)a[i][k] * b[k][j] % MOD) % MOD; } } } return res; } int solve(unsigned long long p) { if (p == 3) return 25; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res = {{1, 0}, {0, 1}}, base = {{1, 2}, {1, 0}}; while (p) { if (p \u0026amp; 1) res = mul(res, base); base = mul(base, base); p \u0026gt;\u0026gt;= 1; } return (res[0][0] + res[0][1]) % MOD; } int main() { unsigned long long n; // æ³¨æ„æ•°æ®èŒƒå›´ï¼Œåˆ«æŠŠ long long çˆ†äº† cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; ((solve(n * 2) - solve(n)) % MOD + MOD) % MOD \u0026lt;\u0026lt; endl; return 0; } Problem G. è¿™é‡Œä¸€å®šå‘ç”Ÿè¿‡ä»€ä¹ˆ XXXï¼ŒG é¢˜æœ‰ä¸€ä»½â€¦â€¦ä¸ï¼Œæ˜¯ 26 ä»½æäº¤ï¼Œæ²¡æœ‰é€šè¿‡ã€‚æ²¡é”™ï¼Œè¿™å°±æ˜¯æˆ‘\næ‹¼éŸ³ï¼Œä¸å¯æˆ˜èƒœçš„ã€‚\nè±†åŒ…å†™çš„ä»£ç ï¼ˆä¸€éç§’äº†ï¼Œæˆ‘ä¸å¦‚è±†åŒ…ğŸ˜­ï¼‰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;std::string\u0026gt; pinyinTexts = { \u0026#34;you ren shuo zhao ge ge zhu ban dan wei de yi ju jian jie zai qian mian jia shang you ren shuo zai hou mian jia shang ye you ren ren wei bu jin ru ci ni zen me kan jiu ke yi chu cheng ben ci xiao sai de qian dao ti ye you ren ren wei bu jin ru ci ni zen me kan\u0026#34;, \u0026#34;ACM ju le bu shi gao xin jiu ye ming xiao shen zao de yao lan\u0026#34;, \u0026#34;ji suan ji xue yuan shuang chuang zhong xin lang chao ju le bu zhuan zhu yu pei yang xue sheng chuang xin neng li\u0026#34;, \u0026#34;wu xian dian xie hui ju jiao yu dian zi ji shu yu chuang xin shi jian\u0026#34;, \u0026#34;shu xue jian mo xie hui duo ci bei ping wei you xiu she tuan\u0026#34;, \u0026#34;zen me kan jiu shi wei le zhe dian cu cai bao de zhe dun jiao zi\u0026#34; }; int n; std::cin \u0026gt;\u0026gt; n; if (n \u0026gt;= 1 \u0026amp;\u0026amp; n \u0026lt;= 6) { std::cout \u0026lt;\u0026lt; pinyinTexts[n - 1] \u0026lt;\u0026lt; std::endl; } return 0; } Problem H. æ•°å¯¹ éå†ä¸€éå­—ç¬¦ä¸²ï¼ˆå­—ç¬¦ä¸²è®°ä¸ºsï¼‰ï¼Œå¼€ä¸€ä¸ªæ•°ç»„ vis è®°å½•æ¯ä¸€ç§å°å†™å­—æ¯ä¸Šæ¬¡å‡ºç°çš„ä½ç½®ï¼Œå¯¹äºæ¯ä¸€ä¸ªä½ç½® iï¼Œéå† \\(\\text{j} \\in [\\text{\u0026lsquo;a\u0026rsquo;, \u0026lsquo;z\u0026rsquo;}]\\)ï¼ŒIF vis\n\\[j\\] \u0026gt; vis\n\\[i\\] THEN ç­”æ¡ˆ++ å³å¯ã€‚\nå‚è€ƒä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int vis[26]; int main() { memset(vis, -1, sizeof(vis)); string s; int res = 0; cin \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt; s.length(); ++i) { for (int j = 0; j \u0026lt; 26; ++j) { if (~vis[j] \u0026amp;\u0026amp; vis[j] \u0026gt; vis[s[i] - \u0026#39;a\u0026#39;]) res++; } vis[s[i] - \u0026#39;a\u0026#39;] = i; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } Problem J. æœ¨æ¿æ”¾ç½® çœ‹ç€æ— ä»ä¸‹æ‰‹ï¼ˆå®é™…ä¸Šä¹Ÿæ— ä»ä¸‹æ‰‹ï¼‰ã€‚\nè¿™é¢˜å¯ä»¥ç”¨è´ªå¿ƒåšï¼Œå…·ä½“åšæ³•æ˜¯\nå¯¹äºåˆæ³•çš„æƒ…å†µï¼Œåšæ³•æ˜¯å…ˆæŠŠé•¿åº¦éƒ½è®¾æˆ Rï¼Œæšä¸¾æ¯ä¸€ä¸ªé—´è·ä¼˜å…ˆä¿è¯å·¦ä¾§çš„æ¿å­é•¿åº¦ä¸º Rï¼Œå¯¹äºä¸æ»¡è¶³è¦æ±‚çš„é—´è·ä¼˜å…ˆç¼©çŸ­å³ä¾§ï¼Œå¦‚æœå³ä¾§ç¼©åˆ° Lï¼Œä»ç„¶ä¸åˆæ³•ï¼Œå°±ç»§ç»­ç¼©çŸ­å·¦ä¾§ã€‚\nå¯¹äºä¸åˆæ³•æƒ…å†µï¼Œåœ¨éå†é—´è·çš„æ—¶å€™åˆ¤æ–­é—´è·æ˜¯å¦å°äº L å³å¯ã€‚\nè¯æ˜ï¼ˆæ•°å­¦å½’çº³æ³•ï¼‰ï¼š\næ˜¾ç„¶ï¼Œn = 1 çš„æ—¶å€™æ»¡è¶³ï¼›\nå‡è®¾ n = k çš„æ—¶å€™æ˜¯æœ€ä¼˜çš„ï¼Œé‚£ä¹ˆåœ¨æœ€åé¢å†åŠ ä¸€ä¸ªé•¿åº¦ä¸º R çš„æœ¨æ¿\nå¦‚æœæ”¾å¾—ä¸‹ï¼Œé‚£ä¸€å®šè¿˜æ˜¯æœ€ä¼˜ï¼›\nå¦‚æœæ”¾ä¸ä¸‹ï¼Œç¼©çŸ­æœ€åä¸€ä¸ªæœ¨æ¿å’Œç¼©çŸ­ç¬¬ k ä¸ªæœ¨æ¿æ˜¯ç­‰ä»·çš„ã€‚\næ‰€ä»¥è¿™ä¸ªåšæ³•æ˜¯å¯è¡Œçš„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; int a[N], s[N]; int main() { int n, l, r; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;l, \u0026amp;r); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); s[i] = r; } a[0] = -0x3f3f3f3f, a[n + 1] = 0x3f3f3f3f; sort(a + 1, a + n + 1); for (int i = 1; i \u0026lt;= n; ++i) { if (a[i] - a[i - 1] \u0026lt; l) { printf(\u0026#34;-1\\n\u0026#34;); return 0; } else if ((s[i - 1] + l) \u0026lt;= (a[i] - a[i - 1]) * 2) s[i] = min(r, (a[i] - a[i - 1]) * 2 - s[i - 1]); else s[i] = l, s[i - 1] = (a[i] - a[i - 1]) * 2 - l; } int res = 0; for (int i = 1; i \u0026lt;= n; ++i) { res += s[i]; } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } Problem M. åˆ æ•° è¿™é“é¢˜ç›¸å¯¹æ­£å¸¸ï¼Œæ¯” G ç®€å• â™¾ï¸ å€ã€‚\nç®€å•å˜æ¢ä¸€ä¸‹ï¼Œå‰©ä¸‹çš„æ€»å’Œä¸º mï¼Œç­‰ä»·äºåˆ é™¤çš„ä¸€æ®µçš„æ€»å’Œä¸º \\(\\sum_{i = 1}^{n}{a_i} - m\\)ï¼›åªéœ€ç»´æŠ¤ä¸€ä¸ªå‰ç¼€å’Œæ•°ç»„ sï¼Œå¯¹äºæ¯ä¸€æ¬¡æŸ¥è¯¢ï¼Œéå†æ•°ç»„ï¼Œå¯¹äºæ¯ä¸€ä¸ªä½ç½® iï¼Œæ˜¯å¦å­˜åœ¨ \\(j \\in [0, i]\\), \\(s_i - s_j = s_n - m\\)å³å¯ï¼›æŸ¥è¯¢çš„æ–¹æ³•æœ‰å¾ˆå¤šç§ï¼Œæˆ‘ç»™å‡ºçš„å‚è€ƒä»£ç ç”¨çš„äºŒåˆ†æŸ¥æ‰¾ï¼Œä¹Ÿå¯ä»¥ç”¨ unordered_setï¼Œunordered_map ç­‰ STL å®¹å™¨ç»´æŠ¤ã€‚\nå‚è€ƒä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; long long s[1000010]; int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;s[i]); s[i] += s[i - 1]; } while (q--) { int m; scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); m = s[n] - m; bool f = false; for (int i = 1; i \u0026lt;= n; ++i) { int l = 0, r = i; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (s[mid] \u0026gt;= s[i] - m) r = mid; else l = mid + 1; } if (s[i] - s[l] == m) { f = true; break; } } if (f) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); } return 0; } è·å¥–æ„Ÿè¨€ è§‚å‰æé†’ï¼šèƒ¡è¨€ä¹±è¯­ï¼Œè¯·ä¸è¦ä¿¡ä»¥ä¸ºçœŸï¼ï¼ï¼\næˆ‘æ„Ÿè°¢ G é¢˜çš„å‡ºé¢˜äººï¼Œè®©æˆ‘è®¤è¯†åˆ°äº†è‡ªå·±ä½œä¸ºä¸­å›½äººåº”è¯¥æœ‰ç‚¹æ–‡åŒ–ç´ å…»ä»æœ‰æ¬ ç¼ºï¼›æˆ‘ä½©æœ J é¢˜çš„å‡ºé¢˜äººï¼Œta å¾ˆä¼šå‘äººï¼ˆæˆ‘æ˜å¹´ä¹Ÿä¸€å®šä¼šå‘ ta å­¦ä¹ ï¼‰ã€‚å°ç±³ä¿æ¸©æ¯å¾ˆå¥½ç”¨ï¼Œæ¯”æ‰‹ç¯å®ç”¨å¤šäº†ï¼Œè¿™ä¸€å®šæ˜¯ G é¢˜å‡ºé¢˜äººæ— æ„é—´ç»™æˆ‘å®‰æ’å¥½çš„å§ã€‚\nå®è¯è¯´ï¼Œè¿™æ¬¡æ ¡èµ›åŸºæœ¬ä¸Šéƒ½æ²¡å¯¹åˆ°æˆ‘çš„å¼ºé¡¹ä¸Šï¼Œè®¡ç®—å‡ ä½•ï¼Œæ•°å­¦é¢˜ï¼Œåšå¼ˆï¼Œæ±‰è¯­æ‹¼éŸ³æ­£å¥½å®Œç¾åŒ…æ‹¬äº†æˆ‘çš„å¼±é¡¹ã€‚ç»™äº†æ•°å­¦è¯­æ–‡åŸºç¡€å¥½çš„äººå¾ˆå¤§çš„å‘æŒ¥ç©ºé—´ï¼Œå¯¹äºæˆ‘è¿™ç§åªä¼šåŸºæœ¬çš„ DPï¼Œå›¾è®ºï¼Œæ•°æ®ç»“æ„çš„äººç®€ç›´æ˜¯ç¾éš¾çº§çš„ğŸ˜­ï¼Œåšä¸åŠ¨ï¼Œæ ¹æœ¬åšä¸åŠ¨ï¼Œæœ€å 7 åˆ†é’Ÿçš„æ—¶å€™è°ƒæ‹¼éŸ³è°ƒå¾—å¿ƒæ€å½»åº•å´©äº†ã€‚\n","date":"2025-03-10T11:22:06Z","permalink":"https://invalidnamee.github.io/p/upcpc2025/","title":"Upcpc2025"},{"content":"è€ƒåœºä¸Šåªåšå‡ºæ¥äº† Aã€Cã€Dã€Fã€‚æˆ‘çœŸçš„æ•²é«˜ç²¾äº†ï¼Œè€Œä¸”ç”šè‡³åŠ æ³•å–æ¨¡éƒ½æ•²äº†ï¼Œåˆšå¼€å§‹ B æœ‰ä¸€ä¸ªæ ·ä¾‹æ˜¯é”™çš„ï¼Œå¸¦æ²Ÿé‡Œä¹‹åå›ä¸æ¥äº†ï¼Œè€ƒå®Œä¹‹åè¢« @xx liu (qwertyuiop) å¤§ä½¬ä¸€å¥è¯æ•²é†’äº†ğŸ˜‡ã€‚æ•°å­¦é¢˜ç¡®å®æœ‰ç‚¹ä¸å¥½æƒ³ï¼Œå½“æ—¶ä¹Ÿæ˜¯å°½åŠ›äº†ã€‚\nA. å­—ç¬¦ä¸²æ¯”å¯¹ ç­¾åˆ°é¢˜\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { string a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if (a.length() != b.length()) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; else { bool f1 = true, f2 = true; for (int i = 0; i \u0026lt; a.length(); ++i) { if (a[i] != b[i]) f1 = false; if (toupper(a[i]) != toupper(b[i])) f2 = false; } if (f1) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; endl; else if (f2) cout \u0026lt;\u0026lt; 3 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 4 \u0026lt;\u0026lt; endl; } return 0; } B. æ•°å­¦å°åº—çš„å¥‡å¦™å…‘æ¢ é«˜ç²¾åº¦é™¤æ³• n / (k - 1).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #define int long long using namespace std; vector\u0026lt;int\u0026gt; div(vector\u0026lt;int\u0026gt; a, int b) { vector\u0026lt;int\u0026gt; res(a.size(), 0); long long t = 0; for (int i = a.size() - 1; i \u0026gt;= 0; --i) { t = t * 10 + a[i]; res[i] = t / b; t %= b; } while (res.back() == 0 \u0026amp;\u0026amp; res.size() \u0026gt; 1) res.pop_back(); return res; } signed main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); vector\u0026lt;int\u0026gt; n; string s; int k; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; n.resize(s.length()); for (int i = 0; i \u0026lt; s.length(); ++i) { n[i] = s[s.length() - i - 1] - \u0026#39;0\u0026#39;; } vector\u0026lt;int\u0026gt; res = div(n, k - 1); for (int i = res.size() - 1; i \u0026gt;= 0; --i) { cout \u0026lt;\u0026lt; res[i]; } cout \u0026lt;\u0026lt; endl; return 0; } C. æŸ“è‰² æ­£å‘ç»´æŠ¤å¾ˆå›°éš¾ï¼Œä½†æ˜¯åå‘å¤„ç†å¾ˆç®€å•ï¼Œå› ä¸ºä¸ç”¨è€ƒè™‘è¿™æ¬¡æŸ“è‰²çš„ç‚¹ä¼šä¸ä¼šè¢«åç»­çš„æ“ä½œæ”¹å˜ï¼Œç»™è¡Œå’Œåˆ—å„å¼€ä¸€ä¸ªåˆ é™¤æ ‡è®°ï¼ŒæŸ“è‰²ä¹‹åæ‰“ä¸Šæ ‡è®°ï¼Œæ¯æ¬¡æ“ä½œå®Œä¹‹ååç»­æ“ä½œçš„è¡Œæ•°æˆ–è€…åˆ—æ•° -1ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; struct Query { int op, u, c; }; bool vis[100010][2]; long long cnt[100010]; stack\u0026lt;Query\u0026gt; st; int main() { int n, m, k, q; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k, \u0026amp;q); for (int i = 1; i \u0026lt;= q; ++i) { int op, u, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;op, \u0026amp;u, \u0026amp;c); st.push({op, u, c}); } while (!st.empty()) { auto [op, u, c] = st.top(); st.pop(); if (op == 0) { if (!vis[u][op]) { cnt[c] += n; vis[u][op] = true; m--; } } else { if (!vis[u][op]) { cnt[c] += m; vis[u][op] = true; n--; } } } for (int i = 1; i \u0026lt;= k; ++i) printf(\u0026#34;%lld \u0026#34;, cnt[i]); printf(\u0026#34;\\n\u0026#34;); return 0; } D. é­”æ³•ä¼ é€é—¨ å› ä¸ºç­”æ¡ˆä¹˜çš„å€æ•°å°±æ˜¯äºŒè¿›åˆ¶çš„ä½æ•°ï¼Œå¯ä»¥æŠŠæ¯ä¸€ä»½ç­”æ¡ˆç›´æ¥åˆ†æ‘Šåˆ°æ¯ä¸ªäºŒè¿›åˆ¶ä½ï¼Œå¼€ä¸€ä¸ªçŠ¶æ€æ•°ç»„è®°å½•å½“å‰çŠ¶æ€ä¹‹å‰çš„å…¨éƒ¨çŠ¶æ€çš„æ¯ä¸ªäºŒè¿›åˆ¶ä½æä¾›çš„æ–¹æ¡ˆæ•°æ€»å’Œã€‚éå†åˆ°ä¸€ä¸ªçŠ¶æ€çš„æ—¶å€™ï¼Œå…ˆæšä¸¾äºŒè¿›åˆ¶ä½æ›´æ–°ç­”æ¡ˆï¼Œå†æšä¸¾äºŒè¿›åˆ¶ä½ç”¨æ–°ç­”æ¡ˆæ›´æ–°çŠ¶æ€æ•°ç»„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int MOD = 998244353; int a[200010]; long long f[200010], s[30]; int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { memset(s, 0, sizeof(s)); int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); if (i == 1) f[i] = 1; else { f[i] = 0; for (int j = 0; j \u0026lt; 30; ++j) { if (a[i] \u0026gt;\u0026gt; j \u0026amp; 1) f[i] = (f[i] + s[j]) % MOD; } } for (int j = 0; j \u0026lt; 30; ++j) { if (a[i] \u0026gt;\u0026gt; j \u0026amp; 1) s[j] = (s[j] + f[i]) % MOD; } } printf(\u0026#34;%lld\\n\u0026#34;, f[n]); } return 0; } E. åŒä½™æ–¹ç¨‹ (fang) æ³¨æ„åˆ° a æ˜¯è¿ç»­åŒºé—´ï¼Œè€Œ bÂ² å’Œ cÂ³ æ˜¯ç¦»æ•£çš„ï¼Œå¯ä»¥æŠŠ a æåˆ° bÂ² æˆ–è€… cÂ³ ä¸­ï¼›åˆå› ä¸ºé¢˜ç›®è¦æ±‚ a â‰¤ b â‰¤ cï¼ŒæŠŠ a æåˆ° bÂ² ä¸­æ›´å¥½ç»´æŠ¤ã€‚å…·ä½“çš„ï¼Œéœ€è¦åŠ¨æ€ç»´æŠ¤ä¸€ä¸ªé•¿åº¦ä¸º k çš„æ•°ç»„ï¼Œè®°å½• a + bÂ² mod k çš„æ¯ç§ç»“æœçš„æ–¹æ¡ˆæ•°ï¼Œåœ¨ä» 1 åˆ° n æšä¸¾ b çš„è¿‡ç¨‹ä¸­æ›´æ–°æ¯ä¸ªå¯èƒ½çš„ c å¯¹åº”çš„ç­”æ¡ˆï¼Œç´¯åŠ å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; long long tr[1000010]; int n, k; void add(int u, int v) { u++; for (; u \u0026lt;= k; u += u \u0026amp; -u) { tr[u] += v; } } long long query(int u) { u++; long long res = 0; for (; u; u -= u \u0026amp; -u) { res += tr[u]; } return res; } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int t = 1; t \u0026lt;= T; ++t) { memset(tr, 0, sizeof(tr)); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); long long res = 0; for (int i = 1; i \u0026lt;= n; ++i) { long long l = (long long)i * i + 1, r = (long long)i * i + i; add(0, (r - l + 1) / k); r -= (r - l + 1) / k * k; if (l \u0026lt;= r) { l %= k, r %= k; if (l \u0026lt;= r) add(l, 1), add(r + 1, -1); else add(0, 1), add(r + 1, -1), add(l, 1); } res += query((long long)i * i * i % k); } printf(\u0026#34;Case %d: %lld\\n\u0026#34;, t, res); } return 0; } F. è®¡ç®—å™¨ (monitor) å°±æ˜¯ç®€å•çš„æ¨¡æ‹Ÿé¢˜ï¼Œå†™ä¸€ä¸ª 8 çš„ç„¶åå¤åˆ¶ç²˜è´´ï¼Œé€‚å½“åˆ å‡å°±å¯ä»¥å¾—åˆ°åˆ«çš„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; trans(int n, int t) { vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; res(3 + t * 2, vector\u0026lt;char\u0026gt;(t + 2, \u0026#39; \u0026#39;)); if (n == 0) { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = res[2 + t * 2][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][0] = res[1 + i][t + 1] = res[2 + t + i][0] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else if (n == 1) { for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][t + 1] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else if (n == 2) { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = res[1 + t][i] = res[2 + t * 2][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][t + 1] = res[2 + t + i][0] = \u0026#39;|\u0026#39;; } } else if (n == 3) { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = res[1 + t][i] = res[2 + t * 2][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][t + 1] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else if (n == 4) { for (int i = 1; i \u0026lt;= t; ++i) { res[1 + t][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][0] = res[1 + i][t + 1] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else if (n == 5) { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = res[1 + t][i] = res[2 + t * 2][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][0] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else if (n == 6) { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = res[1 + t][i] = res[2 + t * 2][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][0] = res[2 + t + i][0] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else if (n == 7) { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][t + 1] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else if (n == 8) { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = res[1 + t][i] = res[2 + t * 2][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][0] = res[1 + i][t + 1] = res[2 + t + i][0] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } else { for (int i = 1; i \u0026lt;= t; ++i) { res[0][i] = res[1 + t][i] = res[2 + t * 2][i] = \u0026#39;-\u0026#39;; } for (int i = 0; i \u0026lt; t; ++i) { res[1 + i][0] = res[1 + i][t + 1] = res[2 + t + i][t + 1] = \u0026#39;|\u0026#39;; } } return res; } void print(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; t) { for (auto i : t) { for (auto j : i) putchar(j); putchar(\u0026#39;\\n\u0026#39;); } } void cat(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;a, vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; b) { for (int i = 0; i \u0026lt; a.size(); ++i) { a[i].push_back(\u0026#39; \u0026#39;); a[i].insert(a[i].end(), b[i].begin(), b[i].end()); } } int main() { int n; char s[10]; while (scanf(\u0026#34;%d%s\u0026#34;, \u0026amp;n, s), n \u0026amp;\u0026amp; s[0] != 0) { auto res = trans(s[0] - 48, n); for (int i = 1; s[i]; ++i) { cat(res, trans(s[i] - 48, n)); } print(res); putchar(\u0026#39;\\n\u0026#39;); } return 0; } ","date":"2025-03-04T11:53:14Z","permalink":"https://invalidnamee.github.io/p/2025st3/","title":"2025æ˜¥è®­ç¬¬ä¸‰åœº"},{"content":"è€ƒåœºä¸Šåªåšå‡ºæ¥äº† Aã€Bã€Cï¼Œæ‹¼å°½å…¨åŠ›æ— æ³•æˆ˜èƒœæ•°å­¦é¢˜ğŸ˜­ğŸ˜­ğŸ˜­ã€‚\nD ä¸€å¼€å§‹æƒ³é”™äº†æ–¹å‘ï¼Œå„ç§åˆ†è§£è´¨å› æ•°æŠŠè‡ªå·±æå¤´ç–¼äº†éƒ½ï¼Œäº‹åæš´åŠ›è½å‡ºæ¥äº†ï¼›E äº‹åæ‰“è¡¨æ‰“äº† 20min ä»¥æƒŠäººçš„æ¯…åŠ›æ‹¿ä¸‹ï¼ˆåˆ«æ€¥ï¼Œè¿˜æœ‰åè½¬ï¼‰ã€‚\nA. çŸ©å½¢ æŠŠä¸‰ä¸ªçŸ©å½¢çš„å·¦ä¸‹è§’åæ ‡å– maxï¼Œå³ä¸Šè§’åæ ‡å– minï¼Œå°±æ˜¯é‡å éƒ¨åˆ†çš„çŸ©å½¢ã€‚\npsï¼šæ³¨æ„åˆ¤æ–­æ˜¯å¦é‡å ï¼Œå¦åˆ™ä¸é‡å çš„å¯èƒ½ä¼šè´Ÿè´Ÿå¾—æ­£ï¼Œç„¶å WA. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); long long x1, y1, x2, y2; long long a1, b1, a2, b2; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; cin \u0026gt;\u0026gt; a1 \u0026gt;\u0026gt; b1 \u0026gt;\u0026gt; a2 \u0026gt;\u0026gt; b2; x1 = max(x1, a1), y1 = max(y1, b1), x2 = min(x2, a2), y2 = min(y2, b2); cin \u0026gt;\u0026gt; a1 \u0026gt;\u0026gt; b1 \u0026gt;\u0026gt; a2 \u0026gt;\u0026gt; b2; x1 = max(x1, a1), y1 = max(y1, b1), x2 = min(x2, a2), y2 = min(y2, b2); if (x2 - x1 \u0026lt;= 0 || y2 - y1 \u0026lt;= 0) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; max(0ll, (x2 - x1) * (y2 - y1)) \u0026lt;\u0026lt; endl; return 0; } è¿™ä¹ˆæ°´çš„é¢˜è¿˜æœ‰äººç”¨ AI å†™ï¼Œè¿˜è¢«æŠ“äº†ğŸ˜².\nB. å…¨çƒé€šå‹¤ æ¯æ¡è¾¹çš„ VIP æ˜¯ç›¸äº’ç‹¬ç«‹çš„ï¼Œç›´æ¥å·®åˆ†å‰ç¼€å’Œç»Ÿè®¡æ¯æ¡è¾¹ç»è¿‡çš„æ¬¡æ•°ï¼Œæœ€åéå†ä¸€æ¬¡ç®—å‡ºæ¥æ¯æ¡è¾¹çš„æœ€ä¼˜è§£åŠ èµ·æ¥å³å¯ã€‚\npsï¼šæ³¨æ„ l å¯èƒ½å¤§äº rï¼Œå¯èƒ½éœ€è¦ swap ä¸€ä¸‹ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 5000010; int a[N], b[N], c[N]; int t[N]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt; n; ++i) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a[i], \u0026amp;b[i], \u0026amp;c[i]); } while (m--) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); if (l \u0026gt; r) swap(l, r); t[l]++, t[r]--; } long long res = 0; for (int i = 1; i \u0026lt; n; ++i) { t[i] += t[i - 1]; res += min(t[i] * a[i], t[i] * c[i] + b[i]); } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } C. ç¤¾äº¤ç½‘ç»œ ä¸èƒ½ç»§ç»­æ‰§è¡Œæ“ä½œçš„æƒ…å†µåªæœ‰ä¸€ç§ï¼Œä»»ä½•ä¸€ä¸ªç‚¹æ‰€åœ¨çš„è¿é€šå—éƒ½æ˜¯å®Œå…¨å›¾ã€‚æ‰€ä»¥ç›´æ¥æ‰¾è¿é€šå—ï¼Œç»Ÿè®¡è¿é€šå—çš„ç‚¹æ•°å’Œè¾¹æ•°ç®—å‡ºæ¯ä¸ªè¿é€šå—çš„æ“ä½œæ¬¡æ•°ç´¯åŠ å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 200010; vector\u0026lt;int\u0026gt; ed[N]; int id[N], tot; int cnt[N], ed_cnt[N]; void dfs(int x) { if (id[x]) return; id[x] = tot; cnt[tot]++; for (int y : ed[x]) { dfs(y); } } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 0; i \u0026lt; m; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); ed[x].push_back(y); ed[y].push_back(x); } for (int i = 1; i \u0026lt;= n; ++i) { sort(ed[i].begin(), ed[i].end()); ed[i].erase(unique(ed[i].begin(), ed[i].end()), ed[i].end()); } for (int i = 1; i \u0026lt;= n; ++i) { if (!id[i]) { ++tot; dfs(i); } } for (int i = 1; i \u0026lt;= n; ++i) { ed_cnt[id[i]] += ed[i].size(); } long long res = 0; for (int i = 1; i \u0026lt;= tot; ++i) { res += (long long)cnt[i] * (cnt[i] - 1) / 2 - ed_cnt[i] / 2; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } D. æ•°æ•° æˆ‘çš„åšæ³•æœ‰ç‚¹æš´åŠ›ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦æ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚\né¦–å…ˆè€ƒè™‘æš´åŠ›å¦‚ä½•è§£å†³ï¼Œç›´æ¥æšä¸¾æŒ‡æ•° i in \\[2, 60\\]ï¼Œåº•æ•° j in \\[1, \\\\(n^{\\frac{1}{i}}\\\\)\\]ï¼ŒæŠŠæ‰€æœ‰ \\(j^i\\)å»é‡ç»Ÿè®¡ä¸ªæ•°ã€‚\nä¸éš¾å‘ç°æš´åŠ›çš„ç“¶é¢ˆåœ¨ \\(\\sqrt{n}\\) ä¸Šï¼Œå¦‚æœ i ä» 3 å¼€å§‹æšä¸¾ï¼Œé‚£ä¹ˆå°±ä¸ä¼š TLEï¼Œæ‰€ä»¥å¹²è„†ç›´æ¥ä» 3 æšä¸¾ï¼Œå¦‚æœ \\(j^i\\)ï¼Œæ˜¯å¹³æ–¹æ•°å°±ç›´æ¥å¿½ç•¥ï¼Œæœ€åä¸€æ¬¡æ€§åŠ è¿›å»ä¸€ä¸ª \\(\\sqrt n\\) å³å¯ã€‚\nn = 1e18 æ—¶æ—¶é—´å¤æ‚åº¦æ˜¯ 1e6 çº§åˆ«çš„ï¼Œ å®Œå…¨å¯è¡Œã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;unordered_set\u0026gt; using namespace std; long long power(long long n, long long p) { long long res = 1, base = n; while (p) { if (p \u0026amp; 1) res = res * base; base = base * base; p \u0026gt;\u0026gt;= 1; } return res; } unordered_set\u0026lt;long long\u0026gt; s; int main() { long long n; cin \u0026gt;\u0026gt; n; for (int i = 60; i \u0026gt;= 3; --i) { for (int j = (long long)pow(n, 1.0 / i); j; --j) { long long t = power(j, i); if (power((int)sqrt(t), 2) != t) s.insert(t); } } cout \u0026lt;\u0026lt; s.size() + (int)(sqrt(n) + 1e-9) \u0026lt;\u0026lt; endl; return 0; } E. å‡ºé¢˜ (problem) æˆ‘èƒ½åŠ›ä¸è¶³ï¼Œæ‰¾ä¸åˆ°é€‰æ‹©ç­–ç•¥ï¼Œåªèƒ½æš´æœäº†ğŸ˜­\n**è¿­ä»£åŠ æ·±ï¼š**å› ä¸ºè¦æ±‚æ–¹æ¡ˆå­—å…¸åºæœ€å°ï¼Œæ‰€ä»¥å¿…é¡»ä¼˜å…ˆæœå°çš„ï¼Œç„¶è€Œä¼˜å…ˆæœå°çš„å¯èƒ½ä¼šå¯¼è‡´é€’å½’å±‚æ•°å¢é•¿è¿‡å¿«çˆ†æ ˆæˆ–è€… TLEï¼Œæ‰€ä»¥ç”¨è¿­ä»£åŠ æ·±ä¸€æ­¥æ­¥è¯•æ¢å¯è¡Œæ€§æ›´é«˜ã€‚\nå‰ªæ1: å½“å‰åºåˆ—æœ€åä¸€ä½å¤§äº n æ—¶ï¼Œç›´æ¥ä¸ç”¨æœäº†ã€‚\nå‰ªæ2: å½“å‰åºåˆ—æœ€åä¸€ä½çš„ 2^cnt å€å°äº n æ—¶ï¼Œä¸€å®šä¸åˆæ³•ï¼Œå³ä½¿ä¸æ–­ç¿»å€ä¹Ÿæ— æ³•åœ¨æŒ‡å®šæ­¥æ•°å†…åˆ°è¾¾ nã€‚ï¼ˆå…¶ä¸­cnt = åç»­ç©ºä½æ•°ï¼‰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int cur[20]; int n; bool dfs(int x, int d) { if (x \u0026gt; d) { if (cur[x - 1] == n) return true; else return false; } if (cur[x - 1] \u0026gt; n || (long long)cur[x - 1] * (1 \u0026lt;\u0026lt; (d - x + 1)) \u0026lt; n) return false; for (int i = 0; i \u0026lt; x; ++i) { for (int j = 0; j \u0026lt;= i; ++j) { if (cur[i] + cur[j] \u0026gt; cur[x - 1]) { cur[x] = cur[i] + cur[j]; if (dfs(x + 1, d)) return true; } } } return false; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int l; cur[0] = 1; for (l = 1; !dfs(1, l); ++l); for (int i = 1; i \u0026lt;= l; ++i) { printf(\u0026#34;%d \u0026#34;, cur[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } WARNINGS ä¸è¦ç”¨ vector é¢‘ç¹ push_back å’Œ pop_backï¼Œä¼šä¸¥é‡è¶…æ—¶ï¼ï¼ï¼å®³æˆ‘æ‰“äº† 20min è¡¨\næ³¨æ„å¸¸æ•°ä¼˜åŒ–ï¼Œèƒ½ç®—ä¸€æ¬¡å°±ä¸ç®—ç¬¬äºŒæ¬¡ï¼Œå¦åˆ™æœç´¢è§„æ¨¡ä¼šæŒ‡æ•°çº§æ‰©å¤§ã€‚\nF. è¿ç»­æ®µ (row) è¿™é“é¢˜ç›®å‰ 0/0ï¼Œæˆ‘é‡åŠ›è€Œä¸ºğŸ’”\n","date":"2025-03-03T14:32:33Z","permalink":"https://invalidnamee.github.io/p/2025st2/","title":"2025æ˜¥è®­ç¬¬äºŒåœº"},{"content":"è€ƒåœºä¸Šåªåšå‡ºæ¥äº† Aã€Bã€Cã€Dï¼Œè€Œä¸” C å’Œ D åšçš„å¾ˆç…ç†¬ï¼ŒE æ˜¯å› ä¸ºçŸ¥è¯†çš„ç¼ºå¤±ï¼ŒF é‚£ä¸€æ¡å…³é”®çš„æ€§è´¨ä¸å¤ªå¥½æƒ³ã€‚\nA. å¥½çš„åºåˆ— ç­¾åˆ°é¢˜ï¼Œæœ€é•¿ä¸Šå‡å­åºåˆ—å˜ä½“ï¼Œä½†æ˜¯å‰ç½®çŠ¶æ€æ˜¯å›ºå®šçš„ï¼Œç›´æ¥å¼€ä¸€ä¸ªæ ‡è®°æ•°ç»„å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int f[100010], a[100010]; int main() { memset(f, -1, sizeof(f)); int n, res = 0; cin \u0026gt;\u0026gt; n; f[0] = 0; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i]; if (f[a[i] - 1] != -1) { f[a[i]] = f[a[i] - 1] + 1; res = max(res, f[a[i]]); } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } B. ä¸€è·¯å‘ä¸Š å¯¹äºæ¯ä¸ªç‚¹å‘æ¯”ä»–é«˜çš„ç‚¹å»ºè¾¹ï¼Œæ‹“æ‰‘æ’åºæ‰¾æœ€é•¿çš„è·¯å¾„å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 1000010; int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, 1, -1}; int ver[N * 4], head[N], ne[N * 4], deg[N], tot; int a[N], f[N]; void add(int x, int y) { ver[++tot] = y; ne[tot] = head[x]; head[x] = tot; deg[y]++; } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[(i - 1) * m + j]); } } for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { for (int k = 0; k \u0026lt; 4; ++k) { int ti = i + dx[k], tj = j + dy[k]; if (ti \u0026gt; 0 \u0026amp;\u0026amp; ti \u0026lt;= n \u0026amp;\u0026amp; tj \u0026gt; 0 \u0026amp;\u0026amp; tj \u0026lt;= m \u0026amp;\u0026amp; a[(i - 1) * m + j] \u0026lt; a[(ti - 1) * m + tj]) { add((i - 1) * m + j, (ti - 1) * m + tj); } } } } queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n * m; ++i) { if (deg[i] == 0) { f[i] = 1; q.push(i); } } int res = 0; while (!q.empty()) { int x = q.front(); q.pop(); res = max(res, f[x]); for (int i = head[x]; i; i = ne[i]) { int y = ver[i]; f[y] = max(f[y], f[x] + 1); if (--deg[y] == 0) q.push(y); } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } C. ç¥ä½¿ æ¯è½®ç¥¨åªå¯èƒ½æŠ•åˆ°æˆ˜åŠ›å€¼æœ€å¤§çš„æˆ–è€…æœ€å°çš„ï¼Œæ‰€ä»¥æŒ‰ç…§ \\(a_i\\) æ’åºï¼Œä¸æ–­æ¯”è¾ƒå¤´å’Œå°¾çš„ç¥¨æ•°è¿›è¡Œæ·˜æ±°ï¼Œç›´åˆ°å‰©ä¸‹æœ€åä¸€ä¸ªã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; const int N = 1000010; pair\u0026lt;int, int\u0026gt; a[N]; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i].first; a[i].second = i; } sort(a + 1, a + n + 1); int h = 1, t = n; while (h \u0026lt; t) { int m = a[h].first + a[t].first \u0026gt;\u0026gt; 1; int l = h, r = t; while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (a[mid].first \u0026lt;= m) l = mid; else r = mid - 1; } if (l - h + 1 \u0026gt;= t - l) t--; else h++; } cout \u0026lt;\u0026lt; a[h].second \u0026lt;\u0026lt; endl; return 0; } D. é¥è¿œçš„å¥¹ \\((x_1,y_1)\\)å’Œ \\((x_2, y_2)\\) ä¹‹é—´äº’ç›¸å¯è¾¾ï¼Œå½“ä¸”ä»…å½“ \\(||x_1 - x_2| - |y_1 - y_2||\\ %\\ 2 = 0\\).\næŠŠåæ ‡ç³»æ—‹è½¬ 45Ëšï¼ˆæˆ‘è¿™é‡Œæ˜¯é¡ºæ—¶é’ˆæ—‹è½¬çš„ï¼‰ï¼ŒæŠŠå•ä½é•¿åº¦è®¾ç½®æˆ \\(\\frac{\\sqrt{2}}{2}\\)ï¼Œæ¯ç»„å†…æŒ‰å…¶ä¸­ä¸€ä¸ªåˆ†é‡æ’åºï¼Œå¦ä¸€ä¸ªåˆ†é‡ç”¨æ•°çŠ¶æ•°ç»„ç»´æŠ¤ï¼Œæœ€åé™¤ä»¥2å³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 200010; pair\u0026lt;long long, long long\u0026gt; f[2][N]; int len[2]; long long tr[N]; int cnt[N], m; void add(int u, long long v) { for (; u \u0026lt;= m; u += u \u0026amp; -u) { tr[u] += v; cnt[u]++; } } int qcnt(int u) { int res = 0; for (; u; u -= u \u0026amp; -u) { res += cnt[u]; } return res; } long long query(int u) { long long res = 0; for (; u; u -= u \u0026amp; -u) { res += tr[u]; } return res; } int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; int t = (x \u0026amp; 1) ^ (y \u0026amp; 1); f[t][++len[t]] = {x, y}; } long long s = 0; for (int t = 0; t \u0026lt; 2; ++t) { m = 0; memset(tr, 0, sizeof(tr)); memset(cnt, 0, sizeof(cnt)); map\u0026lt;int, int\u0026gt; mp; for (int i = 1; i \u0026lt;= len[t]; ++i) { f[t][i] = {f[t][i].first - f[t][i].second, f[t][i].first + f[t][i].second}; mp[f[t][i].second]; } sort(f[t] + 1, f[t] + 1 + len[t]); for (auto \u0026amp;i : mp) i.second = ++m; long long ps = 0; for (int i = 1; i \u0026lt;= len[t]; ++i) { int tt = qcnt(mp[f[t][i].second]); s += f[t][i].first * (i - 1) - ps + f[t][i].second * tt - query(mp[f[t][i].second]) * 2 - f[t][i].second * (i - tt - 1) + query(m); ps += f[t][i].first; add(mp[f[t][i].second], f[t][i].second); } } cout \u0026lt;\u0026lt; s / 2 \u0026lt;\u0026lt; endl; return 0; } E. spongebob è¿™é“é¢˜æ˜¯åæ¥è¡¥çš„ï¼Œæ˜¾ç„¶æœ€åå åŠ å‡ºæ¥çš„å‡½æ•°æ˜¯å•å³°çš„ï¼Œç”¨ä¸‰åˆ†æ±‚å³°å€¼å³å¯ã€‚\néœ€è¦æ³¨æ„ï¼šä¸‰åˆ†çš„ rps åº”è¯¥æ¯”é¢˜ç›®è¦æ±‚çš„å°ï¼Œå› ä¸ºæœ€åçš„æƒ…å†µæœ‰ 3e5 ä¸ª 1e6 å€çš„ x å åŠ ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int N = 300010; int a[N], b[N], n; double sum(double x) { double res = 0; for (int i = 1; i \u0026lt;= n; ++i) { res += fabs(x * a[i] + (double)b[i]); } return res; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[i], \u0026amp;b[i]); } double l = -1e6, r = 1e6; while (r - l \u0026gt; 1e-12) { double mid1 = (l * 2 + r) / 3, mid2 = (l + r * 2) / 3; if (sum(mid1) \u0026gt; sum(mid2)) l = mid1; else r = mid2; } printf(\u0026#34;%lf\\n\u0026#34;, sum((l + r) / 2)); return 0; } F. patrick æ¯ä¸ª h å¯¹åº”çš„ç­”æ¡ˆå¯ä»¥ç”¨æ•°çŠ¶æ•°ç»„æˆ–è€…çº¿æ®µæ ‘åœ¨çº¿ç»´æŠ¤ï¼Œæˆ‘è¿™é‡Œç”¨çš„æ•°çŠ¶æ•°ç»„ã€‚\nè€ƒè™‘æ¯ä¸ªç‚¹å’Œä»–å·¦ä¾§ç‚¹çš„å…³ç³»ï¼Œåˆå§‹åŒ– \\(a_0 = a_{n + 1} = 0\\), å¯¹äºæ¯ä¸ª \\(i \\in [1, n] \\) , è‹¥ \\(a_i \u0026gt; a_{i - 1}\\)ï¼Œæ­¤æ—¶ä¼šåœ¨ \\(h \\in [a_{i - 1} + 1, a_i]\\) æ—¶é¢å¤–äº§ç”Ÿä¸€åº§å²›ï¼Œæ‰€ä»¥æŠŠåŒºé—´å†…çš„ç­”æ¡ˆ +1ã€‚\néœ€è¦ç»´æŠ¤çš„æ“ä½œï¼šåŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢ï¼ˆå¯ä»¥é€šè¿‡å·®åˆ†æ•°ç»„è½¬åŒ–æˆå•ç‚¹ä¿®æ”¹ï¼Œå‰ç¼€å’ŒæŸ¥è¯¢ï¼‰ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 500010; int tr[N], a[N]; void add(int u, int v) { for (; u \u0026lt;= 500000; u += u \u0026amp; -u) { tr[u] += v; } } int query(int u) { int res = 0; for (; u; u -= u \u0026amp; -u) { res += tr[u]; } return res; } int main() { int n, q, last = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); if (a[i] \u0026gt; a[i - 1]) add(a[i - 1] + 1, 1), add(a[i] + 1, -1); } while (q--) { char op[2]; scanf(\u0026#34;%s\u0026#34;, op); if (op[0] == \u0026#39;Q\u0026#39;) { int c; scanf(\u0026#34;%d\u0026#34;, \u0026amp;c); c ^= last; printf(\u0026#34;%d\\n\u0026#34;, last = query(c)); } else { int p, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;p, \u0026amp;v); p ^= last, v ^= last; if (a[p] \u0026gt; a[p - 1]) add(a[p - 1] + 1, -1), add(a[p] + 1, 1); if (a[p + 1] \u0026gt; a[p]) add(a[p] + 1, -1), add(a[p + 1] + 1, 1); a[p] = v; if (a[p] \u0026gt; a[p - 1]) add(a[p - 1] + 1, 1), add(a[p] + 1, -1); if (a[p + 1] \u0026gt; a[p]) add(a[p] + 1, 1), add(a[p + 1] + 1, -1); } } return 0; } ","date":"2025-03-03T04:49:54Z","permalink":"https://invalidnamee.github.io/p/2025st1/","title":"2025æ˜¥è®­ç¬¬ä¸€åœº"},{"content":"åº” ğŸ¸ çš„å»ºè®®ï¼Œä¸èƒ½å…‰åŸ‹å¤´åˆ·é¢˜ï¼Œè¿˜åº”è¯¥ æ°´æ°´åšå®¢ å†™å†™é¢˜è§£ï¼Œæ‰€ä»¥åç»­ä¼šæ—¶ä¸æ—¶æ›´æ–°è®­ç»ƒèµ›å’Œ CSES Problem Set éƒ¨åˆ†**æˆ‘ä¼šçš„**é¢˜çš„é¢˜è§£ã€‚\næˆ‘ä¸ªäººç½‘ç»œé¢„é€‰èµ›æ‰“çš„è¿˜æ˜¯æŒºé¡ºåˆ©çš„ï¼Œè™½ç„¶æ¦œä¸€å·®ç‚¹è¢«æŠ¢äº†ã€‚ å¤§éƒ¨åˆ†é¢˜éƒ½æ˜¯éå¸¸åŸºç¡€çš„ç­¾åˆ°é¢˜éš¾åº¦çš„é¢˜ï¼Œä¸»è¦å¯èƒ½æ˜¯æœ‰çš„é¢˜æ¯”è¾ƒé˜´é—´ï¼Œè¿™ç§éš¾åº¦åº”è¯¥ä¹Ÿä¸æ€ä¹ˆç”¨çœ‹ä»£ç å§ï¼Œç»å¯¹ä¸æ˜¯æ‰“çš„æ—¶å€™ç€æ€¥èµ¶æ—¶é—´å°±æ²¡å­˜ä»£ç ã€‚\nA. ACM å¸¸è¯†é—®ç­” è¿™**â€å¸¸è¯†â€**åæ­£æˆ‘æ˜¯ä¸çŸ¥é“ï¼Œç”¨ python éšæœºäº†ä¸ƒåå¤šæ¬¡ç­”æ¡ˆæœªæœã€‚\nB. å‰²åœ†æœ¯ çœŸæ­£çš„ç­¾åˆ°é¢˜ï¼Œåªéœ€è¦æ³¨æ„å¼€ long longï¼Œæˆ–è€…ç”¨ python å°±è¡Œã€‚\nC. å¤§å° ç­¾åˆ°é¢˜ï¼Œç›´æ¥ if-else å°±è¡Œ\nD. å­åºåˆ— ç»´æŠ¤å‰ç¼€å’Œæ•°ç»„sï¼Œå¯¹æ¯ä¸€ä¸ªä½ç½®iï¼ŒäºŒåˆ†æŸ¥æ‰¾ 0 ~ i - 1 ä¸­ç¬¬ä¸€ä¸ª â‰¤ s\n\\[i\\] - k ä½ç½®ï¼ŒåŠ èµ·æ¥å°±æ˜¯ç­”æ¡ˆï¼ŒäºŒåˆ†å¯ä»¥ç›´æ¥ç”¨ upper_boundã€‚\nE. ç¥ç§˜å’’ç¬¦ ç­¾åˆ°é¢˜ï¼Œéå†å­—ç¬¦ä¸²æŒ¨ä¸ªæ¯”è¾ƒå°±è¡Œï¼Œ\nF. æ²¹ä¸“ä¸² ç•¥å¾®æœ‰ç‚¹é˜´é—´çš„ç­¾åˆ°é¢˜ (æˆ‘ç»å¯¹æ²¡æœ‰ 3 tries)ï¼Œæ³¨æ„å­—ç¬¦ä¸²é‡Œæœ‰ç©ºæ ¼å’Œä¸åˆæ³•çš„æ•°æ®ï¼Œå¤šåŠ ä¸€æ­¥åˆ¤æ–­æ˜¯å¦æ•´ä¸ªä¸²éƒ½æ˜¯å¤§å†™å­—æ¯å³å¯ã€‚\nG. æµ·äººçš„æ•°å­¦é¢˜1 åˆ©ç”¨å·®åˆ†çš„æ€æƒ³å’Œå®¹æ–¥åŸç†ï¼Œè®¾ f(x) = x - (x / div1 + x / div2 - x / æœ€å°å…¬å€æ•°(div1, div2))ï¼Œç­”æ¡ˆæ˜¯ f(number2) - f(number1 - 1) ã€‚\nH. è¿™æ˜¯ç­¾åˆ°é¢˜å— è¿™ä¸æ˜¯ ğŸ˜­ï¼ˆè¶…å¤§å£°ï¼‰\næ‹¼å°½å…¨åŠ›æ²¡æœ‰çœ‹æ‡‚é¢˜ï¼Œçœ‹æ¦œäºŒå·²ç»å¼€æ‘†äº†ï¼Œæˆ‘ä¹Ÿä¸æƒ³çœ‹äº†ã€‚\nI. ç´Šä¹±çš„é™è„‰ æ¯æ¬¡æ“ä½œéƒ½ä¼šå¢åŠ 2ï¼Œæ‰€ä»¥ç­”æ¡ˆæ˜¯ min(åŸæ¥çš„é€šç•…ä¸ªæ•° + 2 * k, n - 1)ã€‚\nps : è¿™é“æ˜¯æœ€åä¸€ä¸ªå†™çš„ï¼Œæ‰€ä»¥æœ‰ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); int n, m, t = 0; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; cin \u0026gt;\u0026gt; s; s = \u0026#34; \u0026#34; + s + \u0026#34; \u0026#34;; for (int i = 1; i \u0026lt;= n; ++i) { if (s[i] == \u0026#39;L\u0026#39; \u0026amp;\u0026amp; s[i - 1] == \u0026#39;L\u0026#39;) t++; else if (s[i] == \u0026#39;R\u0026#39; \u0026amp;\u0026amp; s[i + 1] == \u0026#39;R\u0026#39;) t++; } cout \u0026lt;\u0026lt; min(n - 1, t + m * 2) \u0026lt;\u0026lt; endl; return 0; } K. å¡ç‰Œæ¸¸æˆ ç›´æ¥ nÂ² æŒ¨ä¸ªè¯•å°±è¡Œäº†ã€‚\nL. é­”æ³• å¦‚æœ R - L + 1 â‰¥ 2025 é‚£è‚¯å®šä¼šæœ‰ä¸€ä¸ª i èƒ½è®© i mod 2025 å–åˆ° 0ï¼Œæ‰€ä»¥ç­”æ¡ˆæ˜¯ 0ï¼›\nå¦åˆ™ä¸€å…±å°±ä¸¤åƒå¤šä¸ªæ•°ï¼ŒæŒ¨ä¸ªè¯•å°±è¡Œã€‚\nM. æµ·äººçš„æ•°å­¦é¢˜2 ç›´æ¥æš´åŠ›å°±è¡Œï¼Œå…ˆç®—æ€»å’Œï¼Œç„¶åéå†æ•°ç»„ï¼Œä¸€ç›´ res = min(res, abs((æ€»å’Œ - å‰ç¼€å’Œ) - å‰ç¼€å’Œ))ã€‚\n","date":"2025-03-02T15:09:48Z","permalink":"https://invalidnamee.github.io/p/5asx6liq5lq65yj5zue5b2s/","title":"å¤±è¸ªäººå£å›å½’"},{"content":"0.é¢˜ç›®æè¿° é¢˜é¢: é“¾æ¥\nå¤§è‡´æ„æ€æ˜¯æœ‰ \\(B\\) ä¸ªæ–¹æ¡ˆå’Œ \\(M\\) ä¸ªäººï¼Œæ¯ä¸ªäººå¯ä»¥å¯¹ \\(k(k \\le 4)\\) ä¸ªæ–¹æ¡ˆæŠ•ç¥¨ï¼Œæ¯ä¸€ç¥¨è¦ä¹ˆæ”¯æŒè¦ä¹ˆåå¯¹ã€‚æ¯ä¸ªäººæ»¡æ„å½“ä¸”ä»…å½“ä»–ä¸€åŠä»¥ä¸Šçš„æŠ•ç¥¨è¢«æ»¡è¶³ï¼Œé—®æ¯ä¸ªæ–¹æ¡ˆåº”é€šè¿‡ ( y ) è¿˜æ˜¯å¦å†³ ( n )ï¼Œæˆ–è€…æ—¢å¯ä»¥é€šè¿‡ä¹Ÿå¯ä»¥å¦å†³ ( ? )ï¼Œæ‰èƒ½ä½¿å¾—æ¯ä¸€ä¸ªäººå¯¹æœ€ç»ˆçš„ç»“æœæ»¡æ„ã€‚å¦‚æœä¸å­˜åœ¨ä¸€ç§ä½¿å¾—æ‰€æœ‰äººæ»¡æ„çš„ç»“æœï¼Œè¾“å‡º impossible ã€‚\n1.åˆ†æ + ä»£ç  å¯¹äºæ¯ä¸€ä¸ªæ–¹æ¡ˆåªæœ‰é€šè¿‡å’Œå¦å†³ä¸¤ç§çŠ¶æ€ï¼Œæ¯ä¸€ä¸ªäººçš„æŠ•ç¥¨ç›¸å½“äºæ˜¯é™åˆ¶æ¡ä»¶ï¼Œè¿™é“é¢˜æ˜æ˜¾æ˜¯ä¸€ä¸ª 2-SAT çš„é—®é¢˜ã€‚\n1.1 å»ºè¾¹ å°†æ¯ä¸ªæ–¹æ¡ˆæ‹†æˆä¸¤ä¸ªç‚¹ true å’Œ falseï¼Œåˆ†åˆ«è¡¨ç¤ºé€šè¿‡å’Œå¦å†³ï¼Œç„¶åè€ƒè™‘é™åˆ¶æ¡ä»¶ã€‚\nç”±äº \\(k\\) çš„èŒƒå›´å¾ˆå°ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹ \\(k\\) çš„å–å€¼è¿›è¡Œåˆ†ç±»è®¨è®ºã€‚\n\\( k \\le 2\\)\n\\(k = 1\\) æ—¶éœ€æ»¡è¶³çš„ç¥¨æ•°å¤§äº \\(0.5\\)ï¼Œå³ \\(1\\) ï¼Œ \\(k = 2\\) æ—¶éœ€æ»¡è¶³çš„ç¥¨æ•°å¤§äº \\(1\\) ï¼Œå³ \\(2\\) ã€‚\næ‰€ä»¥å¦‚æœä¸€ä¸ªäººçš„ \\(k\\) æ»¡è¶³ \\(k \\le 2\\) ï¼Œä»–æŠ•çš„æ‰€æœ‰ç¥¨éƒ½å°†å¾—åˆ°æ»¡è¶³ã€‚\nè½¬æ¢åˆ°å›¾ä¸Šå°±æ˜¯å°†ç›¸åº”çš„æ–¹æ¡ˆçš„ç›¸åç»“æœå‘å…¶æŠ•ç¥¨çš„ç»“æœå»ºä¸€æ¡è¾¹ï¼Œè¿™æ ·æŠ•ç¥¨å°±å¿…é¡»è¢«æ»¡è¶³ã€‚\n\\(3 \\le k \\le 4\\)\n\\(k = 3\\) æ—¶éœ€æ»¡è¶³çš„ç¥¨æ•°å¤§äº \\(1.5\\) ï¼Œå³ \\(2\\) æˆ– \\(3\\) ï¼Œ \\(k = 4\\) æ—¶éœ€æ»¡è¶³çš„ç¥¨æ•°å¤§äº \\(2\\) ï¼Œå³ \\(3\\) æˆ– \\(4\\) ã€‚\næ‰€ä»¥å¦‚æœä¸€ä¸ªäººçš„ \\(k\\) æ»¡è¶³ \\(3 \\le k \\le 4\\)ï¼Œä»–æŠ•çš„ç¥¨è‡³å¤šæœ‰ä¸€ä¸ªå¾—ä¸åˆ°æ»¡è¶³ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæœ‰ä¸€ç¥¨å¾—ä¸åˆ°æ»¡è¶³ï¼Œé‚£ä¹ˆå…¶ä»–æ‰€æœ‰çš„ç¥¨å°±å¿…é¡»å…¨éƒ¨æ»¡è¶³ã€‚\nè½¬æ¢åˆ°å›¾ä¸Šå°±æ˜¯å°†æ¯ä¸€ç¥¨çš„ç›¸åçš„ç»“æœå‘å…¶ä½™æ‰€æœ‰ç¥¨çš„ç»“æœåˆ†åˆ«å»ºä¸€æ¡è¾¹ã€‚\nä¸ºäº†æ–¹ä¾¿å¤„ç†å„ç§çŠ¶æ€ï¼Œå¯ä»¥å†™ä¸€ä¸ªå‡½æ•°å¯¼å‡ºç›¸åº”ç‚¹çš„ä¸‹æ ‡ã€‚\n1 2 3 4 // 1~n ä¸º false(å¦å†³) n + 1 ~ 2n ä¸º true(é€šè¿‡) int f(bool op, int p) { return p + op * n; // opä¸ºæ ‡è®°ï¼Œé€šè¿‡ä¸ºtrueï¼Œå¦å†³ä¸ºfalse } å»ºè¾¹éƒ¨åˆ†ä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct Query { bool op; int p; } q[4]; // å­˜æŠ•ç¥¨æƒ…å†µ bool ed[N][N]; // é‚»æ¥çŸ©é˜µ // ...main... if (k \u0026lt;= 2) { // å…¨éƒ¨é€šè¿‡ for (int j = 0; j \u0026lt; k; ++j) { ed[f(!q[j].op, q[j].p)][f(q[j].op, q[j].p)] = true; } } else { // å¦‚æœç¬¬jä¸ªè¢«å¦å†³ï¼Œå…¶ä½™(k - 1)ä¸ªå¿…é¡»é€šè¿‡ for (int j = 0; j \u0026lt; k; ++j) { for (int l = 0; l \u0026lt; k; ++l) { if (j == l) continue; ed[f(!q[j].op, q[j].p)][f(q[l].op, q[l].p)] = true; } } } 1.2 è¾“å‡ºæ–¹æ¡ˆ å¦‚æœåªè¾“å‡ºä¸€ç§å¯è¡Œæ–¹æ¡ˆï¼Œé‚£ä¹ˆå¾ˆç®€å•ï¼Œå–æ¯ä¸ªæ–¹æ¡ˆçš„ true ç‚¹å’Œ false ç‚¹ä¸­æ‹“æ‰‘åºè¾ƒå¤§çš„å³å¯ã€‚\nä¸€ç§å¯è¡Œçš„æ–¹æ¡ˆæ˜¯ç›´æ¥åœ¨å›¾ä¸Šè·‘ä¸€é tarjan æ±‚å‡ºæ¯ä¸ªç‚¹æ‰€åœ¨çš„å¼ºè¿é€šåˆ†é‡çš„ç¼–å·ï¼Œ è¾“å‡ºæ‰€åœ¨å¼ºè¿é€šåˆ†é‡çš„ç¼–å·è¾ƒå°çš„å³å¯ï¼ˆ tarjan å¾—åˆ°çš„ç¼–å·çš„é¡ºåºæ˜¯æ‹“æ‰‘é€†åºï¼‰ã€‚\nä½†æ˜¯è¿™é“é¢˜å­˜åœ¨ä¸€ä¸ª ? çš„æƒ…å†µï¼Œè¡¨ç¤ºé€‰ true å’Œ false å‡å¯è¡Œï¼Œæ˜æ˜¾ä¸Šé¢è¿™ä¸ªæ–¹æ³•æ— æ³•è§£å†³ï¼Œè€ƒè™‘ä¸€ä¸‹å…¶ä»–æ€æƒ³ã€‚\n1.2.1 æšä¸¾ å¯ä»¥è€ƒè™‘å…ˆè·‘ä¸€é tarjan å¾—åˆ°ä¸€ç»„å¯è¡Œè§£ç„¶åä¾æ¬¡éªŒè¯æ¯ä¸€ä¸ªæ–¹æ¡ˆæ˜¯å¦å¯ä»¥å–åï¼Œå¦‚æœå¯ä»¥å°±æ”¹æˆ ? ï¼Œå¤§è‡´æµç¨‹å¦‚ä¸‹ï¼š\nè·‘ä¸€é tarjan å¾—åˆ°ä¸€ç»„å¯è¡Œè§£ã€‚ éå†å¯è¡Œè§£çš„æ¯ä¸€ä¸ªä½ç½®ã€‚ å¯¹äºæ¯ä¸€ä¸ªä½ç½®ï¼Œä¸´æ—¶å»ºä¸€æ¡åå‘çš„è¾¹ï¼Œé™åˆ¶è¯¥ä½ç½®å¿…é¡»é€‰ç›¸åçš„ç»“æœã€‚ å†è·‘ä¸€é tarjanï¼ŒéªŒè¯æ˜¯å¦ä»ç„¶å¯è¡Œã€‚ å¦‚æœå¯è¡Œï¼Œæ”¹ä¸º ? ï¼Œ å¦åˆ™ä¸å˜ã€‚ åˆ æ‰ä¸´æ—¶è¾¹ï¼Œç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªä½ç½®ã€‚ è·‘å®Œä¸€è½®åï¼Œå°±å¯ä»¥å¾—åˆ°ç­”æ¡ˆï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ \\(O(n ^ 3)\\)(é‚»æ¥çŸ©é˜µ)ã€‚\nå‚è€ƒä»£ç \n1.2.2 ä¼ é€’é—­åŒ…ï¼ˆFloydæ±‚å›¾çš„è¿é€šæ€§ï¼‰ è¿›ä¸€æ­¥æ€è€ƒï¼Œè®¾ä¸€ä¸ªä¸‹æ ‡ä¸º \\(p\\) æ–¹æ¡ˆ true ç‚¹ä¸º \\(p + n\\) ï¼Œfalse ç‚¹ä¸º \\(p\\) ã€‚\nè‹¥ \\(p\\) èƒ½èµ°åˆ° \\(p + n\\) ä¸” \\(p + n\\) ä¸èƒ½èµ°åˆ° \\(p\\) ï¼Œé‚£ä¹ˆè¿™ä¸ªæ–¹æ¡ˆåªèƒ½ä¸º true ã€‚ è‹¥ \\(p + n\\) èƒ½èµ°åˆ° \\(p\\) ä¸” \\(p\\) ä¸èƒ½èµ°åˆ° \\(p + n\\) ï¼Œé‚£ä¹ˆè¿™ä¸ªæ–¹æ¡ˆåªèƒ½ä¸º false ã€‚ è‹¥ \\(p\\) ä¸èƒ½èµ°åˆ° \\(p + n\\) ä¸” \\(p + n\\) ä¸èƒ½èµ°åˆ° \\(p\\) ï¼Œé‚£ä¹ˆè¿™ä¸ªæ–¹æ¡ˆå¯ä»¥ä¸º true ä¹Ÿå¯ä»¥ä¸º false ï¼Œå³é¢˜ä¸­ ? ã€‚ è‹¥ \\(p\\) èƒ½èµ°åˆ° \\(p + n\\) ä¸” \\(p + n\\) èƒ½èµ°åˆ° \\(p\\) ï¼Œé‚£ä¹ˆè¿™ä¸ªæ–¹æ¡ˆæ—¢ä¸å¯ä»¥ä¸º true ä¹Ÿä¸å¯ä»¥ä¸º false ï¼Œå³ impossible ã€‚ æ‰€ä»¥ç›´æ¥å¯¹å»ºå¥½çš„å›¾è·‘ä¸€éä¼ é€’é—­åŒ…å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¹Ÿæ˜¯ \\(O(n ^ 3)\\) ï¼Œä½†ç”±äºä¸èƒ½å¿«é€Ÿåˆ¤æ–­æ˜¯å¦å¯è¡Œï¼Œæ‰€ä»¥æ•´ä½“é€Ÿåº¦æ¯” tarjan æ…¢å¾ˆå¤šï¼Œä½†æ˜¯ä»£ç çŸ­å‘€ã€‚\n1 2 3 4 5 6 7 8 for (int k = 1; k \u0026lt;= n * 2; ++k) { for (int i = 1; i \u0026lt;= n * 2; ++i) { for (int j = 1; j \u0026lt;= n * 2; ++j) { if (i == j) continue; else ed[i][j] |= ed[i][k] \u0026amp; ed[k][j]; // iä¸kè¿é€šä¸”kä¸jè¿é€šåˆ™iä¸jè¿é€š } } } Ac Code ä¼ é€’é—­åŒ…åªæœ‰ 82 è¡Œï¼Œå¾ˆæ¸…çˆ½ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 210; struct Query { bool op; // trueä¸ºé€šè¿‡, falseä¸ºå¦å†³ int p; // ç›¸åº”æ–¹æ¡ˆçš„ä¸‹æ ‡ } q[4]; // å­˜æŠ•ç¥¨æƒ…å†µ bool ed[N][N]; // é‚»æ¥çŸ©é˜µ char ans[N]; // å­˜ç­”æ¡ˆ int n, m; // 1~n ä¸º false(å¦å†³) n + 1 ~ 2n ä¸º true(é€šè¿‡) int f(bool op, int p) { return p + op * n; // opä¸ºæ ‡è®°ï¼Œé€šè¿‡ä¸ºtrueï¼Œå¦å†³ä¸ºfalse } int main() { int T = 0; while (scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m), n \u0026amp;\u0026amp; m) { T++; // è®°å¾—åˆå§‹åŒ– memset(ed, 0, sizeof(ed)); memset(ans, 0, sizeof(ans)); for (int i = 1; i \u0026lt;= m; ++i) { int k; scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); for (int j = 0; j \u0026lt; k; ++j) { char s[2]; scanf(\u0026#34;%d%s\u0026#34;, \u0026amp;q[j].p, s); q[j].op = (s[0] == \u0026#39;y\u0026#39;); } if (k \u0026lt;= 2) { // å…¨éƒ¨é€šè¿‡ for (int j = 0; j \u0026lt; k; ++j) { ed[f(!q[j].op, q[j].p)][f(q[j].op, q[j].p)] = true; } } else { // å¦‚æœç¬¬jä¸ªè¢«å¦å†³ï¼Œå…¶ä½™(k - 1)ä¸ªå¿…é¡»é€šè¿‡ for (int j = 0; j \u0026lt; k; ++j) { for (int l = 0; l \u0026lt; k; ++l) { if (j == l) continue; ed[f(!q[j].op, q[j].p)][f(q[l].op, q[l].p)] = true; } } } } // ä¼ é€’é—­åŒ… for (int k = 1; k \u0026lt;= n * 2; ++k) { for (int i = 1; i \u0026lt;= n * 2; ++i) { for (int j = 1; j \u0026lt;= n * 2; ++j) { if (i == j) continue; else ed[i][j] |= ed[i][k] \u0026amp; ed[k][j]; } } } bool valid = true; for (int i = 1; i \u0026lt;= n; ++i) { if (ed[i][i + n] \u0026amp;\u0026amp; ed[i + n][i]) { // impossible valid = false; break; } else if (!ed[i][i + n] \u0026amp;\u0026amp; !ed[i + n][i]) ans[i] = \u0026#39;?\u0026#39;; else if (ed[i][i + n]) ans[i] = \u0026#39;y\u0026#39;; else ans[i] = \u0026#39;n\u0026#39;; } printf(\u0026#34;Case %d: \u0026#34;, T); // æŸæ†¨æ†¨ç”±äºæ²¡è¾“å‡ºCaseè°ƒäº†åŠå¤© if (valid) for (int i = 1; i \u0026lt;= n; ++i) { putchar(ans[i]); } else printf(\u0026#34;impossible\u0026#34;); printf(\u0026#34;\\n\u0026#34;); } return 0; } ","date":"2022-09-19T12:05:49Z","permalink":"https://invalidnamee.github.io/p/uva1086-the-ministers-major-mess/","title":"UVA1086 The Ministers' Major Mess"},{"content":" å‰æ’æ„Ÿè°¢è„šæœ¬å¼€å‘è€…è½¯ä»¶å°å¦¹ï¼Œç»™äº†æˆ‘ä»¬ç™½å«–çš„æœºä¼š\nTempermonkey å…ˆå¼„æ²¹çŒ´è„šæœ¬ï¼Œå»æµè§ˆå™¨çš„æ‰©å±•ç¨‹åºå•†åº—å®‰è£… Tempermonkey (æˆ‘å·²ç»è£…äº†ï¼Œæ‰€ä»¥æ˜¯åˆ é™¤)ï¼Œæ³¨æ„ chrome çš„å•†åº—éœ€è¦ç§‘å­¦ä¸Šç½‘\nå®‰è£…è¿™ä¸ªè„šæœ¬ ç™¾åº¦ç½‘ç›˜ç®€æ˜“ä¸‹è½½åŠ©æ‰‹ï¼ˆç›´é“¾ä¸‹è½½å¤æ´»ç‰ˆï¼‰ (greasyfork.org)\nè„šæœ¬å°±è§£å†³äº†\nIDM å»ºè®®æ”¯æŒæ­£ç‰ˆã€‚\né…ç½® æ‰“å¼€ IDMï¼Œæ‰“å¼€é€‰é¡¹\næŠŠ UA æ”¹æˆ netdisk;3.0.0.112\nä½¿ç”¨ å…ˆæŠŠä¸œè¥¿å­˜åˆ°è‡ªå·±çš„ç½‘ç›˜é‡Œï¼Œç„¶åé€‰æ‹©è¦ä¸‹è½½çš„æ–‡ä»¶ï¼Œç‚¹ç®€æ˜“ä¸‹è½½åŠ©æ‰‹ï¼Œè¿™é‡Œä»¥vmwareä¸ºä¾‹\nç‚¹å‡»è·å–ç›´é“¾åœ°å€ï¼Œæœ‰æ—¶å€™éœ€è¦éªŒè¯ç ï¼Œå…³æ³¨ä¸€ä¸‹å…¬ä¼—å·å³å¯\nIDMé€‰æ‹©æ–°å»ºä»»åŠ¡ï¼ŒæŠŠé“¾æ¥ç²˜è´´è¿›å»å³å¯\nlinuxç”¨æˆ·å’Œmacç”¨æˆ·å¯ä»¥ç”¨Aria2ï¼Œlinuxå¯ä»¥ç”¨aria-ng-guiï¼Œmacå¯ä»¥ç”¨Aria2GUIï¼Œä¸‹è½½çš„æ—¶å€™æŒ‰å‘é€åˆ°Aria2å³å¯ã€‚\n","date":"2022-08-30T09:14:00Z","permalink":"https://invalidnamee.github.io/p/55m5bqm572r55uy5lin6zmq6ycf/","title":"ç™¾åº¦ç½‘ç›˜ä¸é™é€Ÿ"},{"content":" è¿™ä¸ªæ¯”é»˜è®¤çš„ ibus å¥½ç”¨å¾ˆå¤šï¼Œä¸¤ä¸ªè¾“å…¥æ³•å¯èƒ½æœ‰æ’æ–¥ï¼Œå¦‚æœå®‰è£…è¿‡ç¨‹ä¸­æŠ¥é”™ï¼Œå¯ä»¥è¯•è¯•æŠŠ ibus å¸äº†\n1 sudo apt purge ibus å®˜ç½‘ : https://shurufa.sogou.com/linux\nç„¶åå¯ä»¥æŒ‰ç…§å®˜ç½‘çš„æ•™ç¨‹å¼„\nä¸æƒ³çœ‹çš„å¯ä»¥çœ‹æˆ‘çš„\nå…ˆæ¢ä¸ªä¸­å›½çš„æº (å¯ä»¥è®©ä¸‹è½½å®‰è£…çš„å‘½ä»¤æ›´å¿«ä¸€ç‚¹)\n1 sudo gedit /etc/apt/sources.list å…¨éƒ¨åˆ æ‰æ¢æˆåä¸ºçš„\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 # deb cdrom:[Ubuntu 20.04.1 LTS _Focal Fossa_ - Release amd64 (20200731)]/ focal main restricted # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal main restricted # deb-src http://us.archive.ubuntu.com/ubuntu/ focal main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal-updates main restricted # deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team. Also, please note that software in universe WILL NOT receive any ## review or updates from the Ubuntu security team. deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal universe # deb-src http://us.archive.ubuntu.com/ubuntu/ focal universe deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal-updates universe # deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates universe ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## multiverse WILL NOT receive any review or updates from the Ubuntu ## security team. deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal multiverse # deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal-updates multiverse # deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse ## N.B. software from this repository may not have been tested as ## extensively as that contained in the main release, although it includes ## newer versions of some applications which may provide useful features. ## Also, please note that software in backports WILL NOT receive any review ## or updates from the Ubuntu security team. deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal-backports main restricted universe multiverse # deb-src http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse ## Uncomment the following two lines to add software from Canonical\u0026#39;s ## \u0026#39;partner\u0026#39; repository. ## This software is not part of Ubuntu, but is offered by Canonical and the ## respective vendors as a service to Ubuntu users. # deb http://archive.canonical.com/ubuntu focal partner # deb-src http://archive.canonical.com/ubuntu focal partner deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal-security main restricted # deb-src http://security.ubuntu.com/ubuntu focal-security main restricted deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal-security universe # deb-src http://security.ubuntu.com/ubuntu focal-security universe deb http://mirrors.huaweicloud.com/repository/ubuntu/ focal-security multiverse # deb-src http://security.ubuntu.com/ubuntu focal-security multiverse # This system was installed using small removable media # (e.g. netinst, live or single CD). The matching \u0026#34;deb cdrom\u0026#34; # entries were disabled at the end of the installation process. # For information about how to configure apt package sources, # see the sources.list(5) manual. ç„¶å\n1 sudo apt update è£… fcitx\n1 sudo apt install fcitx é…ç½®ä¸€ä¸‹ fcitx\næ‰¾åˆ° language support (è¯­è¨€æ”¯æŒ)\næŠŠè¾“å…¥æ³•æ”¹æˆ fcitx\næ³¨é”€ä¸€æ¬¡\nå®‰è£…æœç‹—è¾“å…¥æ³•çš„åŒ…\n1 2 3 4 5 6 # è¿›å…¥ä¸‹è½½åŒ…çš„ç›®å½•ï¼Œé»˜è®¤æ˜¯åœ¨~/Downloads cd ~/Downloads # å¦‚æœæ˜¯è‹±æ–‡ç³»ç»Ÿ cd ~/ä¸‹è½½ # å¦‚æœæ˜¯ä¸­æ–‡ç³»ç»Ÿ # å®‰è£… sudo dpkg -i sogoupinyin_4.0.1.2800_x86_64.deb # è¾“å…¥ä¸€ä¸ªsogouç„¶åtabä¸€ä¸‹å°±å‡ºæ¥äº†ï¼Œç‰ˆæœ¬å·å¯èƒ½ä¸ä¸€æ ·è¯·å‹¿å¤åˆ¶ å®‰è£…ä¾èµ–\n1 2 sudo apt install libqt5qml5 libqt5quick5 libqt5quickwidgets5 qml-module-qtquick2 sudo apt install libgsettings-qt1 å¯ç”¨\næ‰“å¼€ fcitx çš„è®¾ç½®\nå¦‚æœæ²¡æœ‰ sogoupinyin çš„è¯å°±ç‚¹åä¸‹è§’çš„åŠ å·æœç´¢ sogoupinyin åŠ ä¸Šå°±å¯ä»¥äº†\nå¦‚æœæ— è®ºå¦‚ä½•éƒ½æ²¡æœ‰ï¼Œå»ºè®®æ³¨é”€ä¸€æ¬¡å†è¯•\nFinished\nå¯ä»¥ Ctrl + Space åˆ‡æ¢è¾“å…¥æ³•\n","date":"2022-08-30T08:53:49Z","permalink":"https://invalidnamee.github.io/p/for-linux/","title":"æœç‹—è¾“å…¥æ³• for Linux"},{"content":"0.å‰ç½®è¯´æ˜ WSLæ˜¯ä»€ä¹ˆï¼Œä»¥ä¸‹å®šä¹‰æ¥è‡ªç™¾åº¦ç™¾ç§‘\nWindows Subsystem for Linuxï¼ˆç®€ç§°WSLï¼‰æ˜¯ä¸€ä¸ªåœ¨Windows 10ä¸Šèƒ½å¤Ÿè¿è¡ŒåŸç”ŸLinuxäºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶ä¸Canonicalå…¬å¸åˆä½œå¼€å‘ï¼Œå…¶ç›®æ ‡æ˜¯ä½¿çº¯æ­£çš„Ubuntuã€Debianç­‰æ˜ åƒèƒ½ä¸‹è½½å’Œè§£å‹åˆ°ç”¨æˆ·çš„æœ¬åœ°è®¡ç®—æœºï¼Œå¹¶ä¸”æ˜ åƒå†…çš„å·¥å…·å’Œå®ç”¨å·¥å…·èƒ½åœ¨æ­¤å­ç³»ç»Ÿä¸ŠåŸç”Ÿè¿è¡Œã€‚\n1.æŠ˜è…¾ç¼˜ç”± ä¼—æ‰€å‘¨çŸ¥ï¼Œä¸Šå‘¨æœ‰ä¸€é“å›¾è®ºé¢˜åœ¨winä¸Šè·‘å°±REï¼Œåˆ°linuxä¸Šè·‘å°±å¯æ­£å¸¸è¿è¡Œï¼Œå¯¼è‡´æˆ‘è°ƒäº†åŠå¤©æ„Ÿè§‰è‡ªå·±æ²¡é—®é¢˜ä½†æ˜¯æœç´¢æ•°æ®å°±æ˜¯çˆ†ï¼Œæ°”æ€¥è´¥åï¼Œç›´æ¥äº¤äº†ä¸€ä»½ç„¶å\u0026hellip; ç«Ÿç„¶Aäº†ï¼Œæˆ‘ç«‹åˆ»é‡å¯å»æˆ‘çš„linuxé‡Œè·‘äº†ä¸€éï¼Œç¡®å®æ²¡é—®é¢˜ï¼Œäºæ˜¯æˆ‘åˆè¯·yzyåœ¨ä»–çš„ç”µè„‘ä¸Šè·‘äº†ä¸€éï¼Œå‘ç°ä¹Ÿç‚¸äº†ã€‚\nåæ¥å¬Laffeyè§£é‡Šä¹‹åæ‰çŸ¥é“ï¼Œå› ä¸ºwinçš„ç³»ç»Ÿæ ˆé»˜è®¤å¥½åƒåªæœ‰ 1MBï¼Œæ•°æ®å¤ªå¤§ç›´æ¥æŠŠç«™çˆ†äº†ï¼Œç„¶è€Œlinuxå°±æ²¡äº‹ã€‚ç”±äºè¯¸å¤šåŸå› ï¼Œæ—¥å¸¸çš„ä½¿ç”¨å¹¶ç¦»ä¸å¼€windowsï¼Œæˆ‘åˆæ²¡æ³•æ¯æ¬¡éƒ½å»linuxè·‘ä»£ç ï¼Œäºæ˜¯æˆ‘å°±æƒ³äº†ä¸ªåŠæ³•ï¼Œè£…ä¸ªlinuxå­ç³»ç»Ÿï¼Œç”¨å­ç³»ç»Ÿè·‘ä»£ç  (åˆšå¥½VScodeæ˜¯å¾®è½¯è‡ªå·±å®¶çš„ï¼Œæ‰€ä»¥é…ç½®åœ°å¾ˆç®€å•) ã€‚\n2.ç›®çš„ åœ¨win11(10)ä¸Šå®‰è£…WSL\\(Ubuntu22.04\\)å¹¶åœ¨vscodeä¸­ä½¿ç”¨linuxå­ç³»ç»Ÿè·‘ä»£ç ã€‚(ä½äºwin10çš„å¯ä»¥é€‰æ‹©è‡ªè¡Œæ›´æ–°æˆ–æ”¾å¼ƒ)\n3.å¼€å§‹æ•´æ´» 3.1å®‰è£… æ‰“å¼€ Microsoft Store ï¼Œæœç´¢Ubuntuï¼Œå¹¶å®‰è£… (ç»å¸¸å¡é¡¿ï¼Œè¯·è€å¿ƒç­‰å¾…) å¼€å¯ç›¸å…³æœåŠ¡ æœç´¢windows åŠŸèƒ½ï¼Œå¹¶æ‰“å¼€\næ‰“å¼€ä»¥ä¸‹ä¸¤é¡¹\næŒ‰è¦æ±‚é‡å¯ä¸€æ¬¡ï¼Œå®‰è£…ç›¸å…³æœåŠ¡\nåœ¨å¼€å§‹èœå•æ‰“å¼€ Ubuntu 22.04ï¼Œå‘ç°æŠ¥é”™ (æˆ‘å½“æ—¶å¿˜äº†æˆªå›¾äº†) è§£å†³æ–¹æ¡ˆï¼š æ‰‹åŠ¨å®‰è£…WSLæ–°å†…æ ¸ï¼šWSL2 Linux kernel update package for x64 machines\nå†æ¬¡æ‰“å¼€Ubuntu 22.04 ç„¶åå‘ç°å¯ä»¥äº† ç­‰å¾…ä¸€æ®µæ—¶é—´åè¾“å…¥ä½ ä¹‹åè¦ç»™linuxç³»ç»Ÿç”¨çš„ç”¨æˆ·åå’Œå¯†ç ï¼Œå°±å¯ä»¥è¿›å»äº†ï¼Œä¼šçœ‹åˆ°ä¸€ä¸ªè¿™æ ·çš„ç•Œé¢ï¼Œè¡¨æ˜æˆåŠŸäº†ï¼ˆæ€ä¹ˆç»™æˆ‘æŠ¥äº†æ¡é”™ï¼Œå’³å’³\u0026hellip;ä¸ç”¨ç®¡ï¼Œubuntuç»å¸¸è¿™æ ·ï¼‰ã€‚\n3.2 é…ç½® VScode åœ¨æ‹“å±•ç¨‹åºæœç´¢wslï¼Œå®‰è£…ç¬¬ä¸€ä¸ª\n3.2 é…ç½® linux ç”¨è¿‡Debianç³»çš„linuxçš„äººéƒ½çŸ¥é“apt(åŒ…ç®¡ç†å™¨ï¼‰çš„ç›¸å…³æ“ä½œï¼Œä¸çŸ¥é“ä¹Ÿæ²¡äº‹ï¼Œåªéœ€è¦çŸ¥é“è¿™ç©æ„èƒ½è£…è½¯ä»¶å’Œå¸è½¯ä»¶å°±è¡Œäº†\næ›´æ–°æºå’Œè½¯ä»¶ï¼Œé˜²æ­¢å‡ºäº‹ 1 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade ç„¶åè¾“å…¥è‡ªå·±çš„å¯†ç ï¼Œå’Œwindowsä¸€ä¸ªé“ç†ï¼Œlinuxè£…è½¯ä»¶ä¹Ÿéœ€è¦ç®¡ç†å‘˜æƒé™\næ³¨æ„ï¼š ä½ è¾“å…¥çš„å¯†ç ä¸æ˜¾ç¤ºä½†æ˜¯è¾“è¿›å»äº†\nç„¶åç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œé»˜è®¤çš„æºæœ‰ç‚¹æ…¢ï¼Œæœ‰èƒ½åŠ›çš„å¯ä»¥é€‰æ‹©å…ˆå»æ¢æºï¼Œç„¶ååœ¨æ›´æ–°ï¼Œç”±äºç³»ç»Ÿæ²¡æœ‰å›¾å½¢ç•Œé¢ï¼Œæ‰€ä»¥æœ‰ç‚¹éº»çƒ¦ï¼Œå¤šç­‰ä¼šå„¿å°±å¥½äº†ã€‚\næ¢æº(å¯ä»¥ä¸åš)ï¼š\n1 sudo nano /etc/apt/sources.list ç„¶åæŠŠé‡Œé¢çš„å†…å®¹æ›¿æ¢æˆtunaçš„(æ¸…åæº)\n1 2 3 4 5 6 7 8 9 10 11 12 13 # é»˜è®¤æ³¨é‡Šäº†æºç é•œåƒä»¥æé«˜ apt update é€Ÿåº¦ï¼Œå¦‚æœ‰éœ€è¦å¯è‡ªè¡Œå–æ¶ˆæ³¨é‡Š deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse # é¢„å‘å¸ƒè½¯ä»¶æºï¼Œä¸å»ºè®®å¯ç”¨ # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse ç„¶å ctrl + Xé€€å‡ºï¼Œé€‰æ‹© Yï¼Œç„¶åæŒ‰ enter\nå†æ›´æ–°ä¸€æ¬¡æº\n1 sudo apt update å®‰è£…gccå’Œg++(Cè¯­è¨€å’ŒC++çš„ç¼–è¯‘å™¨) 1 sudo apt install gcc g++ å®‰è£… VScode æ”¯æŒ 1 code . ç­‰ä»–è·‘å®Œï¼Œå°±ä¼šå¼¹å‡ºä¸€ä¸ª VScodeçª—å£ï¼Œæ‰€ä¸‹è§’æ˜¯è¿™æ ·çš„\nè¯´æ˜å·²ç»è¿ä¸Šäº†å­ç³»ç»Ÿ\n3.4 é…ç½®linuxå­ç³»ç»Ÿçš„VScodeæ‹“å±•ç¨‹åº éœ€è¦è£…ä¸¤ä¸ªæ‹“å±•ç¨‹åº\nå¦‚æœå·²ç»è£…è¿‡äº†å°±é€‰\ncode runner é…ç½®\nå‰è¨€: ä¸æ˜¯åˆšéœ€ä½†æ˜¯å¾ˆæ–¹ä¾¿çš„è¿è¡Œä»£ç çš„å·¥å…·ï¼Œè‡ªæˆ‘æ„Ÿè§‰æ¯” [@Laffey](Laffey â€” Hashnode) çš„é‚£ä¸ªå¥½ã€‚\nä½¿ç”¨: è£…ä¸Šå»ä¹‹åæ–°å»ºä¸€ä¸ª .cppæ–‡ä»¶æ‰“å¼€åä¼šå‘ç°å³ä¸Šè§’æœ‰ä¸€ä¸ªè¿è¡ŒæŒ‰é’®ï¼Œç‚¹ä¸€ä¸‹å°±ä¼šç¼–è¯‘è¿è¡Œ(å¿«æ·é”® ctrl + alt + N)ï¼Œç¼ºç‚¹æ˜¯ä¸èƒ½è°ƒè¯•ï¼Œå› ä¸ºä»–æ˜¯é€šè¿‡ç»ˆç«¯å‘½ä»¤è¿è¡Œçš„ã€‚\nä¼˜åŒ–: æœ‰æ—¶å€™æˆ‘ä»¬å¯èƒ½ä¼šåˆ›å»ºä¸€ä¸ªåç§°æœ‰ç©ºæ ¼çš„ä»£ç æ–‡ä»¶ï¼Œç”¨code runnerç¼–è¯‘å°±ä¼šæŠ¥é”™ï¼Œå› ä¸ºç©ºæ ¼å½±å“äº†å‘½ä»¤çš„æ‰§è¡Œï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ›´æ”¹è¿è¡Œå‘½ä»¤æ¥è§£å†³\næ‰“å¼€è®¾ç½®\nåˆ‡æ¢åˆ° ubuntu 22.04 çš„æ ‡ç­¾ä¸‹ï¼Œæœ code runnerï¼Œç„¶åæŒ‰å›¾ç¤ºæ“ä½œï¼Œç‚¹å‡» Execulor Map ä¸‹çš„ Edit in settings.json\næŠŠ cpp é‚£ä¸€è¡Œæ”¹æˆè¿™ä¸ª\n1 \u0026#34;cpp\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; g++ \u0026#39;$fileName\u0026#39; -o tmp \u0026amp;\u0026amp; ./tmp\u0026#34;, ä¹‹ååœ¨ç¼–è¯‘çš„æ—¶å€™å°±ä¼šåœ¨æ”¹ç›®å½•ä¸‹ç”Ÿæˆä¸€ä¸ªåä¸º tmp çš„å¯æ‰§è¡Œæ–‡ä»¶\nå¦‚æœæœ‰éœ€è¦ç¼–è¯‘ .c æ–‡ä»¶å°±æŠŠ c å“ªä¸€è¡Œæ”¹æˆè¿™ä¸ª\n1 \u0026#34;c\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; gcc \u0026#39;$fileName\u0026#39; -o tmp \u0026amp;\u0026amp; ./tmp\u0026#34;, è¿™æ ·å°±è§£å†³äº†\n4.ä¸€äº›å°çŸ¥è¯† å‘½ä»¤(åº”è¯¥æ˜¯ä¸ªOIerå°±ä¼šå§) 1 2 3 4 5 6 7 8 cd dir # è¿›å…¥åˆ°åä¸ºdirçš„æ–‡ä»¶å¤¹ï¼Œä¹Ÿå¯ä»¥æ˜¯ç»å¯¹è·¯å¾„ cd .. # è¿”å›ä¸Šçº§ç›®å½• cd # å›åˆ°homeï¼Œç›¸å½“äºæ˜¯windowsçš„usersæ–‡ä»¶å¤¹ï¼Œå‚¨å­˜ç”¨æˆ·æ–‡ä»¶ mkdir dir # åœ¨å½“å‰ç›®å½•ä¸‹å»ºä¸€ä¸ªåä¸ºdirçš„æ–‡ä»¶å¤¹ touch abc # åœ¨å½“å‰ç›®å½•ä¸‹å»ºä¸€ä¸ªåå«abcçš„æ–‡ä»¶ï¼Œå¯ä»¥åŠ åç¼€å å¦‚ï¼šabc.cpp sudo apt install xxx # ä»è½¯ä»¶æºé‡Œå®‰è£…xxxè½¯ä»¶ï¼Œè½¯ä»¶æºé‡Œä¸ä¸€å®šæœ‰ã€‚ã€‚ã€‚ sudo apt purge xxx # å¸è½½xxxè½¯ä»¶ sudo dpkg -i xxx.deb # ä»æœ¬åœ°å®‰è£…è½¯ä»¶ï¼Œubuntuçš„åŒ…æ ¼å¼ä¸ºdeb è¿™äº›åº”è¯¥å·®ä¸å¤šå¤Ÿç”¨äº†ï¼Œå…¶å®æœ‰ä»€ä¹ˆé—®é¢˜ç›´æ¥ç™¾åº¦è‚¯å®šæœ‰ç­”æ¡ˆ\nå¥½åƒæŠŠæ–‡ä»¶æ‹·åˆ°linuxé‡Œé¢è¿è¡Œæ›´å¿«ï¼Œlinuxçš„æ–‡ä»¶åœ¨è¿™é‡Œ è¿›å»ä¹‹åæ˜¯æ ¹ç›®å½•ï¼Œæˆ‘ä»¬çš„ç”¨æˆ·æ–‡ä»¶åœ¨homeé‡Œ\nå¦‚æœå‡ºäº†é—®é¢˜å°±å»ç™¾åº¦ï¼Œä¸è¡Œå°±å»å›½é™…ç‰ˆçš„bingç”¨è‹±æ–‡æœï¼Œå†ä¸è¡Œå°±ç§‘å­¦ä¸Šç½‘å»google 5.ç»ˆäºå†™å®Œäº† å¦‚æœæœ‰ä»€ä¹ˆé”™è¯¯æ¬¢è¿æŒ‡æ­£ï¼Œè™½ç„¶å¯èƒ½ä¼šç‰¹åˆ«å†·æ²¡äººçœ‹ï¼Œæˆ‘ç›¸ä¿¡ä¸€å®šæœ‰å–œæ¬¢æŠ˜è…¾çš„äººï¼Œæ¯”å¦‚æˆ‘\n","date":"2022-08-30T08:53:39Z","permalink":"https://invalidnamee.github.io/p/wslvscode/","title":"å®‰è£…WSLå¹¶åœ¨VScodeè°ƒç”¨"},{"content":"0.é¢˜ç›®æè¿° é¢˜é¢:P3956 [NOIP2017 æ™®åŠç»„] æ£‹ç›˜\næœ‰ä¸€ä¸ª\\(m \\times m\\)çš„æ£‹ç›˜ï¼Œæ£‹ç›˜ä¸Šæ¯ä¸€ä¸ªæ ¼å­å¯èƒ½æ˜¯çº¢è‰²ã€é»„è‰²æˆ–æ²¡æœ‰ä»»ä½•é¢œè‰²çš„ã€‚ä½ ç°åœ¨è¦ä»æ£‹ç›˜çš„æœ€å·¦ä¸Šè§’èµ°åˆ°æ£‹ç›˜çš„æœ€å³ä¸‹è§’ã€‚\nä»»ä½•ä¸€ä¸ªæ—¶åˆ»ï¼Œä½ æ‰€ç«™åœ¨çš„ä½ç½®å¿…é¡»æ˜¯æœ‰é¢œè‰²çš„ï¼ˆä¸èƒ½æ˜¯æ— è‰²çš„ï¼‰ï¼Œ ä½ åªèƒ½å‘ä¸Šã€ ä¸‹ã€å·¦ã€ å³å››ä¸ªæ–¹å‘å‰è¿›ã€‚å½“ä½ ä»ä¸€ä¸ªæ ¼å­èµ°å‘å¦ä¸€ä¸ªæ ¼å­æ—¶ï¼Œå¦‚æœä¸¤ä¸ªæ ¼å­çš„é¢œè‰²ç›¸åŒï¼Œé‚£ä½ ä¸éœ€è¦èŠ±è´¹é‡‘å¸ï¼›å¦‚æœä¸åŒï¼Œåˆ™ä½ éœ€è¦èŠ±è´¹ \\(1\\) ä¸ªé‡‘å¸ã€‚\nä½ å¯ä»¥èŠ±è´¹ \\(2\\) ä¸ªé‡‘å¸å°†ä¸€ä¸ªæ— è‰²æ ¼å­æš‚æ—¶å˜æˆæŒ‡å®šçš„é¢œè‰²ï¼Œä½†æ˜¯åœ¨åˆ°è¾¾ä¸€ä¸ªåŸæœ¬å°±æœ‰é¢œè‰²çš„æ ¼å­å‰ä¸èƒ½å†æ¬¡ä½¿ç”¨ï¼Œç¦»å¼€è¯¥æ ¼å­åé¢œè‰²æ¢å¤ã€‚\næ±‚æœ€å°‘èŠ±è´¹çš„é‡‘å¸æ•°ã€‚\næœ¬æ¥çš„æè¿°å°±æŒºç®€æ´çš„ï¼Œæ‰€ä»¥å¤§éƒ¨åˆ†å¼•ç”¨çš„åŸé¢˜çš„æè¿°\n1. å¿ƒè·¯å†ç¨‹ æœ¬æ¥æˆ‘çœ‹åˆ°è¿™ä¸ªæ ¼å­ï¼Œè¿˜æ˜¯ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’ï¼Œç›´æ¥æ»¡è„‘å­éƒ½æ˜¯ dpï¼Œç„¶åå†™äº†ä¸€å¤§å †åªæœ‰ \\(50\\) åˆ†ï¼Œç„¶åæ‰å‘ç°ä»–ä¸ä¸€å®šè¦æŒ‰æ‹“æ‰‘åºèµ°æ‰æ˜¯æœ€çŸ­çš„ï¼Œæ‰€ä»¥æ­£è§£æ˜¯æœç´¢(æœ€çŸ­è·¯)ï¼Œç„¶åæœç´¢å†™äº†å››ä¸ªç‰ˆæœ¬ï¼Œæœ€åå‘ç°ç¬¬ä¸€ä¸ª(æœ€æš´åŠ›çš„é‚£ä¸ª)æ€è·¯æ˜¯å¯¹çš„ï¼Œæ¯•ç«Ÿæ•°æ®åªæœ‰ \\(100*100\\)ã€‚\n2. è§£æ 2.1 å‰è¨€ é‚£ä¸ª dp çš„é”™è¯¯æ€æƒ³å°±ä¸å¤šè¯´äº†ï¼Œè¿™ä¸ªæ€è·¯åªèƒ½åº”ä»˜éƒ¨åˆ†æŒ‰ç…§æ‹“æ‰‘åºèµ°çš„æƒ…å†µã€‚ å› ä¸ºæ­£è§£å°±æ˜¯æš´åŠ›ï¼Œæš´åŠ›å°±æ˜¯æ­£è§£ï¼Œæ‰€ä»¥è¿™ä¸ªé¢˜çš„ä»£ç é‡ä¸ç®—å¤ªå°ï¼Œè€Œä¸”éœ€è¦å¤´è„‘æ¸…é†’ 2.2 æ€è·¯ æŠŠèƒ½èµ°çš„è·¯å…¨éƒ¨å»ºä¸€æ¡è¾¹ï¼Œè¾¹æƒæ˜¯èµ°è¿‡å»æ¶ˆè€—çš„é‡‘å¸æ•°ï¼Œç„¶åå¯¹ç”Ÿæˆçš„å›¾è·‘ Dijkstraã€‚\nç®€å•çš„ä¸€å¥è¯ï¼Œä½†æ˜¯å®ç°èµ·æ¥ç¼ºä¸å¤ªå®¹æ˜“\n2.3 å®ç° ç‚¹å¦‚ä½•ç¼–å·\nå¦‚å›¾ï¼ŒæŠŠæ¯ä¸€è¡Œéƒ½æ¥ä¸Šï¼Œé¡ºç€ç¼–å·ã€‚\nä»åæ ‡å¯¹åº”åˆ°ç¼–å·çš„å‡½æ•°:\n1 2 3 int tonum(const int \u0026amp;x, const int \u0026amp;y) { return n * (x - 1) + y; } ä»ç¼–å·å¯¹åº”åˆ°åæ ‡çš„å‡½æ•°:\n1 2 3 pair\u0026lt;int, int\u0026gt; tosite(const int \u0026amp;x) { return {ceil((double)x / n), x % n == 0 ? n : x % n}; } **å»ºè¾¹é€»è¾‘ **(å¼ºçƒˆå»ºè®®å•ç‹¬å†™ä¸€ä¸ªå‡½æ•°)\nä»¥æ ·ä¾‹ä¸ºä¾‹ ï¼Œçœ‹ä¸Šé¢çš„å›¾\nè®¾å…¥ç‚¹ä¸º \\(x\\)ï¼Œå‡ºç‚¹ä¸º \\(y\\)ã€‚\né¢œè‰²(\\(C\\)) : \\(-1\\) ä¸ºæ— è‰²ï¼Œ \\(0\\) ä¸ºçº¢è‰²ï¼Œ\\(1\\) ä¸ºé»„è‰²ã€‚\n\\(c_x=-1\\) ä¸” \\(c_y=-1\\) ç”±äºä¸èƒ½è¿ç»­æ–½å±•é­”æ³•æ‰€ä»¥ä¸èƒ½èµ°ï¼Œä¸å»ºè¾¹ \\(eg.\\) \\(3\\) å’Œ \\(4\\) \\(c_x \\neq -1\\) ä¸” \\(c_y=-1\\) å¯ä»¥æ¶ˆè€—ä¸¤ä¸ªé‡‘å¸æ–½å±•é­”æ³•å°† \\(c_y\\) å˜æˆ \\(c_x\\)ï¼Œå»ºè¾¹ï¼Œè¾¹æƒä¸º \\(2\\)ã€‚ \\(eg.\\) \\(2\\) å’Œ \\(3\\) \\(c_x=-1\\) ä¸” \\(c_y\\neq-1\\) å¦‚æœèƒ½èµ°ï¼Œåˆ™ \\(x\\) å·²ç»è¢«æ–½å±•é­”æ³•ï¼Œé¢œè‰²å–å†³äºç»™ \\(x\\) æ–½å±•é­”æ³•çš„ç‚¹ï¼Œå»ºè¾¹ï¼Œè¾¹æƒä¸º \\(-1\\) ï¼Œåœ¨æ±‚æœ€çŸ­è·¯æ—¶ç‰¹åˆ¤ã€‚ \\(eg.\\) \\(8\\) å’Œ \\(13\\) \\(c_x\\neq-1\\) ä¸” \\(c_y\\neq-1\\) \\(c_x=c_y\\) å¯ä»¥ç›´æ¥èµ°ï¼Œå»ºè¾¹ï¼Œè¾¹æƒä¸º \\(0\\)ã€‚ \\(eg.\\) \\(1\\) å’Œ \\(2\\) \\(c_x\\neq c_y\\) å¯ä»¥æ¶ˆè€—ä¸€ä¸ªé‡‘å¸èµ°ï¼Œå»ºè¾¹ï¼Œè¾¹æƒä¸º \\(0\\)ã€‚ \\(eg.\\) \\(2\\) å’Œ \\(7\\) Dijkstra\nå¤§éƒ¨åˆ†å¥—æ¨¡æ¿å°±è¡Œï¼Œéœ€è¦ç‰¹åˆ¤ä¸€ä¸‹å»ºè¾¹çš„æƒ…å†µ 3ï¼Œåœ¨é˜Ÿåˆ—çš„å‚æ•°é‡Œé¢åŠ ä¸€é¡¹ï¼Œè®°å½•çˆ¶èŠ‚ç‚¹ï¼Œå½“æœåˆ°ä¸€ä¸ªè¾¹æƒä¸º \\(-1\\) çš„è¾¹æ—¶å¯¹æ¯”å®ƒå’Œå®ƒçš„éš”ä»£ç¥–å…ˆèŠ‚ç‚¹çš„é¢œè‰²ï¼Œå†³å®šå°†\\( -1\\) æ”¹æˆæ˜¯ \\(0\\) è¿˜æ˜¯ \\(1\\) ï¼Œç›¸å½“äºæ˜¯è½¬åŒ–æˆäº†å»ºè¾¹çš„æƒ…å†µ 4ã€‚\n3.æ€»ç»“ è¿™ä¸ªçœ‹ä¼¼ç®€å•çš„æš´åŠ›é¢˜ç»†èŠ‚ç‰¹åˆ«å¤šï¼Œä¸è¦å¤ªå°çœ‹ä»–äº†ï¼Œä¸€å®šè¦ä¿æŒæ¸…é†’\nAc Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;int, pii\u0026gt; piii; const int N = 110; const int M = 40010; int c[N][N]; // è®°å½•é¢œè‰² int nxt[M], ver[M], w[M], head[M]; // å­˜å›¾ int tot; int n, m; void add(int x, int y, int e) { ver[++tot] = y; w[tot] = e; nxt[tot] = head[x]; head[x] = tot; } int tonum(const int \u0026amp;x, const int \u0026amp;y) { // åæ ‡è½¬åˆ°åºå· return n * (x - 1) + y; } pair\u0026lt;int, int\u0026gt; tosite(const int \u0026amp;x) { // åºå·è½¬åˆ°åæ ‡ // è¿™é‡Œè¦æ³¨æ„ï¼Œç¨ä¸ç•™ç¥å°±é”™äº†ï¼Œä¸»è¦æ˜¯å–æ¨¡çš„é—®é¢˜ï¼Œæœ¬æ¥æ˜¯5çš„ä¼šè¢«æ¨¡æˆ0ï¼Œæ³¨æ„ç‰¹åˆ¤ return {ceil((double)x / n), x % n == 0 ? n : x % n}; } int tocol(const int \u0026amp;x) { // åºå·è½¬åˆ°é¢œè‰² return c[tosite(x).first][tosite(x).second]; } bool judge(const int \u0026amp;x, const int \u0026amp;y) { // åˆ¤æ–­æ˜¯å¦å‡ºç•Œ return x \u0026gt; 0 \u0026amp;\u0026amp; x \u0026lt;= n \u0026amp;\u0026amp; y \u0026gt; 0 \u0026amp;\u0026amp; y \u0026lt;= n; } void build(const int \u0026amp;a, const int \u0026amp;b, const int \u0026amp;x, const int \u0026amp;y) { // éš¾ç‚¹:å»ºè¾¹ if (c[a][b] == -1 \u0026amp;\u0026amp; c[x][y] == -1) return; // ä¸¤ä¸ªæ²¡æœ‰é¢œè‰²ï¼Œåªèƒ½å˜ä¸€ä¸ªï¼Œæ‰€ä»¥ä¸èƒ½èµ° else if (c[x][y] == -1) add(tonum(a, b), tonum(x, y), 2); // æœ‰ -\u0026gt; æ—  æ¶ˆè€—2ä¸ªé‡‘å¸ else if (c[a][b] == -1) add(tonum(a, b), tonum(x, y), -1); // æ—  -\u0026gt; æœ‰ è§†æƒ…å†µè€Œå®šï¼Œå…ˆå¼„æˆ-1åˆ°æ—¶å€™å†åˆ¤æ–­ else if (c[a][b] == c[x][y]) add(tonum(a, b), tonum(x, y), 0); // é¢œè‰²ç›¸åŒï¼Œæ¶ˆè€—0ä¸ªé‡‘å¸ else add(tonum(a, b), tonum(x, y), 1); // é¢œè‰²ä¸åŒï¼Œæ¶ˆè€—1ä¸ªé‡‘å¸ } int dijkstra(const int \u0026amp;s, const int \u0026amp;t) { priority_queue\u0026lt;piii, vector\u0026lt;piii\u0026gt;, greater\u0026lt;piii\u0026gt; \u0026gt; q; // pair\u0026lt;è·ç¦», \u0026lt;ç¼–å·ï¼Œçˆ¶èŠ‚ç‚¹\u0026gt; \u0026gt; int d[M]; bool v[M]; memset(d, 0x3f, sizeof(d)); memset(v, 0, sizeof(v)); d[s] = 0; q.push({0, {s, 0}}); while (!q.empty()) { int x = q.top().second.first; int fa = q.top().second.second; q.pop(); if (v[x]) continue; v[x] = 1; for (int i = head[x]; i; i = nxt[i]) { int \u0026amp;y = ver[i]; int t = w[i]; // ä¹‹å‰ç‰¹æ®Šæ ‡è®°çš„ï¼Œyä¸xçš„çˆ¶èŠ‚ç‚¹(yçš„éš”ä»£ç¥–å…ˆ)é¢œè‰²ç›¸åŒåˆ™æ¶ˆè€—0ä¸ªï¼Œä¸åŒåˆ™æ¶ˆè€—1ä¸ª // é»˜è®¤æŠŠæ²¡é¢œè‰²çš„èŠ‚ç‚¹æ ‡è®°æˆå…¶çˆ¶èŠ‚ç‚¹çš„é¢œè‰²ï¼Œæ–¹ä¾¿ç»Ÿè®¡ if (w[i] == -1) { if (tocol(fa) != tocol(y)) { t = 1; } else t = 0; } // æ­£å¸¸çš„dijkstraçš„çŠ¶æ€è½¬ç§» if (d[y] \u0026gt; d[x] + t) { d[y] = d[x] + t; q.push({d[y], {y, x}}); } } } return d[t] == 0x3f3f3f3f ? -1 : d[t]; // æ³¨æ„ç‰¹åˆ¤ä¸èƒ½åˆ°è¾¾çš„æƒ…å†µ } int main() { memset(c, -1, sizeof(c)); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; ++i) { int x, y, z; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); c[x][y] = z; } for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { // å»ºè¾¹ï¼Œæ³¨æ„åˆ¤æ–­æœ‰æ²¡å‡ºç•Œ if (judge(i + 1, j)) build(i, j, i + 1, j); if (judge(i, j + 1)) build(i, j, i, j + 1); if (judge(i - 1, j)) build(i, j, i - 1, j); if (judge(i, j - 1)) build(i, j, i, j - 1); } } printf(\u0026#34;%d\\n\u0026#34;, dijkstra(1, tonum(n, n))); return 0; } ","date":"2022-08-30T08:37:16Z","permalink":"https://invalidnamee.github.io/p/noip-2017/","title":"[noip 2017 æ™®åŠç»„] æ£‹ç›˜"},{"content":"0.é¢˜ç›®æè¿° é¢˜é¢:P2680 [NOIP2015 æé«˜ç»„] è¿è¾“è®¡åˆ’ åœ¨ä¸€æ£µæ ‘ä¸­ï¼Œå°†ä»»æ„ä¸€æ¡è¾¹çš„è¾¹æƒæ”¹ä¸º0 (ä»¥ä¸‹ç§°â€œåˆ è¾¹â€) ï¼Œä½¿å¾—æ‰€æœ‰è¯¢é—®ä¸­ä¸¤ä¸ªç‚¹ä¹‹é—´è·ç¦»çš„æœ€å¤§å€¼æœ€å°(æ¶ˆè€—çš„æ—¶é—´æœ€å°‘)\n1.å¿ƒè·¯å†ç¨‹ æè¿°å¾ˆç®€å•ï¼Œä¹Ÿå¾ˆå®¹æ˜“æŠ½è±¡æˆä¸€æ£µæ ‘ï¼Œä½†æ˜¯å¦‚ä½•å®ç°æ˜¯ä¸ªå¤§é—®é¢˜ï¼Œè€Œä¸”è¿™é“é¢˜æ•°æ®èŒƒå›´å¾ˆå¤§ï¼Œ 0(n^2) çš„ç®—æ³•è‚¯å®šä¼šè¢«å¡æ‰ï¼Œæ‰€ä»¥ä¸€ä¸‹å­æƒ³å‡ºæ­£è§£å°±å¾ˆéš¾ï¼Œå¯ä»¥å…ˆä»æš´åŠ›çš„åšæ³•å‡ºå‘ï¼Œå¯ä»¥æ‹¿ 50 åˆ†ï¼Œç„¶åå†å»æƒ³æ­£è§£ã€‚\næˆ‘å½“æ—¶æ˜¯å†™å®Œæš´åŠ›åæƒ³ä¸å‡ºæ­£è§£ï¼Œå»çœ‹äº†åˆ«äººçš„é¢˜è§£æ‰èŒ…å¡é¡¿å¼€ã€‚ã€‚ã€‚\n2.æš´åŠ›åšæ³• 2.1 æš´åŠ›æ€è·¯ éå¸¸ç®€å•ï¼Œä¾æ¬¡æŠŠæ¯æ¡è¾¹çš„è¾¹æƒéƒ½æ”¹æˆ 0 è¯•ä¸€éï¼Œæ‰¾æœ€å°çš„ç­”æ¡ˆå³å¯ã€‚\n2.2 æš´åŠ›éšœç¢ å¿«é€Ÿæ±‚æ ‘ä¸Šä¸¤ç‚¹çš„è·ç¦»\nè¿™ä¸ªå¯ä»¥é€šè¿‡åœ¨æ ‘ä¸Šç»´æŠ¤å‰ç¼€å’Œå®ç°ï¼Œç»´æŠ¤æ¯ä¸ªç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»dï¼Œx å’Œ y çš„è·ç¦» dis[x,y]=d[x]+d[y]-2*lca[x,y] (1å·ç‚¹åˆ° x çš„è·ç¦»åŠ ä¸Š 1 å·ç‚¹åˆ° y çš„è·ç¦»å‡å»å¤šç®—ä¸¤æ¬¡çš„ lca[x,y] åˆ° 1å·ç‚¹çš„è·ç¦»å³å¯)\nå»ºç«‹ç‚¹å’Œè¾¹çš„å…³ç³»\næŠŠè¾¹æƒä¸‹æ”¾åˆ°å‡ºç‚¹ä¸Šï¼Œåœ¨ä¸€æ£µæ ‘ä¸Šä»¥åŒä¸€ä¸ªç‚¹ä¸ºå‡ºç‚¹çš„è¾¹åªæœ‰ä¸€ä¸ªï¼Œå¯ä»¥é€šè¿‡ç©·ä¸¾ç‚¹æ¥ç©·ä¸¾è¾¹ï¼Œâ€œåˆ é™¤â€ä¸€æ¡è¾¹æ—¶ï¼Œåªéœ€éå†åˆ°è¿™æ¡è¾¹çš„å‡ºç‚¹æ—¶ä¸è®¡ç®—å½“å‰è¾¹çš„æƒå€¼å³å¯ã€‚\nä¸ä¼šèƒŒ lca\nâ€‹\té‚£ä½ åšä¸ªç´«é¢˜å¹²ä»€ä¹ˆï¼Ÿ\nâ€‹\n2.4 æš´åŠ›ä»£ç  æ—¶é—´å¤æ‚åº¦ä¸º O(n^2) ï¼Œåªèƒ½è¿‡ä¸€åŠçš„æ•°æ® 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 300010; struct Node{ // lcaï¼Œèµ·ç‚¹ï¼Œç»ˆç‚¹ int fa, x, y; // é¢„å¤„ç†å¥½lcaä¸ç„¶æ¯æ¬¡éƒ½é‡ç®—ä¸€æ¬¡æ—¶é—´å¤æ‚åº¦å°±ä¸Šå»äº† }query[N]; int nxt[N * 2], w[N * 2], ver[N * 2], head[N]; // é“¾å¼å‰å‘æ˜Ÿ int d[N]; // æ‰€æœ‰ç‚¹åˆ°1å·ç‚¹çš„è·ç¦» int tot; int f[N][20], dep[N]; // æ ‘ä¸Šå€å¢æ±‚lca int len; void add(int x, int y, int e) { ver[++tot] = y; w[tot] = e; nxt[tot] = head[x]; head[x] = tot; } void init(int x) { for (int i = 1; i \u0026lt;= 18; ++i) { f[x][i] = f[f[x][i - 1]][i - 1]; } for (int i = head[x]; i; i = nxt[i]) { int y = ver[i], e = w[i]; if (y == f[x][0]) continue; // é˜²æ­¢å›æœ dep[y] = dep[x] + 1; f[y][0] = x; init(y); } } int lca(int x, int y) { if (dep[x] \u0026gt; dep[y]) swap(x, y); for (int i = 18; i \u0026gt;= 0; --i) { if (dep[f[y][i]] \u0026gt;= dep[x]) y = f[y][i]; } if (x == y) return x; for (int i = 18; i \u0026gt;= 0; --i) { if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; } return f[x][0]; } void dfs(int x, int pos) { for (int i = head[x]; i; i = nxt[i]) { int y = ver[i], e = w[i]; if (y == f[x][0]) continue; if (y == pos) d[y] = d[x]; // posç‚¹çš„å…¥è¾¹çš„è¾¹æƒè§†ä¸º0 else d[y] = d[x] + e; dfs(y, pos); } } int main() { int n, m; int res = 0x3f3f3f3f; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt; n; ++i) { int x, y, e; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;e); add(x, y, e), add(y, x, e); } dep[1] = 1; init(1); for (int i = 1; i \u0026lt;= m; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); query[++len] = {lca(x, y), x, y}; // æå‰ç»´æŠ¤å¥½lcaï¼Œå¦åˆ™TLE } for (int pos = 2; pos \u0026lt;= n; ++pos) { // ç©·ä¸¾â€œåˆ æ‰â€çš„è¾¹ï¼Œ1å·ç‚¹(æ ¹èŠ‚ç‚¹)æ²¡æœ‰å…¥è¾¹ memset(d, 0, sizeof(d)); // æ¯æ¬¡é‡ç®—è·ç¦» dfs(1, pos); int maxn = 0; for (int i = 1; i \u0026lt;= len; ++i) { int x = query[i].x, y = query[i].y, fa = query[i].fa; int dis = d[x] + d[y] - 2 * d[fa]; // ä¸¤ç‚¹çš„è·ç¦» maxn = max(maxn, dis); // è€—æ—¶æœ€å¤§çš„ä¸€ç»„çš„æ—¶é—´ä¸ºæ¶ˆè€—çš„æ—¶é—´ } res = min(res, maxn); } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } 3.æ­£è§£ 3.1 æ€è·¯ ä»”ç»†è§‚å¯Ÿè¿™é“é¢˜ï¼Œå¯ä»¥å‘ç°ç­”æ¡ˆæ˜¯å•è°ƒçš„ï¼šå½“ç­”æ¡ˆè¿‡å¤§çš„æ—¶å€™ä¸ç”¨â€œåˆ è¾¹â€ï¼Œå½“ç­”æ¡ˆè¿‡å°çš„æ—¶å€™åˆ ä¸€æ¡è¾¹ä¸èƒ½æ»¡è¶³æ¡ä»¶ï¼Œå› æ­¤å¯ä»¥ç”¨äºŒåˆ†ç­”æ¡ˆçš„æ€è·¯åšè¿™é“é¢˜ã€‚\n3.2 éš¾ç‚¹ ä»£ç é‡æŒºå¤§ï¼Œåšå¥½å¿ƒç†å‡†å¤‡\nåˆ¤æ–­å‡½æ•°çš„è®¾è®¡\nå¦‚ä½•æ£€éªŒç›®å‰çš„ mid æ˜¯å¦åˆæ³•æ˜¯è¿™é“é¢˜çš„æœ€å¤§çš„éš¾ç‚¹\nåšæ³•æ˜¯åœ¨â€œåˆ è¾¹â€å‰å°†æ‰€æœ‰è¯¢é—®ä¸­é•¿åº¦å¤§äº mid çš„è·¯å¾„ç­›å‡ºæ¥ï¼Œç„¶åæ‰¾å‡ºæ‰€æœ‰é•¿åº¦å¤§äº mid çš„è¾¹ç»è¿‡çš„è·¯å¾„ä¸­æœ€å¤§çš„ä¸€æ¡è¾¹ï¼Œæ£€éªŒæœ€é•¿çš„è·¯å¾„å‡å»æœ€å¤§è¾¹åæ˜¯å¦å¤§äº midã€‚\nå¦‚æœå¤§äº mid ï¼Œè¡¨æ˜è¿˜éœ€è¦åˆ æ›´å¤šçš„è¾¹æ‰èƒ½æ»¡è¶³è¦æ±‚æˆ–ä¸èƒ½æ»¡è¶³è¦æ±‚ï¼Œmid å–å°äº†\nå¦‚æœå°äºæˆ–ç­‰äº mid ï¼Œè¡¨æ˜â€œåˆ è¾¹â€åçŠ¶æ€åˆæ³•æˆ–ä¸éœ€è¦åˆ è¾¹ï¼Œmid å–å¤§äº†(æ­¤æ—¶ mid å¯èƒ½æ˜¯ç­”æ¡ˆ)\nåˆ¤æ–­å‡½æ•°çš„å®ç°\néå†æ¯ç»„è¯¢é—®ï¼Œç»Ÿè®¡å¤§äº mid çš„è·¯å¾„æ¡æ•° cntï¼Œå¹¶è®°å½•æœ€é•¿è·¯å¾„ maxnã€‚\nåˆ¤æ–­ä¸€æ¡è¾¹æ˜¯å¦è¢«æ‰€æœ‰é•¿åº¦å¤§äº mid çš„è·¯å¾„ç»è¿‡ã€‚ ï¼ˆéš¾ç‚¹ï¼‰\nç»Ÿè®¡æ¯æ¡è¾¹è¢«é•¿åº¦å¤§äº mid çš„è·¯å¾„ç»è¿‡çš„æ¬¡æ•° s[i]ï¼Œå¦‚æœ s[i]=cntï¼Œè¡¨æ˜è¿™æ¡è¾¹è¢«æ‰€æœ‰é•¿åº¦å¤§äº mid çš„è·¯å¾„ç»è¿‡ã€‚s æ•°ç»„å¯ä»¥é€šè¿‡æ ‘ä¸Šå·®åˆ†å®ç° ( è¾¹æƒå·®åˆ† )ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(m+n)ã€‚\néå†æ‰€æœ‰çš„è¾¹ w[i]ï¼Œåˆ¤æ–­ maxn-w[i] ä¸ mid çš„å…³ç³»ã€‚\n4.æé†’ å†æ¬¡æé†’ï¼Œæå‰ç»´æŠ¤å¥½ lcaï¼Œå¦åˆ™æ—¶é—´å¤æ‚åº¦ä¼šé€€åŒ–ï¼Œå¯¼è‡´ TLEã€‚\nè¿˜æ˜¯ï¼Œçœ‹æ‡‚äº†å°±è‡ªå·±å…ˆå†™ï¼Œå†™ä¸åŠ¨äº†å†æ¥çœ‹ä»£ç \nAc Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 300010; struct Node{ int fa, x, y; }query[N]; int nxt[N * 2], w[N * 2], ver[N * 2], head[N]; int d[N], s[N], w_ver[N]; /** * d[N]ä¸ºåˆ°1å·ç‚¹çš„è·ç¦» * s[N]ä¸ºå·®åˆ†æ•°ç»„ * w_ver[N]ä¸ºæ¯ä¸ªç‚¹å…¥è¾¹çš„è¾¹æƒ */ int tot, n, m; int f[N][21], dep[N]; void add(int x, int y, int e) { ver[++tot] = y; w[tot] = e; nxt[tot] = head[x]; head[x] = tot; } void init(int x) { for (int i = 1; i \u0026lt;= 20; ++i) { f[x][i] = f[f[x][i - 1]][i - 1]; } for (int i = head[x]; i; i = nxt[i]) { const int \u0026amp;y = ver[i], \u0026amp;e = w[i]; if (y == f[x][0]) continue; dep[y] = dep[x] + 1; f[y][0] = x; d[y] = d[x] + e; // ç»´æŠ¤è·ç¦» w_ver[y] = e; // ç»´æŠ¤å…¥è¾¹çš„è¾¹æƒ init(y); } } int lca(int x, int y) { if (dep[x] \u0026gt; dep[y]) swap(x, y); for (int i = 20; i \u0026gt;= 0; --i) { if (dep[f[y][i]] \u0026gt;= dep[x]) y = f[y][i]; } if (x == y) return x; for (int i = 20; i \u0026gt;= 0; --i) { if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; } return f[x][0]; } void dfs(int x) { // å¯¹å·®åˆ†æ•°ç»„è¿›è¡Œå‰ç¼€å’Œè¿ç®—ï¼Œæ±‚å‡ºæ¯æ¡è¾¹è¢«ç»è¿‡çš„æ¬¡æ•° for (int i = head[x]; i; i = nxt[i]) { const int \u0026amp;y = ver[i]; if (y == f[x][0]) continue; dfs(y); s[x] += s[y]; } } bool judge(int mid) { memset(s, 0, sizeof(s)); // æ¯æ¬¡åˆå§‹åŒ–å·®åˆ†æ•°ç»„ int maxn = 0, cnt = 0; // maxnä¸ºæœ€å¤§è·¯å¾„é•¿åº¦ï¼Œcntä¸ºé•¿åº¦å¤§äºmidçš„è·¯å¾„æ¡æ•° for (int i = 1; i \u0026lt;= m; ++i) { int x = query[i].x, y = query[i].y, fa = query[i].fa; int dis = d[x] + d[y] - 2 * d[fa]; if (dis \u0026gt; mid) { maxn = max(dis, maxn); ++s[x], ++s[y]; s[fa] -= 2; ++cnt; } } if (!maxn) return true; // ä¸ç”¨åˆ è¾¹ï¼Œè¯´æ˜midå–å¤§äº†ï¼Œç›´æ¥å¾€å·¦æ‰¾ï¼Œå¦‚æœä¸ä¼˜åŒ–ä¼šTLEä¸€ä¸ªç‚¹ dfs(1); for (int i = 1; i \u0026lt;= n; ++i) { // æœ€é•¿è·¯å¾„å‡å»æœ€é•¿è¾¹å°äºmidï¼ŒçŠ¶æ€åˆæ³•ï¼Œæ­¤midå’Œæ›´å°çš„midéƒ½å¯èƒ½æ˜¯ç­”æ¡ˆï¼Œå‘å·¦æ‰¾ if (s[i] == cnt \u0026amp;\u0026amp; maxn - w_ver[i] \u0026lt;= mid) return true; } return false; // åˆ äº†ä¸€æ¡è¾¹è¿˜ä¸å¤Ÿï¼Œè¯´æ˜midå–å°äº† } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt; n; ++i) { int x, y, e; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;e); add(x, y, e), add(y, x, e); } dep[1] = 1; init(1); for (int i = 1; i \u0026lt;= m; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;query[i].x, \u0026amp;query[i].y); query[i].fa = lca(query[i].x, query[i].y); } int l = 0, r = 300000000; // 3e5 * 1e3ï¼Œç­”æ¡ˆæœ€å¤§æ˜¯ 3e8 while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (judge(mid)) r = mid; // midè‡ªèº«ä¹Ÿå¯èƒ½æ˜¯ç­”æ¡ˆï¼Œä¸è¦èˆæ‰ else l = mid + 1; } printf(\u0026#34;%d\\n\u0026#34;, l); return 0; } ","date":"2022-08-30T08:37:12Z","permalink":"https://invalidnamee.github.io/p/noip2015/","title":"[noip2015 æé«˜ç»„] è¿è¾“è®¡åˆ’"},{"content":"é™©äº›æŠŠ@Laffeyçš„é¢˜æŠ¢äº†\næ³¨æ„å®¡é¢˜ï¼ï¼å› ä¸ºå®¡é¢˜å‡ºäº†å¾ˆå¤šé—®é¢˜ã€‚\nè¿™é¢˜ä¸€çœ¼çœ‹ä¸‹å»å¾ˆæ— ä»ä¸‹æ‰‹ï¼Œç®€å•æ¥è¯´å°±æ˜¯è·ç¦»ä¸º2çš„ä¸¤ä¸ªç‚¹çš„æƒå€¼ä¹‹ç§¯ä¸ºè”åˆæƒå€¼ï¼Œè®©æ±‚æœ€å¤§è”åˆæƒå€¼å’Œæ‰€æœ‰è”åˆæƒå€¼çš„æ€»å’Œ\nä»”ç»†æ€è€ƒä¸€ä¸‹ï¼Œä¸€æ£µæ ‘ä¸­å­˜åœ¨ä¸¤ä¸ªè·ç¦»ä¸º2çš„ç‚¹åªæœ‰ä¸¤ç§æƒ…å†µï¼Œä¸€æ¡çº¿å’Œä¸€ä¸ªè§’ï¼š\næ•°æ®æœ‰ 60% åœ¨ 2000 ä»¥å†…ï¼Œ è¿™ä½¿æˆ‘èŒç”Ÿäº†æš´åŠ›çš„æƒ³æ³•ï¼Œå…ˆæ‹¿60å†è¯´\næš´æœæ€æƒ³(DFS) I. ä¸€æ¡çº¿ è¿™ç§å¾ˆå¥½æƒ³ï¼Œåªéœ€åœ¨dfsçš„åŸºç¡€ä¸Šè®°å½•ä¸€ä¸ªå‰é©±preï¼Œè‹¥å½“å‰çˆ¶èŠ‚ç‚¹ä¸ºxï¼Œå­èŠ‚ç‚¹ä¸ºyï¼Œé‚£ä¹ˆpreä¸yçš„è·ç¦»ä¸º2ï¼Œw[pre] * w[j]å’Œw[j] * w[pre]æ˜¯ä¸¤ä¸ªè”åˆæƒå€¼ã€‚\nä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 void dfs(int x, int pre) { v[x] = 1; for(int i = head[x]; i; i = nxt[i]) { int \u0026amp; y = to[i]; if(!v[y]) { dfs(y, x); maxn = max(maxn, w[y] * w[pre]); sum += w[y] *w[pre] * 2; sum %= MOD; } } } è¿™ä¸ªæ—¶å€™ï¼Œæ ·ä¾‹è¿‡äº†ï¼Œå› ä¸ºæ ·ä¾‹æ˜¯å•é“¾ï¼ï¼\nII.ä¸€ä¸ªè§’ è¿™ç§æƒ…å†µéš¾åº¦å°±ç¨å¾®å¤§äº†ä¸€äº›ï¼Œéœ€ç»Ÿè®¡åŒä¸€å±‚æ‰€æœ‰å­èŠ‚ç‚¹ï¼Œå¯¹å…¶è¿›è¡Œæ’åˆ—ç»„åˆï¼Œæ¯ç§é…å¯¹çš„æƒ…å†µéƒ½æ˜¯ä¸¤ç»„è”åˆæƒå€¼ã€‚ (å¯ä»¥å¯¹æ¯”ä¹‹å‰åšè¿‡çš„ä¸€é“æ·±æœ é€‰æ•°)\nä¸¾ä¸ªæ —å­ï¼š\nè¿™æ˜¯ä¸€ä¸ªä»¥â‘ ä¸ºæ ¹çš„å­æ ‘\næœåˆ°â‘¡æ—¶ï¼Œæ— æ³•é…å¯¹ï¼Œç»§ç»­æœç´¢\næœå¾—åˆ°â‘¢æ—¶ï¼Œå¯ä¸â‘¡ç»„åˆ\næœåˆ°â‘£æ—¶ï¼Œå¯ä¸â‘¡å’Œâ‘¢ç»„åˆ\nåˆšå¥½ä¸é‡ä¸æ¼\næˆ‘ä»¬çš„æ€è·¯æ˜¯æœåˆ°æ¯ä¸€ä¸ªå­èŠ‚ç‚¹åå‘å›æœç´¢åŒå±‚çš„å­èŠ‚ç‚¹ï¼Œåˆ†åˆ«è®¡ç®—ï¼Œä¸ºæ­¤æˆ‘ä»¬è¦è®°å½•å½“å‰çˆ¶èŠ‚ç‚¹ä¸‹çš„å·²æœè¿‡çš„å­èŠ‚ç‚¹ï¼Œç›´æ¥å¼€N * Nçš„æ•°ç»„ä¼šçˆ†too largeæ‰€ä»¥æˆ‘ä»¬å¼€vector\u0026lt;int\u0026gt; son[N]\nåšæ³•æ˜¯æ¯æœåˆ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå…ˆå›æœåŒä¸€å±‚çš„å­èŠ‚ç‚¹è¿›è¡Œæ“ä½œï¼Œç„¶åå°†å…¶ç¼–å·å­˜å…¥sonæ•°ç»„ä¸­ä¸ºä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä½¿ç”¨ï¼Œåœ¨åŸdfsåŠ å…¥\n1 2 3 4 5 6 for(auto i : son[x]) { maxn = max(maxn, w[y] * w[i]); sum += w[y] * w[i] * 2; sum %= MOD; } son[x].push_back(y); è¿™æ ·ï¼Œä¸€ä¸ªæš´åŠ›çš„åšæ³•å°±å®Œæˆäº†ã€‚\næš´åŠ›ï¼ˆ70åˆ†ï¼‰ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 4000010; const int MOD = 10007; typedef long long ll; //è®°å¾—å¼€long longä¸ç„¶å–æ¨¡ä¹‹å‰å®¹æ˜“çˆ† ll maxn; ll sum; bool v[N]; int to[N], head[N], nxt[N]; ll w[N]; vector\u0026lt;int\u0026gt; son[N]; int tot = 0; void add(int x, int y) { to[++tot] = y; nxt[tot] = head[x]; head[x] = tot; } void dfs(int x, int pre) { v[x] = 1; for(int i = head[x]; i; i = nxt[i]) { int \u0026amp; y = to[i]; if(!v[y]) { dfs(y, x); for(auto i : son[x]) { maxn = max(maxn, w[y] * w[i]); sum += w[y] * w[i] * 2; sum %= MOD; } son[x].push_back(y); maxn = max(maxn, w[y] * w[pre]); sum += w[y] * w[pre] * 2; sum %= MOD; } } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt; n; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); add(x, y); add(y, x); } for(int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;w[i]); dfs(1, 0); printf(\u0026#34;%lld %lld\u0026#34;, maxn, sum); return 0; } ä¼˜åŒ– DFS -\u0026gt; æ ‘å½¢DP I.ä¸€ä¸ªè§’ ä¸€æ¡çº¿çš„æ—¶é—´å¤æ‚åº¦å·²ç»ä¸å¤§äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬å…ˆæ¥è€ƒè™‘ä¸€ä¸ªè§’çš„æƒ…å†µ\nå†ä¸¾ä¸ªç›¸åŒçš„æ —å­:\nå›é¡¾ä¸€ä¸‹ï¼Œä»¥â‘£ä¸ºä¾‹\n$$ sum = sum + 2 \\times w[2] \\times w[4] + 2 \\times w[3] \\times w[4] = 2 \\times w[4] \\times (w[2] + w[3]) $$ä¹˜æ³•åˆ†é…å¾‹ï¼Œæ˜ç™½å§\næ¨å¹¿åˆ°ä¸€èˆ¬çš„çˆ¶èŠ‚ç‚¹x,å­èŠ‚ç‚¹y\n$$ sum = sum + 2 \\times w[y] \\times s(w[yå‰æ‰€æœ‰å­èŠ‚ç‚¹]) $$åŒæ ·æœ€å€¼ä¹Ÿå¯ä»¥è¿™ä¹ˆæ“ä½œ\n$$ maxn = max(maxn, w[y] \\times \\max(w[yå‰æ‰€æœ‰çš„å­èŠ‚ç‚¹])) $$æ‰€ä»¥å¤„ç†è¿™ç§æƒ…å†µåªéœ€ç»´æŠ¤ä¸€ä¸ªå‰ç¼€å’Œs[N]å’Œä¸€ä¸ªæœ€å€¼m[N]å°±å¯ä»¥å®ŒæˆçŠ¶æ€è½¬ç§»ï¼Œæ— éœ€éå†ä¸€éã€‚\n1 2 3 4 5 6 sum += 2 * s[x] * w[y]; sum %= MOD; maxn = max(maxn, m[x] * w[y]); //æ³¨æ„å…ˆå¤„ç†sumå’Œmaxnå†è½¬ç§»çŠ¶æ€ï¼Œå› ä¸ºåä¹‹w[y]ä¼š * w[y]è‡ªå·±é€ æˆé—®é¢˜ s[x] += w[y]; m[x] = max(m[x], w[y]); æŠŠä¹‹å‰çš„å¾ªç¯æ¢æ‰å°±å¯ä»¥aæ‰äº†\nII.ä¸€æ¡çº¿ å½“dfså›æº¯åˆ°xæ—¶\n$$ s[y] = sum(w[yçš„æ‰€æœ‰å­©å­])\\\\ m[y] = max(w[yçš„æ‰€æœ‰å­©å­]) $$ä½ å‘ç°äº†ä»€ä¹ˆï¼Ÿ\nå…¶å®åœ¨åšä¸Šä¸€æ¬¡ä¼˜åŒ–çš„æ—¶å€™ä¸€æ¡çº¿çš„æƒ…å†µä¹Ÿå·²ç»é¢„å¤„ç†å¥½äº†ï¼Œåªéœ€\n1 2 sum += 2 * s[y] * w[x]; maxn = max(maxn, m[y] * w[x]); å°±okäº†\nè¿™æ ·ä¹Ÿä¸ç”¨å†ç»Ÿè®¡å‰é©±äº†\nAcä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 400010; const int MOD = 10007; typedef long long ll; bool v[N]; int to[N], head[N], nxt[N]; //å‰å‘æ˜Ÿ ll s[N], m[N], w[N]; /** * s[i]è¡¨ç¤ºä»¥iä¸ºé¡¶çš„ä¸€å±‚å­æ ‘èŠ‚ç‚¹æƒå€¼å’Œ * m[i]è¡¨ç¤ºä»¥iä¸ºé¡¶çš„ä¸€å±‚å­æ ‘èŠ‚ç‚¹æƒå€¼æœ€å€¼ */ ll maxn = 0, sum = 0; int tot = 0; void add(int x, int y) { to[++tot] = y; nxt[tot] = head[x]; head[x] = tot; } void dp(int x) { v[x] = 1; for(int i = head[x]; i; i = nxt[i]) { int \u0026amp; y = to[i]; if(!v[y]) { dp(y); // case corner sum += 2 * s[x] * w[y]; sum %= MOD; maxn = max(maxn, m[x] * w[y]); //case line è¿™ä¸ªæ”¾åˆ°å“ªé‡Œéƒ½è¡Œï¼Œä¸å½“å‰å±‚çš„yæƒå€¼æ— å…³ sum += 2 * s[y] * w[x]; sum %= MOD; maxn = max(maxn, m[y] * w[x]); //dp s[x] += w[y]; m[x] = max(m[x], w[y]); } } } int main() { int n; //read scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt; n; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); add(x, y); add(y, x); } for(int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;w[i]); //dp dp(1); printf(\u0026#34;%lld %lld\u0026#34;, maxn, sum); return 0; } ","date":"2022-08-30T08:37:07Z","permalink":"https://invalidnamee.github.io/p/noip2014/","title":"[noip2014 æé«˜ç»„] è”åˆæƒå€¼"},{"content":"0.é¢˜ç›®æè¿° é¢˜é¢:[NOI2015] è½¯ä»¶åŒ…ç®¡ç†å™¨\nè¿™é“é¢˜æ˜¯å…³äºlinuxçš„è½¯ä»¶ä¾èµ–å…³ç³»ã€‚\nä¾èµ–å…³ç³»æˆä¸€é¢—ä»¥ 0 å·è½¯ä»¶ä¸ºæ ¹çš„æ ‘ã€‚æ±‚å®‰è£…æˆ–åˆ é™¤ä¸€ä¸ªè½¯ä»¶éœ€è¦æ›´æ”¹çš„è½¯ä»¶åŒ…æ•°\n1.åšé¢˜ç»å† è¿™ä¸ªé¢˜æˆ‘ä¸€ä¸Šæ¥åŠä¸ªå°æ—¶å·¦å³å°±æƒ³åˆ°äº†è§£æ³•ï¼Œä½†æ˜¯åˆ°ä»Šå¤©æ‰å®ç°ï¼Œå› ä¸ºä»–å®åœ¨æ˜¯å¤ªæ¶å¿ƒï¼Œä»£ç é‡å¤ªå¤§ï¼Œæ²¡åŠæ³•ã€‚åšé¢˜çš„è¿‡ç¨‹ä¸­é‡å†™äº†ä¸¤æ¬¡ä»£ç ï¼Œç¬¬äºŒæ¬¡ç–¯ç‹‚è°ƒè¯•ï¼Œæœ€åæ‰è°ƒå¯¹ã€‚æå‰æé†’å¤§å®¶ä¸è¦æ”¾å¼ƒ\n2.è§£æ 2.1 æ€è·¯ ä¹‹å‰ä¹Ÿæåˆ°äº†è¿™é“é¢˜å¯ä»¥æŠ½è±¡æˆä¸€é¢—ä»¥ 0 ä¸ºæ ¹çš„æ ‘è¿›è¡Œæ€è€ƒï¼š\nå®‰è£…ä¸€ä¸ªè½¯ä»¶ a ï¼Œéœ€è¦å®‰è£…ä» a åˆ° 0 è·¯å¾„ä¸Šæ‰€æœ‰çš„è½¯ä»¶\nå¸è½½ä¸€ä¸ªè½¯ä»¶ bï¼Œéœ€è¦å¸è½½ä»¥ b ä¸ºæ ¹çš„å­æ ‘ä¸­çš„æ‰€æœ‰è½¯ä»¶\nç”±æ­¤å¯çŸ¥è¿™é“é¢˜å’Œæ ‘ä¸Šçš„åŒºé—´ä¿®æ”¹æŸ¥è¯¢æœ‰å…³ï¼Œå¯ä»¥ç”¨æ ‘é“¾å‰–åˆ†æ¥åšã€‚\n2.2 å®ç° ä¸‹æ–‡ä¸­çš„æ•°ç»„çš„å£°æ˜å’Œå‡½æ•°åŸå‹ä¸ºï¼š\n1 2 3 4 5 6 7 int dep[N], cnt[N]; // æ·±åº¦ å­æ ‘èŠ‚ç‚¹ä¸ªæ•° int id[N] // æ ‘ä¸Šçš„æ¯ä¸ªç‚¹æ˜ å°„åˆ°çº¿æ®µæ ‘ä¸Šçš„ä½ç½® void modify(int u, int l, int r, int k); // çº¿æ®µæ ‘åŒºé—´ä¿®æ”¹ void modify(int x, int y, int k); // æ ‘å‰–åŒºé—´ä¿®æ”¹ void query(int u, int l, int r); // çº¿æ®µæ ‘åŒºé—´æŸ¥è¯¢ void query(int x, int y); // æ ‘å‰–åŒºé—´æŸ¥è¯¢ ä¸€ä¸ªè½¯ä»¶åªæœ‰ä¸¤ä¸ªçŠ¶æ€ï¼šå·²å®‰è£…ï¼Œæœªå®‰è£…ã€‚ä¸ºäº†æ–¹ä¾¿ç»Ÿè®¡ï¼Œè®¡å·²å®‰è£…ä¸º 1, æœªå®‰è£…ä¸º 0 ç”±æ­¤å¯çŸ¥ï¼š\nå®‰è£…ä¸€ä¸ªè½¯ä»¶ aï¼Œéœ€è¦å®‰è£…çš„è½¯ä»¶æ•°é‡ä¸º dep[a] - query(0, a)ï¼Œæ‰§è¡Œçš„æ“ä½œæ˜¯ modify(0,a,1)\nå¸è½½ä¸€ä¸ªè½¯ä»¶ bï¼Œéœ€è¦å¸è½½çš„è½¯ä»¶æ•°é‡ä¸º query(1, id[b], id[b] + cnt[b] - 1) ï¼Œæ‰§è¡Œçš„æ“ä½œæ˜¯ modify(1, id[b].id[b]+cnt[b]-1,0)\nå®ç°çš„æ€è·¯ä¹Ÿå¾ˆç®€å•ï¼Œéš¾çš„æ˜¯è¿™é“é¢˜æœ‰å¾ˆå¤šçš„å‘ï¼Œä¸€ä¸å°å¿ƒå°±è¿›å»äº† awa\n2.3 å‘ ä» 0 ç¼–å·æ”¹æˆä» 1 ç¼–å· é—®é¢˜ï¼šå¦‚æœä» 0 ç¼–å·é“¾å¼å‰å‘æ˜Ÿå’Œçº¿æ®µæ ‘éƒ½ä¼šå‡ºä¸€äº›è¯¡å¼‚çš„é—®é¢˜ï¼Œè«åå…¶å¦™å¾—æœç´¢ç›´æ¥æŒ‚äº†ï¼Œçº¿æ®µæ ‘éƒ½æ˜¯ 0 (å¯èƒ½æ˜¯æˆ‘å¤ªå¼±äº†)\nè§£å†³ï¼šæŠŠè¯»å…¥çš„æ¯ä¸ªç‚¹çš„ç¼–å·éƒ½åŠ  1\nçº¿æ®µæ ‘ç›´æ¥èµ‹å€¼ é—®é¢˜ï¼šéš¾ä»¥è®¡ç®—æ¯ä¸ªç‚¹éœ€è¦åŠ å¤šå°‘ï¼Œå› ä¸ºæœ‰çš„ç‚¹ä¸ç”¨åŠ ï¼Œæœ‰çš„ç‚¹ç”¨åŠ  (è½¯ä»¶å·²ç»è£…äº†ä¸ç”¨å†è£…ä¸€æ¬¡)\nè§£å†³ï¼šå®‰è£…æ—¶ç›´æ¥æŠŠåŒºé—´èµ‹å€¼æˆåŒºé—´é•¿åº¦ï¼Œå¸è½½æ—¶ç›´æ¥å°†åŒºé—´æ”¹æˆ 0\nåˆ°è¿™é‡Œé—®é¢˜å°±å·²ç»è§£å†³äº†ï¼Œæ€è·¯ç®€å•ä¹Ÿå¥½ç†è§£ï¼Œå°±æ˜¯å†™ä»£ç å¾ˆè‰°éš¾ï¼Œæœ€åè´´ä¸Šæˆ‘çš„ä»£ç ï¼Œå®åœ¨å†™ä¸å‡ºæ¥äº†æˆ–è€…æ‰¾ä¸å‡ºé”™çš„å¯ä»¥å‚è€ƒä¸€ä¸‹ï¼Œé‡Œé¢ä¹Ÿæœ‰ä¸€äº›è°ƒè¯•çš„æ€è·¯ã€‚\nAc Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; struct SegmentTree{ int l, r; int val, lazy; // è¿™é¢—æ ‘ä¸­ lazy çš„æœ‰æ•ˆå€¼åªèƒ½æ˜¯ 0 æˆ– 1, æŠŠ lazy çš„åˆå€¼èµ‹æˆ -1 ä»¥é˜²æ›´æ–°é”™è¯¯(ä¸‹æ”¾æ‡’æ ‡è®°æ—¶, å…¨æˆ 0 äº†) SegmentTree() {lazy = -1;} }tr[N * 4]; int nxt[N], ver[N], head[N]; int tot; int fa[N], dep[N], son[N], cnt[N]; int id[N], rnk[N], top[N]; int times; void add(int x, int y ) { ver[++tot] = y; nxt[tot] = head[x]; head[x] = tot; } void dfs(int x) { cnt[x] = 1; for (int i = head[x]; i; i = nxt[i]) { int \u0026amp;y = ver[i]; if (y == fa[x]) continue; fa[y] = x; dep[y] = dep[x] + 1; dfs(y); cnt[x] += cnt[y]; if (cnt[son[x]] \u0026lt; cnt[y]) son[x] = y; } } void dfs(int x, int tp) { top[x] = tp; id[x] = ++times; rnk[times] = x; if (!son[x]) return; dfs(son[x], tp); for (int i = head[x]; i; i = nxt[i]) { int \u0026amp;y = ver[i]; if (y == fa[x] || y == son[x]) continue; dfs(y, y); } } void push_up(int u) { tr[u].val = tr[u \u0026lt;\u0026lt; 1].val + tr[u \u0026lt;\u0026lt; 1 | 1].val; } void push_down(int u) { // è¦è£…è¿™ä¸ªåŒºé—´å†…çš„éƒ½å¾—è£…, åŒæ ·, è¦å¸éƒ½å¾—å¸ if (tr[u].lazy == -1) return; // æ²¡æœ‰æ‡’æ ‡è®°çš„ä¸ç®— tr[u \u0026lt;\u0026lt; 1].lazy = tr[u].lazy; tr[u \u0026lt;\u0026lt; 1 | 1].lazy = tr[u].lazy; tr[u \u0026lt;\u0026lt; 1].val = tr[u].lazy * (tr[u \u0026lt;\u0026lt; 1].r - tr[u \u0026lt;\u0026lt; 1].l + 1); tr[u \u0026lt;\u0026lt; 1 | 1].val = tr[u].lazy * (tr[u \u0026lt;\u0026lt; 1 | 1].r - tr[u \u0026lt;\u0026lt; 1 | 1].l + 1); tr[u].lazy = -1; // æ¸…ç©ºåå˜æˆ -1, ä¸è¦æ”¹æˆ 0, 0ä¹Ÿæ˜¯æœ‰æ•ˆæ•°å­—, å¦åˆ™ä¸‹æ”¾æ‡’æ ‡è®°åéƒ½æˆ 0 äº† } void build(int u, int l, int r) { tr[u].l = l, tr[u].r = r; if (l == r) return; // ç›´æ¥å°±æ˜¯ 0, é»˜è®¤éƒ½æ²¡è£… int mid = l + r \u0026gt;\u0026gt; 1; build (u \u0026lt;\u0026lt; 1, l, mid), build(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r); } void modify(int u, int l, int r, int k) { if (l \u0026lt;= tr[u].l \u0026amp;\u0026amp; tr[u].r \u0026lt;= r) { // æ³¨æ„ï¼Œç›´æ¥èµ‹å€¼ï¼Œå¦åˆ™è¿˜å¾—å¤šå†™ä¸€ä¸ª query å¢å¤§å¸¸æ•°æ—¶é—´å¤æ‚åº¦è¿˜å®¹æ˜“é”™ tr[u].lazy = k; tr[u].val = k * (tr[u].r - tr[u].l + 1); } else { push_down(u); int mid = tr[u].l + tr[u].r \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) modify(u \u0026lt;\u0026lt; 1, l, r, k); if (r \u0026gt; mid) modify(u \u0026lt;\u0026lt; 1 | 1, l, r, k); push_up(u); } } void modify(int x, int y, int k) { while (top[x] != top[y]) { if (dep[top[x]] \u0026gt; dep[top[y]]) swap(x, y); modify(1, id[top[y]], id[y], k); y = fa[top[y]]; } if (dep[x] \u0026gt; dep[y]) swap(x, y); modify(1, id[x], id[y], k); } int query(int u, int l, int r) { if (l \u0026lt;= tr[u].l \u0026amp;\u0026amp; tr[u].r \u0026lt;= r) return tr[u].val; else { push_down(u); int mid = tr[u].l + tr[u].r \u0026gt;\u0026gt; 1; int res = 0; if (l \u0026lt;= mid) res += query(u \u0026lt;\u0026lt; 1, l, r); if (r \u0026gt; mid) res += query(u \u0026lt;\u0026lt; 1 | 1, l, r); return res; } } int query(int x, int y) { int res = 0; while (top[x] != top[y]) { if (dep[top[x]] \u0026gt; dep[top[y]]) swap(x, y); res += query(1, id[top[y]], id[y]); y = fa[top[y]]; } if (dep[x] \u0026gt; dep[y]) swap(x, y); res += query(1, id[x], id[y]); return res; } void print(int u) { // æ£€æŸ¥çº¿æ®µæ ‘ç”¨çš„ï¼Œè¾“å‡ºæ¯ä¸ªç‚¹çš„å€¼ if (tr[u].l == tr[u].r) { printf(\u0026#34;%d \u0026#34;, tr[u].val); } else { push_down(u); // è®°å¾—ä¸‹æ”¾æ‡’æ ‡è®° print(u \u0026lt;\u0026lt; 1), print(u \u0026lt;\u0026lt; 1 | 1); } } int main() { int n, m; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 2; i \u0026lt;= n; ++i) { // ä¸€å®šè¦è¿™ä¹ˆå†™, åæœä¸å ªè®¾æƒ³ int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); add(t + 1, i); } dep[1] = 1; dfs(1); dfs(1, 1); build(1, 1, n); scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); while (m--) { string s; int t; cin \u0026gt;\u0026gt; s, scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); ++t; // ä¸€å®šè¦è¿™ä¹ˆå†™, åæœä¸å ªè®¾æƒ³ if (s == \u0026#34;install\u0026#34;) { printf(\u0026#34;%d\\n\u0026#34;, dep[t] - query(1, t)); modify(1, t, 1); } else { printf(\u0026#34;%d\\n\u0026#34;, query(1, id[t], id[t] + cnt[t] - 1)); modify(1, id[t], id[t] + cnt[t] - 1, 0); } } return 0; } ","date":"2022-08-30T08:36:53Z","permalink":"https://invalidnamee.github.io/p/noi2015/","title":"[noi2015] è½¯ä»¶åŒ…ç®¡ç†å™¨"},{"content":"å› ä¸ºäººåœ¨å­¦æ ¡æ—¶é—´æ¯”è¾ƒè¦ç´§å°±å†™ç®€å•ä¸€äº›\né¢˜é¢: P5752 [NOI1999] æ£‹ç›˜åˆ†å‰²\nè¿™é“é¢˜è‡ªå·±æ²¡æƒ³å‡ºæ¥ï¼Œç»“åˆ zsh çš„ ppt å’Œæ´›è°·ä¸Šçš„é¢˜è§£æ‰ææ˜ç™½\nè¿™é“é¢˜æ¶‰åŠåˆ°åˆ†å‰²å’Œæœ€å€¼ï¼Œæ‰€ä»¥ç›®æ ‡å°±é”å®šåœ¨åŒºé—´dpï¼Œåœ¨æƒ³dpä¹‹å‰ä¹Ÿæœ‰å‡ ä¸ªè¦å¤„ç†çš„é—®é¢˜\n1.æ•°å­¦é—®é¢˜ è¿™é“é¢˜è¦æ±‚æ ‡å‡†å·®ï¼Œä½†æ˜¯å› ä¸ºæœ‰æ ¹å·å¾ˆéš¾æï¼Œæ‰€ä»¥å¯ä»¥å…ˆç”¨æ–¹å·®ç®—\n$$ s^2 = (\\frac{1}{n} \\sum^n_{i = 1}{x_i^2}) - \\bar x^2\\\\ \\sigma = \\sqrt {s^2} $$è¿™æ ·åªéœ€æ±‚å‡º \\( \\sum_{i = 1}^{n}{x_i^2} \\)å†å¥—å…¬å¼å³å¯æ±‚å‡ºç­”æ¡ˆ\n2.äºŒç»´å‰ç¼€å’Œ å› ä¸ºè¿™é“é¢˜éœ€è¦å¤šæ¬¡è®¡ç®—ä¸€ä¸ªå—å†…çš„æƒå€¼çš„å’Œï¼Œç»´æŠ¤ä¸€ä¸ªäºŒç»´çš„å‰ç¼€å’Œä¼šå¾ˆæ–¹ä¾¿ï¼Œå¤ä¹ ä¸€ä¸‹\nç»´æŠ¤å‰ç¼€å’Œ\n1 2 3 4 5 for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { s[i][j] = a[i][j] + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; } } è®¡ç®—ä» $(x_1, y_1)$ åˆ°$(x_2, y_2)$ çš„å‰ç¼€å’Œ\n1 2 3 int get_sum(int x1, int y1, int x2, int y2) { return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; } 3.åŒºé—´dp æ€è·¯\ndpçš„å¤§è‡´æ€è·¯æ˜¯ç»´æŠ¤æ¯ä¸€ä¸ªäºŒç»´åŒºé—´å†…åˆ†å‰² $k$ æ¬¡åæ¯ä¸€å—çš„æ€»å’Œçš„å¹³æ–¹é™¤ä»¥ $n$ åçš„ç»“æœçš„å’Œçš„æœ€å°å€¼ï¼Œç›®æ ‡æ˜¯ f[1][1][8][8][k]ï¼Œç»“æœæ˜¯ sqrt(f[1][1][8][8][n] - ave * aveã€‚ï¼ˆave ä¸ºå¹³å‡å€¼ $\\bar x$ï¼‰\nçŠ¶æ€\nè¡¨ç¤ºä¸€ä¸ªäºŒç»´åŒºé—´è‡³å°‘éœ€è¦ $4$ ä¸ªå‚æ•°(å·¦ä¸Šè§’åæ ‡å’Œå³ä¸‹è§’åæ ‡)ï¼Œæ‰€ä»¥ $f$ æ•°ç»„è¦å¼€äº”ç»´ï¼Œå³ f[9][9][9][9][15]ï¼Œ\nf[x1][y1][x2][y2][k]è¡¨ç¤ºä» $(x_1,y_1)$ åˆ° $(x_2,y_2)$ è¿™æ®µåŒºé—´å†…åˆ†å‰² $k$ æ¬¡åæ¯ä¸ªå­åŒºé—´çš„æƒå€¼å’Œ $s$ çš„ $\\frac{s^2}{n}$ çš„å’Œçš„æœ€å°å€¼\né‡ç‚¹ â€”â€”æšä¸¾åˆ†å‰²ç‚¹\nå› ä¸ºåªèƒ½ç æˆä¸¤åŠï¼Œæ‰€ä»¥å¯ä»¥åˆ†åˆ«æšä¸¾æ¨ªå‘åˆ†å‰²çš„åˆ†å‰²ç‚¹çš„çºµåæ ‡å’Œçºµå‘åˆ†å‰²çš„åˆ†å‰²ç‚¹çš„æ¨ªåæ ‡ï¼Œç„¶åçŠ¶æ€è½¬ç§»\n1 2 3 4 5 6 7 8 9 10 for (int t = x1; t \u0026lt; x2; ++t) { // æšä¸¾çºµåæ ‡ f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k], min(f[t + 1][y1][x2][y2][k - 1] + getf(x1, y1, t, y2), // ä¸Šä¾§å·²è¢«åˆ†å‰² k - 1 æ¬¡ f[x1][y1][t][y2][k - 1] + getf(t + 1, y1, x2, y2))); // ä¸‹ä¾§å·²è¢«åˆ†å‰² k - 1 æ¬¡ } for (int t = y1; t \u0026lt; y2; ++t) { // æšä¸¾æ¨ªåæ ‡ f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k], min(f[x1][t + 1][x2][y2][k - 1] + getf(x1, y1, x2, t), // å·¦ä¾§å·²è¢«åˆ†å‰² k - 1 æ¬¡ f[x1][y1][x2][t][k - 1] + getf(x1, t + 1, x2, y2))); // å³ä¾§å·²è¢«åˆ†å‰² k - 1 æ¬¡ } å…¶ä¸­ getf ä¸º\n1 2 3 4 double getf(int x1, int y1, int x2, int y2) { double tmp = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; return tmp * tmp / n; } æœ€åçœ‹ä¸€ä¸‹ä»£ç  æˆ‘å°±çŸ¥é“ä½ å†™ä¸å‡ºæ¥ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int a[9][9]; double s[9][9], f[9][9][9][9][15]; int n; double getf(int x1, int y1, int x2, int y2) { double tmp = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; return tmp * tmp / n; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= 8; ++i) { for (int j = 1; j \u0026lt;= 8; ++j) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); s[i][j] = a[i][j] + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; // äºŒç»´å‰ç¼€å’Œ } } double ave = s[8][8] / n; for (int k = 1; k \u0026lt;= n; ++k) { for (int x2 = 1; x2 \u0026lt;= 8; ++x2) { for (int y2 = 1; y2 \u0026lt;= 8; ++y2) { for (int x1 = 1; x1 \u0026lt;= x2; ++x1) { // x1 \u0026lt;= x2 y1 \u0026lt;= y2 è¿™æ ·æšä¸¾ä¼šå¿«ä¸€ç‚¹ for (int y1 = 1; y1 \u0026lt;= y2; ++y1) { if (k == 1) { // è®°å¾—åˆå§‹åŒ– f[x1][y1][x2][y2][k] = getf(x1, y1, x2, y2); continue; } f[x1][y1][x2][y2][k] = 0x3f3f3f3f; // è®°å¾—åˆå§‹åŒ– // æ³¨æ„åŒºé—´ä¸è¦é‡å  for (int t = x1; t \u0026lt; x2; ++t) { // æšä¸¾çºµåæ ‡ f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k], min(f[t + 1][y1][x2][y2][k - 1] + getf(x1, y1, t, y2), // ä¸Šä¾§å·²è¢«åˆ†å‰² k - 1 æ¬¡ f[x1][y1][t][y2][k - 1] + getf(t + 1, y1, x2, y2))); // ä¸‹ä¾§å·²è¢«åˆ†å‰² k - 1 æ¬¡ } for (int t = y1; t \u0026lt; y2; ++t) { // æšä¸¾æ¨ªåæ ‡ f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k], min(f[x1][t + 1][x2][y2][k - 1] + getf(x1, y1, x2, t), // å·¦ä¾§å·²è¢«åˆ†å‰² k - 1 æ¬¡ f[x1][y1][x2][t][k - 1] + getf(x1, t + 1, x2, y2))); // å³ä¾§å·²è¢«åˆ†å‰² k - 1 æ¬¡ } } } } } } printf(\u0026#34;%.3lf\\n\u0026#34;, sqrt(f[1][1][8][8][n] - ave * ave)); // è¾“å‡ºç»“æœ } ","date":"2022-08-29T12:58:51Z","permalink":"https://invalidnamee.github.io/p/noi1999/","title":"[noi1999] æ£‹ç›˜åˆ†å‰²"},{"content":"0. é¢˜ç›®æè¿° é¢˜é¢:P2294 [HNOI2005]ç‹¡çŒ¾çš„å•†äºº\næ£€æŸ¥ä¸€ä¸ªå•†äººçš„è´¦æœ¬æ˜¯å¦æ˜¯ä¼ªé€ çš„(ç¼©å¥å¤§å¸ˆ)ï¼Œç®€å•æ¥è¯´å°±æ˜¯å¯¹äºæ¯ä¸€ç»„æ•°æ®ï¼Œæ¯ä¸ªåŒºé—´å†…çš„ç›ˆåˆ©æ€»å’Œåº”è¯¥ä¸€è‡´ï¼Œå¦åˆ™å°±æ˜¯ä¼ªé€ çš„\n1. å¿ƒè·¯å†ç¨‹ å…¶å®çœ‹äº†æè¿°å°±è·Ÿæ²¡çœ‹ä¸€æ ·æ‡µï¼Œå› ä¸ºè¿™é“é¢˜æ¶‰åŠåˆ°åŒºé—´å’Œä¹‹ç±»çš„ä¸œè¥¿ï¼Œæ‰€ä»¥æˆ‘çš„ç¬¬ä¸€ååº”æ˜¯çº¿æ®µæ ‘ç»´æŠ¤åŒºé—´å’Œï¼Œä½†æ˜¯åæ¥å‘ç°è¿™æ ·ä¸è¡Œï¼Œå› ä¸ºä½ åªçŸ¥é“ä¸€ä¸ªåŒºé—´çš„æ€»å’Œï¼Œå¹¶ä¸çŸ¥é“æ¯ä¸ªå­åŒºé—´çš„è¯¦ç»†ä¿¡æ¯ï¼Œæ‰€ä»¥å½“è¾“å…¥çš„ä¸€ä¸ªåŒºé—´æ¨ªè·¨çº¿æ®µæ ‘çš„ä¸¤ä¸ªèŠ‚ç‚¹æ—¶å°±æ²¡åŠæ³•å¤„ç†äº†ã€‚æ‰€ä»¥ä¸å¯ä»¥ç”¨ç»´æŠ¤åŒºé—´å’Œçš„æ€æƒ³ã€‚\næ‰€ä»¥è¦æƒ³ä¸€ä¸ªåˆ«çš„æ–¹æ³•å·§å¦™åœ°è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå› åˆšå­¦äº†å·®åˆ†çº¦æŸç³»ç»Ÿï¼Œæ‰€ä»¥æˆ‘ç®€å•åœ°æƒ³åˆ°äº†å›¾è®º\n2. è§£æ 2.1 å»ºè¾¹ å¯¹äºæ¯ä¸ªåŒºé—´ \\( [l, r] \\) ï¼Œéƒ½å»ºä¸€æ¡è¾¹ \\( (l - 1) \\) -\u0026gt; \\( r \\)ï¼Œè¾¹æƒä¸ºç›ˆåˆ©å€¼ \\( a \\)\n2.2 æ€è·¯ ä¹Ÿå¾ˆç®€å•ï¼Œå¦‚æœä¸€ä¸ªåŒºé—´ \\( (l, r] \\)çš„ç›ˆåˆ©å€¼æ˜¯ \\( a \\)ï¼Œé‚£ä¹ˆæ‰€æœ‰ç”± \\( l \\) æŒ‡å‘ \\( r \\) çš„è·¯å¾„çš„é•¿åº¦åº”è¯¥éƒ½ä¸º \\( a \\) ï¼Œå¦åˆ™å°±æ˜¯å‡çš„ã€‚\nè®¡èµ·ç‚¹åˆ°ç¬¬ \\( i \\) ä¸ªç‚¹çš„è·ç¦»ä¸º \\( d[i] \\) ï¼Œé‚£ä¹ˆå½“å­˜åœ¨ä¸€æ¡èµ·ç‚¹ä¸º \\( x \\) ç»ˆç‚¹ä¸º \\( y \\) è¾¹æƒå€¼ä¸º \\( a \\) çš„è¾¹æ»¡è¶³ \\( d[y] \\neq d[x] + a \\) æ—¶ï¼Œè¿™ä¸ªè´¦å•æ˜¯å‡çš„ã€‚\n2.3 å‘ç‚¹ åŒºé—´\næ‰€æœ‰çš„åŒºé—´éƒ½è¦æ”¹æˆä¸€å¼€ä¸€é—­ï¼ˆæˆ‘è¿™é‡Œæ˜¯å‰å¼€åé—­ï¼‰ï¼Œå¦‚æœæŒ‰ç…§é¢˜ç›®çš„è¯»å…¥ç›´æ¥å»ºè¾¹å°±ä¼šé¢ä¸´ä¸€å®šçš„é—®é¢˜ã€‚\nä¾‹å¦‚:é¢˜ç›®çš„æ ·ä¾‹ç¬¬äºŒç»„\n1 2 3 4 5 3 1 5 100 3 5 50 1 2 51 å¦‚æœæŒ‰ç…§è¯»å…¥çš„æ•°æ®å»ºå›¾ï¼Œç”»æˆå›¾å°±æ˜¯è¿™æ ·å­çš„:\næ˜¾ç„¶è¿™ä¸ªæ˜¯é”™çš„ï¼Œ \\( 2 \\) å’Œ \\( 3 \\) æ˜¯ç›¸è¿çš„ã€‚ä½†æ˜¯å¦‚æœæŠŠåŒºé—´ \\( [l, r] \\) æ”¹æˆä¸€å¼€ä¸€é—­ï¼Œå³ \\( (l-1,r] \\) ï¼Œå›¾å°±ä¼šå˜æˆè¿™æ ·:\näºæ˜¯å›¾å°±è¿ä¸Šäº†ï¼ŒåŒæ—¶å› ä¸º \\( 51+50 \\neq 100 \\) ï¼Œæ‰€ä»¥ç­”æ¡ˆæ˜¯ \\( false \\)ã€‚\nå¤šèµ·ç‚¹SPFA\nå› ä¸ºå›¾ä¸­çš„æ¯ä¸ªè¿é€šå—éƒ½æ˜¯ç›¸äº’ç‹¬ç«‹ï¼Œäº’ä¸å¹²æ‰°çš„ï¼ˆæ¯ä¸ªæå¤§åŒºé—´ç›¸äº’ç‹¬ç«‹ï¼‰ï¼Œæ‰€ä»¥å¯¹äºæ¯ä¸€ä¸ªè¿é€šå—éƒ½ç‹¬ç«‹åœ°è·‘ä¸€éSPFA\nåˆ¤æ–­æ¡ä»¶\nå¯¹äºæ¯ä¸€ä¸ªè¿é€šå—å†…ï¼Œå½“ \\( d[y] = d[x] + w \\) æˆ– \\( d[y] = 0 \\) æ—¶æ›´æ–° \\( d[y] \\) ï¼Œå¹¶ä¸”å°† \\(d[y] \\) å…¥é˜Ÿï¼Œå¦åˆ™ç›´æ¥åˆ¤falseï¼Œå…¨éƒ¨æ­£å¸¸è·‘å®Œä¸ºtrueã€‚\nå¯¹äºæ•´å¼ å›¾ï¼Œå­˜åœ¨ä¸€ä¸ªè¿é€šå— falseï¼Œç›´æ¥æ˜¯ falseï¼›æ‰€æœ‰è¿é€šå—éƒ½ä¸º trueï¼Œå°±è¾“å‡º trueã€‚\næ˜ç¡®äº†æ€è·¯ä¹‹åå°±å¯ä»¥è‡ªå·±å°è¯•å†™ä¸€ä¸‹äº†ï¼Œå®åœ¨ä¸ä¼šäº†çœ‹ä¸‹é¢çš„ä»£ç ã€‚\nAc Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 1010; int nxt[N * 4], ver[N * 4], w[N * 4], head[N]; // å‰å‘æ˜Ÿå­˜å›¾ int d[N]; // è·ç¦» bool v[N]; // è®°å½•æ˜¯å¦è¢«è®¿é—®è¿‡ï¼Œè¢«è®¿é—®è¿‡çš„ç‚¹å·²ç»åœ¨åˆ«çš„è¿é€šå—ä¸­ï¼Œæ‰€ä»¥ä¸‹ä¸€æ¬¡å°±ä¸ç”¨ä»è¿™ä¸ªç‚¹å¼€å§‹æœäº† int tot; int n, m; int read() { int res = 0; char c = getchar(); bool flag = 0; while (c \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) { if (c == \u0026#39;-\u0026#39;) flag = 1; // å¿«è¯»è®°å¾—ç‰¹åˆ¤è´Ÿæ•° c = getchar(); } while (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) res = res * 10 + c - 48, c = getchar(); return flag ? -res : res; } void add(int x, int y, int e ) { ver[++tot] = y; w[tot] = e; nxt[tot] = head[x]; head[x] = tot; } void init() { memset(nxt, 0, sizeof(nxt)); memset(ver, 0, sizeof(ver)); memset(w, 0, sizeof(w)); memset(head, 0, sizeof(head)); memset(v, 0, sizeof(v)); tot = 0; // è®°å¾—åˆå§‹åŒ– tot } bool spfa(int s) { bool exist[N]; memset(exist, 0, sizeof(exist)); memset(d, 0, sizeof(d)); // è¿™ä¸ªæ¯æ¬¡éƒ½è¦é‡ç½®ï¼Œå› ä¸ºæ¯ä¸ªè¿é€šå—ï¼Œèµ·ç‚¹ä¸åŒ queue\u0026lt;int\u0026gt; q; q.push(s); v[s] = exist[s] = 1; while (!q.empty()) { int x = q.front(); q.pop(); exist[x] = 0; for (int i = head[x]; i; i = nxt[i]) { int \u0026amp;y = ver[i], \u0026amp;e = w[i]; if (d[y] == d[x] + e || d[y] == 0) { // d[y] == 0 æ—¶ï¼Œè¿™ä¸ªç‚¹æ²¡è¢«æ›´æ–°ï¼Œéœ€è¦æ›´æ–°ä¸€æ¬¡ d[y] = d[x] + e; if (!exist[y]) { exist[y] = 1; q.push(y); } } else return false; // ä¸ç›¸ç­‰ç›´æ¥å°±æ˜¯false } } return true; // ä¸€ä¸ªå—å†…æ‰€æœ‰çš„ç‚¹éƒ½æ²¡é—®é¢˜æ‰æ˜¯true } int main() { int T = read(); while (T--) { init(); // è®°å¾—åˆå§‹åŒ– n = read(), m = read(); for (int i = 1; i \u0026lt;= m; ++i) { int x = read(), y = read(), z = read(); add(x - 1, y, z); // å‰å¼€åé—­ } bool flag = 0; for (int i = 0; i \u0026lt;= n; ++i) { if (v[i]) continue; if (!spfa(i)) { // ä¸€ä¸ªæ˜¯falseè¿™ç»„æ•°æ®å°±ç›´æ¥æ˜¯false printf(\u0026#34;false\\n\u0026#34;); flag = 1; break; } } if (!flag) { printf(\u0026#34;true\\n\u0026#34;); // æ¯ä¸€ä¸ªéƒ½æ˜¯trueï¼Œè¿™ç»„æ•°æ®å°±æ˜¯true } } return 0; } ","date":"2022-08-29T12:58:44Z","permalink":"https://invalidnamee.github.io/p/hnoi2005/","title":"[hnoi2005] ç‹¡çŒ¾çš„å•†äºº"}]